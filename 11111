import asyncio
import logging
import sqlite3
import requests
import pandas as pd
from io import BytesIO
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

TOKEN = '8521733674:AAGE5DDQFmHYf5O5cLLMom0lpO7nHiCqLuo'

KGEU_API_GROUPS = 'https://kabinet.kgeu.ru/api/raspGroupList'
KGEU_API_SCHEDULE = 'https://kabinet.kgeu.ru/api/Rasp'

logging.basicConfig(level=logging.INFO)
bot = Bot(token=TOKEN)
dp = Dispatcher()
scheduler = AsyncIOScheduler(timezone="Europe/Moscow")

DB_NAME = 'bot_database_corrupted_20260219_213016.db'


def db_start():
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()

    cursor.execute("""CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        first_name TEXT,
        last_name TEXT,
        password TEXT,
        is_logged_in INTEGER DEFAULT 0,
        user_group TEXT DEFAULT '',
        group_id INTEGER DEFAULT 0
    )""")

    connect.commit()
    connect.close()
    print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∞!")


def add_user_to_db(user_id, first_name, last_name, password):
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    if cursor.fetchone() is None:
        cursor.execute(
            "INSERT INTO users (user_id, first_name, last_name, password, is_logged_in) VALUES (?, ?, ?, ?, ?)",
            (user_id, first_name, last_name, password, 1))
        connect.commit()
        connect.close()
        return True
    connect.close()
    return False


def check_login(user_id, password):
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("SELECT user_id, first_name, last_name FROM users WHERE user_id = ? AND password = ?",
                   (user_id, password))
    user = cursor.fetchone()
    if user:
        cursor.execute("UPDATE users SET is_logged_in = 1 WHERE user_id = ?", (user_id,))
        connect.commit()
        connect.close()
        return True, user[1], user[2]
    connect.close()
    return False, None, None


def logout_user(user_id):
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("UPDATE users SET is_logged_in = 0 WHERE user_id = ?", (user_id,))
    connect.commit()
    connect.close()


def is_user_registered(user_id):
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone() is not None
    connect.close()
    return result


def get_user_status(user_id):
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("SELECT is_logged_in FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    connect.close()
    return result[0] if result else 0


def save_user_group(user_id, group_name, group_id):
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("UPDATE users SET user_group = ?, group_id = ? WHERE user_id = ?", (group_name, group_id, user_id))
    connect.commit()
    connect.close()


def get_user_data(user_id):
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("SELECT user_group, group_id FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    connect.close()
    return result if result else ('', 0)



def get_all_users_with_groups():
    connect = sqlite3.connect(DB_NAME)
    cursor = connect.cursor()
    cursor.execute("""
        SELECT user_id, user_group, group_id 
        FROM users 
        WHERE group_id > 0 
        AND is_logged_in = 1
    """)
    users = cursor.fetchall()
    connect.close()
    return users


def fetch_schedule_for_today(group_id):
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
        }
        url = f'{KGEU_API_SCHEDULE}?idGroup={group_id}'
        response = requests.get(url, headers=headers, timeout=15)
        
        if response.status_code == 200:
            data = response.json()
            if data.get('state') == 1 and data.get('data'):
                return data['data']
        return None
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None


def group_lessons_by_time(lessons):
    grouped = {}
    for lesson in lessons:
        time_key = (lesson.get('–Ω–∞—á–∞–ª–æ', ''), lesson.get('–∫–æ–Ω–µ—Ü', ''))
        if time_key not in grouped:
            grouped[time_key] = []
        grouped[time_key].append(lesson)
    return grouped


def format_today_schedule(schedule_data, group_name):
    if not schedule_data or 'rasp' not in schedule_data:
        return None
    
    rasp = schedule_data['rasp']
    if not rasp:
        return None
    
    today = datetime.now().date()
    today_str = today.strftime('%Y-%m-%d')
    
    days_ru = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
    day_name = days_ru[today.weekday()]
    
    today_lessons = []
    for lesson in rasp:
        date_str = lesson.get('–¥–∞—Ç–∞', '')[:10]
        try:
            lesson_date = None
            for fmt in ['%Y-%m-%d', '%d.%m.%Y', '%d-%m-%Y']:
                try:
                    lesson_date = datetime.strptime(date_str, fmt).date()
                    break
                except ValueError:
                    continue
            
            if lesson_date == today:
                today_lessons.append(lesson)
        except:
            continue
    
    if not today_lessons:
        return None
    
    grouped = group_lessons_by_time(today_lessons)
    
    sorted_times = sorted(grouped.keys(), key=lambda x: x[0])
    
    text = f"üåÖ **–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ!**\n\n"
    text += f"üìö **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è**\n"
    text += f"üìÖ {today.strftime('%d.%m.%Y')} ({day_name})\n"
    text += f"üë• –ì—Ä—É–ø–ø–∞: **{group_name}**\n\n"
    
    pair_num = 1
    for time_key in sorted_times:
        time_start, time_end = time_key
        lessons_at_time = grouped[time_key]
        
        text += f"**{pair_num}. {time_start} - {time_end}**\n"
        
        if len(lessons_at_time) == 1:
            lesson = lessons_at_time[0]
            discipline = lesson.get('–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞', '')
            teacher = lesson.get('–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å', '')
            room = lesson.get('–∞—É–¥–∏—Ç–æ—Ä–∏—è', '')
            lesson_type = lesson.get('–≤–∏–¥', '')
            subgroup = lesson.get('–ø–æ–¥–≥—Ä—É–ø–ø–∞', '')
            
            text += f"üìñ {discipline}\n"
            if lesson_type:
                text += f"üìù {lesson_type}\n"
            if subgroup:
                text += f"üë• –ü–æ–¥–≥—Ä—É–ø–ø–∞: {subgroup}\n"
            text += f"üë®‚Äçüè´ {teacher}\n"
            text += f"üö™ –ê—É–¥. {room}\n\n"
        else:
            for idx, lesson in enumerate(lessons_at_time):
                discipline = lesson.get('–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞', '')
                teacher = lesson.get('–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å', '')
                room = lesson.get('–∞—É–¥–∏—Ç–æ—Ä–∏—è', '')
                lesson_type = lesson.get('–≤–∏–¥', '')
                subgroup = lesson.get('–ø–æ–¥–≥—Ä—É–ø–ø–∞', '')
                
                if idx > 0:
                    text += f"  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                
                text += f"üìñ {discipline}\n"
                if lesson_type:
                    text += f"üìù {lesson_type}\n"
                if subgroup:
                    text += f"üë• –ü–æ–¥–≥—Ä—É–ø–ø–∞: {subgroup}\n"
                else:
                    text += f"üë• –í–∞—Ä–∏–∞–Ω—Ç {idx + 1}\n"
                text += f"üë®‚Äçüè´ {teacher}\n"
                text += f"üö™ –ê—É–¥. {room}\n"
            text += "\n"
        
        pair_num += 1
    
    text += f"\n_–í—Å–µ–≥–æ –ø–∞—Ä: {len(sorted_times)}_"
    
    return text


async def send_daily_schedule():
    print(f"üïê [{datetime.now()}] –ó–∞–ø—É—Å–∫ —Ä–∞—Å—Å—ã–ª–∫–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...")
    
    users = get_all_users_with_groups()
    print(f"üìä –ù–∞–π–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏: {len(users)}")
    
    if not users:
        print("‚ö†Ô∏è –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏")
        return
    
    groups_cache = {}
    sent_count = 0
    error_count = 0
    no_schedule_count = 0
    
    for user_id, group_name, group_id in users:
        try:
            if group_id not in groups_cache:
                schedule = fetch_schedule_for_today(group_id)
                groups_cache[group_id] = schedule
            else:
                schedule = groups_cache[group_id]
            
            if schedule:
                schedule_text = format_today_schedule(schedule, group_name)
                
                if schedule_text:
                    await bot.send_message(
                        chat_id=user_id,
                        text=schedule_text,
                        parse_mode="Markdown"
                    )
                    sent_count += 1
                    print(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id} ({group_name})")
                else:
                    today = datetime.now()
                    days_ru = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
                    day_name = days_ru[today.weekday()]
                    
                    no_lessons_text = (
                        f"üåÖ **–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ!**\n\n"
                        f"üìÖ {today.strftime('%d.%m.%Y')} ({day_name})\n"
                        f"üë• –ì—Ä—É–ø–ø–∞: **{group_name}**\n\n"
                        f"üéâ **–°–µ–≥–æ–¥–Ω—è –Ω–µ—Ç –∑–∞–Ω—è—Ç–∏–π!**\n\n"
                        f"–•–æ—Ä–æ—à–µ–≥–æ –æ—Ç–¥—ã—Ö–∞! üòä"
                    )
                    await bot.send_message(
                        chat_id=user_id,
                        text=no_lessons_text,
                        parse_mode="Markdown"
                    )
                    no_schedule_count += 1
            else:
                error_count += 1
                print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}")
            
            # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏ —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –ª–∏–º–∏—Ç—ã Telegram
            await asyncio.sleep(0.1)
            
        except Exception as e:
            error_count += 1
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
    
    print(f"üìä –ò—Ç–æ–≥–∏ —Ä–∞—Å—Å—ã–ª–∫–∏: –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {sent_count}, –±–µ–∑ –∑–∞–Ω—è—Ç–∏–π {no_schedule_count}, –æ—à–∏–±–æ–∫ {error_count}")



def fetch_groups_from_api():
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
        }
        response = requests.get(KGEU_API_GROUPS, headers=headers, timeout=15)
        if response.status_code == 200:
            data = response.json()
            return data.get('data', [])
        return []
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä—É–ø–ø: {e}")
        return []


def search_groups(groups, query):
    query = query.upper().strip()
    found = []
    for group in groups:
        if query in group['name'].upper():
            found.append(group)
    return found[:20]


def fetch_schedule_from_api(group_id):
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
        }
        url = f'{KGEU_API_SCHEDULE}?idGroup={group_id}'
        response = requests.get(url, headers=headers, timeout=15)
        
        if response.status_code == 200:
            data = response.json()
            if data.get('state') == 1 and data.get('data'):
                return data['data']
        return None
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None



def get_schedule_dates(schedule_data):
    if not schedule_data or 'rasp' not in schedule_data:
        return []
    
    rasp = schedule_data['rasp']
    if not rasp:
        return []
    
    dates = set()
    for lesson in rasp:
        date_str = lesson.get('–¥–∞—Ç–∞', '')[:10]
        try:
            for fmt in ['%Y-%m-%d', '%d.%m.%Y', '%d-%m-%Y']:
                try:
                    lesson_date = datetime.strptime(date_str, fmt).date()
                    dates.add(lesson_date)
                    break
                except ValueError:
                    continue
        except:
            continue
    
    return sorted(list(dates))


def format_schedule_for_date(schedule_data, group_name, target_date):
    if not schedule_data or 'rasp' not in schedule_data:
        return None
    
    rasp = schedule_data['rasp']
    if not rasp:
        return None
    
    days_ru = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
    day_name = days_ru[target_date.weekday()]
    
    day_lessons = []
    for lesson in rasp:
        date_str = lesson.get('–¥–∞—Ç–∞', '')[:10]
        try:
            lesson_date = None
            for fmt in ['%Y-%m-%d', '%d.%m.%Y', '%d-%m-%Y']:
                try:
                    lesson_date = datetime.strptime(date_str, fmt).date()
                    break
                except ValueError:
                    continue
            
            if lesson_date == target_date:
                day_lessons.append(lesson)
        except:
            continue
    
    if not day_lessons:
        return None
    
    grouped = group_lessons_by_time(day_lessons)
    
    sorted_times = sorted(grouped.keys(), key=lambda x: x[0])
    
    today = datetime.now().date()
    if target_date == today:
        relative = "—Å–µ–≥–æ–¥–Ω—è"
    elif target_date == today + timedelta(days=1):
        relative = "–∑–∞–≤—Ç—Ä–∞"
    elif target_date == today - timedelta(days=1):
        relative = "–≤—á–µ—Ä–∞"
    else:
        relative = ""
    
    text = f"üìö **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {target_date.strftime('%d.%m.%Y')}**\n"
    text += f"üìÖ {day_name}"
    if relative:
        text += f" ({relative})"
    text += f"\nüë• –ì—Ä—É–ø–ø–∞: **{group_name}**\n\n"
    
    pair_num = 1
    for time_key in sorted_times:
        time_start, time_end = time_key
        lessons_at_time = grouped[time_key]
        
        text += f"**{pair_num}. {time_start} - {time_end}**\n"
        
        if len(lessons_at_time) == 1:
            lesson = lessons_at_time[0]
            discipline = lesson.get('–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞', '')
            teacher = lesson.get('–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å', '')
            room = lesson.get('–∞—É–¥–∏—Ç–æ—Ä–∏—è', '')
            lesson_type = lesson.get('–≤–∏–¥', '')
            subgroup = lesson.get('–ø–æ–¥–≥—Ä—É–ø–ø–∞', '')
            
            text += f"üìñ {discipline}\n"
            if lesson_type:
                text += f"üìù {lesson_type}\n"
            if subgroup:
                text += f"üë• –ü–æ–¥–≥—Ä—É–ø–ø–∞: {subgroup}\n"
            text += f"üë®‚Äçüè´ {teacher}\n"
            text += f"üö™ –ê—É–¥. {room}\n\n"
        else:
            for idx, lesson in enumerate(lessons_at_time):
                discipline = lesson.get('–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞', '')
                teacher = lesson.get('–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å', '')
                room = lesson.get('–∞—É–¥–∏—Ç–æ—Ä–∏—è', '')
                lesson_type = lesson.get('–≤–∏–¥', '')
                subgroup = lesson.get('–ø–æ–¥–≥—Ä—É–ø–ø–∞', '')
                
                if idx > 0:
                    text += f"  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                
                text += f"üìñ {discipline}\n"
                if lesson_type:
                    text += f"üìù {lesson_type}\n"
                if subgroup:
                    text += f"üë• –ü–æ–¥–≥—Ä—É–ø–ø–∞: {subgroup}\n"
                else:
                    text += f"üë• –í–∞—Ä–∏–∞–Ω—Ç {idx + 1}\n"
                text += f"üë®‚Äçüè´ {teacher}\n"
                text += f"üö™ –ê—É–¥. {room}\n"
            text += "\n"
        
        pair_num += 1
    
    text += f"_–í—Å–µ–≥–æ –ø–∞—Ä: {len(sorted_times)}_"
    
    return text


def get_week_days_keyboard(schedule_data, current_week_offset=0):
    today = datetime.now().date()
    
    week_start = today - timedelta(days=today.weekday()) + timedelta(weeks=current_week_offset)
    
    days_ru_short = ['–ü–Ω', '–í—Ç', '–°—Ä', '–ß—Ç', '–ü—Ç', '–°–±', '–í—Å']
    
    available_dates = set(get_schedule_dates(schedule_data)) if schedule_data else set()
    
    keyboard = []
    row = []
    
    for i in range(7):
        day_date = week_start + timedelta(days=i)
        day_str = day_date.strftime('%d.%m')
        day_name = days_ru_short[i]
        
        has_lessons = day_date in available_dates
        
        if day_date == today:
            btn_text = f"üìç {day_name} {day_str}"
        elif has_lessons:
            btn_text = f"üìö {day_name} {day_str}"
        else:
            btn_text = f"‚ûñ {day_name} {day_str}"
        
        row.append(InlineKeyboardButton(
            text=btn_text,
            callback_data=f"schedule_day_{day_date.strftime('%Y-%m-%d')}"
        ))
        
        if len(row) == 2:
            keyboard.append(row)
            row = []
    
    if row:
        keyboard.append(row)
    
    nav_row = []
    if current_week_offset > -2:  # –ù–µ –±–æ–ª—å—à–µ 2 –Ω–µ–¥–µ–ª—å –Ω–∞–∑–∞–¥
        nav_row.append(InlineKeyboardButton(
            text="‚¨ÖÔ∏è –ü—Ä–µ–¥. –Ω–µ–¥–µ–ª—è",
            callback_data=f"schedule_week_{current_week_offset - 1}"
        ))
    
    if current_week_offset < 4:  # –ù–µ –±–æ–ª—å—à–µ 4 –Ω–µ–¥–µ–ª—å –≤–ø–µ—Ä–µ–¥
        nav_row.append(InlineKeyboardButton(
            text="–°–ª–µ–¥. –Ω–µ–¥–µ–ª—è ‚û°Ô∏è",
            callback_data=f"schedule_week_{current_week_offset + 1}"
        ))
    
    if nav_row:
        keyboard.append(nav_row)
    
    if current_week_offset != 0:
        keyboard.append([InlineKeyboardButton(
            text="üìç –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ —Ç–µ–∫—É—â–µ–π –Ω–µ–¥–µ–ª–µ",
            callback_data="schedule_week_0"
        )])
    
    keyboard.append([InlineKeyboardButton(text="‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="close_schedule")])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_day_navigation_keyboard(current_date_str, week_offset=0):
    current_date = datetime.strptime(current_date_str, '%Y-%m-%d').date()
    prev_date = current_date - timedelta(days=1)
    next_date = current_date + timedelta(days=1)
    
    keyboard = [
        [
            InlineKeyboardButton(
                text="‚¨ÖÔ∏è –ü—Ä–µ–¥. –¥–µ–Ω—å",
                callback_data=f"schedule_day_{prev_date.strftime('%Y-%m-%d')}"
            ),
            InlineKeyboardButton(
                text="–°–ª–µ–¥. –¥–µ–Ω—å ‚û°Ô∏è",
                callback_data=f"schedule_day_{next_date.strftime('%Y-%m-%d')}"
            )
        ],
        [InlineKeyboardButton(
            text="üìÖ –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –¥–µ–Ω—å",
            callback_data=f"schedule_week_{week_offset}"
        )],
        [InlineKeyboardButton(text="‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="close_schedule")]
    ]
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)



class AuthState(StatesGroup):
    reg_name = State()
    reg_surname = State()
    reg_password = State()
    login_password = State()


class GroupState(StatesGroup):
    search_group = State()


def get_main_menu():
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton(text="üìù –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è"), KeyboardButton(text="üîë –í—Ö–æ–¥")],
        [KeyboardButton(text="üö™ –í—ã—Ö–æ–¥"), KeyboardButton(text="‚ÑπÔ∏è –û –±–æ—Ç–µ")]
    ], resize_keyboard=True)


def get_logged_menu():
    # –£–ë–†–ê–ù–ê –∫–Ω–æ–ø–∫–∞ "üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è" - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–∏—Ö–æ–¥—è—Ç –≤—Å–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    return ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton(text="üë• –í—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É"), KeyboardButton(text="üìÖ –ú–æ—ë —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")],
        [KeyboardButton(text="üìÖ –ù–∞ —Å–µ–≥–æ–¥–Ω—è")],
        [KeyboardButton(text="üì± –ú–æ–±–∏–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"), KeyboardButton(text="üåê –°–∞–π—Ç")],
        [KeyboardButton(text="üö™ –í—ã—Ö–æ–¥"), KeyboardButton(text="‚ÑπÔ∏è –û –±–æ—Ç–µ")]
    ], resize_keyboard=True)


def get_cancel_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_process")]
    ])


def get_back_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_menu")]
    ])


def get_search_results_keyboard(groups):
    keyboard = []
    for group in groups:
        keyboard.append([InlineKeyboardButton(
            text=f"{group['name']} ({group['kurs']} –∫—É—Ä—Å)",
            callback_data=f"select_group_{group['id']}"
        )])
    
    keyboard.append([InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_process")])
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_app_links_keyboard():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üçé App Store", url="https://apps.apple.com/ru/app/–∫–≥—ç—É-—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ/id1544568777")],
        [InlineKeyboardButton(text="üì± Google Play", url="https://play.google.com/store/apps/details?id=ru.kgeu.rasp")],
        [InlineKeyboardButton(text="üî∑ AppGallery", url="https://appgallery.huawei.com/app/C103667171")]
    ])



@dp.message(CommandStart())
async def cmd_start(message: types.Message, state: FSMContext):
    await state.clear()
    user_id = message.from_user.id
    if is_user_registered(user_id):
        if get_user_status(user_id) == 1:
            text = "üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º!\n\nüöÄ –ë–æ—Ç –ö–ì–≠–£ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!\n\nüîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å –ø—Ä–∏—Ö–æ–¥–∏—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ 07:00"
            await message.answer(text, parse_mode="Markdown", reply_markup=get_logged_menu())
        else:
            text = "üëã –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã, –Ω–æ –Ω–µ –≤–æ—à–ª–∏.\n–ù–∞–∂–º–∏—Ç–µ 'üîë –í—Ö–æ–¥'."
            await message.answer(text, parse_mode="Markdown", reply_markup=get_main_menu())
    else:
        text = "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!\n–ù–∞–∂–º–∏—Ç–µ 'üìù –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è' –¥–ª—è —Å—Ç–∞—Ä—Ç–∞."
        await message.answer(text, parse_mode="Markdown", reply_markup=get_main_menu())


@dp.message(F.text == "üìù –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è")
async def btn_register(message: types.Message, state: FSMContext):
    await state.clear()
    if is_user_registered(message.from_user.id):
        await message.answer("‚ö†Ô∏è –í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!", reply_markup=get_main_menu())
        return
    await state.set_state(AuthState.reg_name)
    await message.answer("üìù –í–≤–µ–¥–∏—Ç–µ **–ò–º—è**:", parse_mode="Markdown", reply_markup=get_cancel_kb())


@dp.message(AuthState.reg_name)
async def process_reg_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(AuthState.reg_surname)
    await message.answer("üìù –í–≤–µ–¥–∏—Ç–µ **–§–∞–º–∏–ª–∏—é**:", parse_mode="Markdown", reply_markup=get_cancel_kb())


@dp.message(AuthState.reg_surname)
async def process_reg_surname(message: types.Message, state: FSMContext):
    await state.update_data(surname=message.text)
    await state.set_state(AuthState.reg_password)
    await message.answer("üîí –ü—Ä–∏–¥—É–º–∞–π—Ç–µ **–ü–∞—Ä–æ–ª—å** (–º–∏–Ω. 4 –∑–Ω–∞–∫–∞):", parse_mode="Markdown", reply_markup=get_cancel_kb())


@dp.message(AuthState.reg_password)
async def process_reg_password(message: types.Message, state: FSMContext):
    if len(message.text) < 4:
        await message.answer("‚ö†Ô∏è –ö–æ—Ä–æ—Ç–∫–∏–π –ø–∞—Ä–æ–ª—å! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:")
        return
    data = await state.get_data()
    success = add_user_to_db(message.from_user.id, data['name'], data['surname'], message.text)
    await state.clear()
    if success:
        await message.answer(f"‚úÖ **–£—Å–ø–µ—à–Ω–æ!**\n\nüöÄ –í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è\n\nüîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å –±—É–¥–µ—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ 07:00", parse_mode="Markdown",
                             reply_markup=get_logged_menu())
    else:
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞.", reply_markup=get_main_menu())


@dp.message(F.text == "üîë –í—Ö–æ–¥")
async def btn_login(message: types.Message, state: FSMContext):
    await state.clear()
    if not is_user_registered(message.from_user.id):
        await message.answer("‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å!", reply_markup=get_main_menu())
        return
    if get_user_status(message.from_user.id) == 1:
        await message.answer("‚úÖ –í—ã —É–∂–µ –≤–æ—à–ª–∏!", reply_markup=get_logged_menu())
        return
    await state.set_state(AuthState.login_password)
    await message.answer("üîí –í–≤–µ–¥–∏—Ç–µ **–ü–∞—Ä–æ–ª—å**:", parse_mode="Markdown", reply_markup=get_cancel_kb())


@dp.message(AuthState.login_password)
async def process_login_password(message: types.Message, state: FSMContext):
    success, name, surname = check_login(message.from_user.id, message.text)
    await state.clear()
    if success:
        await message.answer(f"‚úÖ **–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω!**\n{name} {surname}\n\nüöÄ **–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:**", parse_mode="Markdown",
                             reply_markup=get_logged_menu())
    else:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å.", reply_markup=get_main_menu())


@dp.message(F.text == "üö™ –í—ã—Ö–æ–¥")
async def btn_logout(message: types.Message, state: FSMContext):
    await state.clear()
    logout_user(message.from_user.id)
    await message.answer("üö™ –í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.", reply_markup=get_main_menu())


@dp.message(F.text == "üìÖ –ù–∞ —Å–µ–≥–æ–¥–Ω—è")
async def btn_today_schedule(message: types.Message):
    user_id = message.from_user.id
    group_name, group_id = get_user_data(user_id)
    
    if not group_id:
        await message.answer("‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É! –ù–∞–∂–º–∏—Ç–µ 'üë• –í—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É'", reply_markup=get_logged_menu())
        return
    
    await message.answer("‚è≥ –ó–∞–≥—Ä—É–∂–∞—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è...")
    schedule = fetch_schedule_for_today(group_id)
    
    if schedule:
        schedule_text = format_today_schedule(schedule, group_name)
        if schedule_text:
            schedule_text = schedule_text.replace("üåÖ **–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ!**\n\n", "")
            await message.answer(schedule_text, parse_mode="Markdown", reply_markup=get_logged_menu())
        else:
            today = datetime.now()
            days_ru = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
            day_name = days_ru[today.weekday()]
            await message.answer(
                f"üìÖ {today.strftime('%d.%m.%Y')} ({day_name})\n"
                f"üë• –ì—Ä—É–ø–ø–∞: **{group_name}**\n\n"
                f"üéâ **–°–µ–≥–æ–¥–Ω—è –Ω–µ—Ç –∑–∞–Ω—è—Ç–∏–π!**",
                parse_mode="Markdown",
                reply_markup=get_logged_menu()
            )
    else:
        await message.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ.\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", reply_markup=get_logged_menu())



@dp.message(F.text == "üë• –í—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É")
async def btn_select_group(message: types.Message, state: FSMContext):
    await state.set_state(GroupState.search_group)
    await message.answer(
        "üîç **–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã**\n\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: `–≠–°-1-23` –∏–ª–∏ `–ê–¢–ü-2-22`\n\n"
        "–ú–æ–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞:",
        parse_mode="Markdown",
        reply_markup=get_cancel_kb()
    )


@dp.message(GroupState.search_group)
async def process_group_search(message: types.Message, state: FSMContext):
    query = message.text.strip()
    
    if len(query) < 2:
        await message.answer("‚ö†Ô∏è –í–≤–µ–¥–∏—Ç–µ –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞", reply_markup=get_cancel_kb())
        return
    
    await message.answer("‚è≥ –ò—â—É –≥—Ä—É–ø–ø—É...")
    
    groups = fetch_groups_from_api()
    if not groups:
        await message.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", reply_markup=get_logged_menu())
        await state.clear()
        return
    
    found_groups = search_groups(groups, query)
    
    if not found_groups:
        await message.answer(
            f"‚ùå –ì—Ä—É–ø–ø–∞ **{query}** –Ω–µ –Ω–∞–π–¥–µ–Ω–∞\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤–≤–µ—Å—Ç–∏ –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:",
            parse_mode="Markdown",
            reply_markup=get_cancel_kb()
        )
        return
    
    if len(found_groups) == 1:
        group = found_groups[0]
        save_user_group(message.from_user.id, group['name'], group['id'])
        await state.clear()
        await message.answer(
            f"‚úÖ –ì—Ä—É–ø–ø–∞ **{group['name']}** –≤—ã–±—Ä–∞–Ω–∞!",
            parse_mode="Markdown",
            reply_markup=get_logged_menu()
        )
    else:
        await state.update_data(found_groups=found_groups)
        await message.answer(
            f"üîç –ù–∞–π–¥–µ–Ω–æ –≥—Ä—É–ø–ø: {len(found_groups)}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É –≥—Ä—É–ø–ø—É:",
            reply_markup=get_search_results_keyboard(found_groups)
        )



@dp.message(F.text == "üìÖ –ú–æ—ë —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
async def btn_my_schedule(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    group_name, group_id = get_user_data(user_id)

    if not group_id:
        await message.answer("‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É! –ù–∞–∂–º–∏—Ç–µ 'üë• –í—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É'", reply_markup=get_logged_menu())
        return

    await message.answer("‚è≥ –ó–∞–≥—Ä—É–∂–∞—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ...")
    schedule = fetch_schedule_from_api(group_id)
    
    if not schedule:
        await message.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ.\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", reply_markup=get_logged_menu())
        return
    
    await state.update_data(schedule_data=schedule, group_name=group_name, group_id=group_id)
    
    today = datetime.now().date()
    week_start = today - timedelta(days=today.weekday())
    week_end = week_start + timedelta(days=6)
    
    await message.answer(
        f"üìö **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã {group_name}**\n\n"
        f"üìÖ –ù–µ–¥–µ–ª—è: {week_start.strftime('%d.%m')} - {week_end.strftime('%d.%m.%Y')}\n\n"
        f"üìç - —Å–µ–≥–æ–¥–Ω—è\n"
        f"üìö - –µ—Å—Ç—å –∑–∞–Ω—è—Ç–∏—è\n"
        f"‚ûñ - –Ω–µ—Ç –∑–∞–Ω—è—Ç–∏–π\n\n"
        f"**–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:**",
        parse_mode="Markdown",
        reply_markup=get_week_days_keyboard(schedule, 0)
    )


@dp.callback_query(F.data.startswith("schedule_week_"))
async def schedule_week_navigation(callback: types.CallbackQuery, state: FSMContext):
    """–ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ –Ω–µ–¥–µ–ª—è–º"""
    week_offset = int(callback.data.split("_")[2])
    
    data = await state.get_data()
    schedule = data.get('schedule_data')
    group_name = data.get('group_name', '')
    
    if not schedule:
        group_id = data.get('group_id')
        if group_id:
            schedule = fetch_schedule_from_api(group_id)
            await state.update_data(schedule_data=schedule)
    
    today = datetime.now().date()
    week_start = today - timedelta(days=today.weekday()) + timedelta(weeks=week_offset)
    week_end = week_start + timedelta(days=6)
    
    if week_offset == 0:
        week_label = "–¢–µ–∫—É—â–∞—è –Ω–µ–¥–µ–ª—è"
    elif week_offset == 1:
        week_label = "–°–ª–µ–¥—É—é—â–∞—è –Ω–µ–¥–µ–ª—è"
    elif week_offset == -1:
        week_label = "–ü—Ä–æ—à–ª–∞—è –Ω–µ–¥–µ–ª—è"
    else:
        week_label = f"–ù–µ–¥–µ–ª—è {week_offset:+d}"
    
    await callback.message.edit_text(
        f"üìö **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã {group_name}**\n\n"
        f"üìÖ {week_label}: {week_start.strftime('%d.%m')} - {week_end.strftime('%d.%m.%Y')}\n\n"
        f"üìç - —Å–µ–≥–æ–¥–Ω—è\n"
        f"üìö - –µ—Å—Ç—å –∑–∞–Ω—è—Ç–∏—è\n"
        f"‚ûñ - –Ω–µ—Ç –∑–∞–Ω—è—Ç–∏–π\n\n"
        f"**–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:**",
        parse_mode="Markdown",
        reply_markup=get_week_days_keyboard(schedule, week_offset)
    )


@dp.callback_query(F.data.startswith("schedule_day_"))
async def schedule_day_selected(callback: types.CallbackQuery, state: FSMContext):
    date_str = callback.data.split("_")[2]
    selected_date = datetime.strptime(date_str, '%Y-%m-%d').date()
    
    data = await state.get_data()
    schedule = data.get('schedule_data')
    group_name = data.get('group_name', '')
    
    if not schedule:
        await callback.answer("‚ö†Ô∏è –î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏. –ù–∞–∂–º–∏—Ç–µ 'üìÖ –ú–æ—ë —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ' –∑–∞–Ω–æ–≤–æ.", show_alert=True)
        return
    
    schedule_text = format_schedule_for_date(schedule, group_name, selected_date)
    
    if schedule_text:
        await callback.message.edit_text(
            schedule_text,
            parse_mode="Markdown",
            reply_markup=get_day_navigation_keyboard(date_str)
        )
    else:
        days_ru = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
        day_name = days_ru[selected_date.weekday()]
        
        await callback.message.edit_text(
            f"üìÖ **{selected_date.strftime('%d.%m.%Y')}** ({day_name})\n"
            f"üë• –ì—Ä—É–ø–ø–∞: **{group_name}**\n\n"
            f"üéâ **–í —ç—Ç–æ—Ç –¥–µ–Ω—å –Ω–µ—Ç –∑–∞–Ω—è—Ç–∏–π!**",
            parse_mode="Markdown",
            reply_markup=get_day_navigation_keyboard(date_str)
        )


@dp.callback_query(F.data == "close_schedule")
async def close_schedule(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("‚úÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ")
    await callback.message.answer("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_logged_menu())


# ============ –û–°–¢–ê–õ–¨–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò ============

@dp.message(F.text == "üì± –ú–æ–±–∏–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ")
async def btn_mobile_app(message: types.Message, state: FSMContext):
    await message.answer(
        "üì± **–ú–æ–±–∏–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ö–ì–≠–£ –û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ**\n\n"
        "–°–∫–∞—á–∞–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –≤–∞—à–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:",
        parse_mode="Markdown",
        reply_markup=get_app_links_keyboard()
    )


@dp.message(F.text == "üåê –°–∞–π—Ç")
async def btn_site(message: types.Message):
    await message.answer(
        "üåê **–°–µ–≥–æ–¥–Ω—è –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω**\n\n"
        "",
        parse_mode="Markdown"
    )


@dp.callback_query(F.data.startswith("select_group_"))
async def select_group(callback: types.CallbackQuery, state: FSMContext):
    group_id = int(callback.data.split("_")[2])
    
    data = await state.get_data()
    groups = data.get('found_groups') or fetch_groups_from_api()
    
    group = next((g for g in groups if g['id'] == group_id), None)

    if group:
        save_user_group(callback.from_user.id, group['name'], group['id'])
        await state.clear()
        await callback.message.edit_text(f"‚úÖ –ì—Ä—É–ø–ø–∞ **{group['name']}** –≤—ã–±—Ä–∞–Ω–∞!", parse_mode="Markdown")
        await callback.message.answer("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_logged_menu())
    else:
        await callback.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞ –≥—Ä—É–ø–ø—ã", show_alert=True)


@dp.callback_query(F.data == "cancel_process")
async def cancel_process(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ.")
    user_status = get_user_status(callback.from_user.id)
    await callback.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                                  reply_markup=get_logged_menu() if user_status == 1 else get_main_menu())


@dp.callback_query(F.data == "back_to_menu")
async def back_to_menu(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.answer("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_logged_menu())


@dp.message()
async def echo_all(message: types.Message):
    pass


async def main():
    db_start()
    
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–∞ 07:00 –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
    scheduler.add_job(
        send_daily_schedule,
        CronTrigger(hour=0, minute=40, timezone="Europe/Moscow"),
        id="daily_schedule",
        replace_existing=True
    )
    scheduler.start()
    print("‚è∞ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω! –†–∞—Å—Å—ã–ª–∫–∞ –≤ 07:00 –ø–æ –ú–°–ö")
    
    print("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    await dp.start_polling(bot)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("–ë–æ—Ç –≤—ã–∫–ª—é—á–µ–Ω")

C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\PycharmProjects\PythonProject12\.venv\Scripts\python.exe C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\PycharmProjects\PythonProject12\112.py 
Traceback (most recent call last):
  File "C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\PycharmProjects\PythonProject12\112.py", line 1020, in <module>
    asyncio.run(main())
    ~~~~~~~~~~~^^^^^^^^
  File "C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\AppData\Local\Python\pythoncore-3.14-64\Lib\asyncio\runners.py", line 204, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\AppData\Local\Python\pythoncore-3.14-64\Lib\asyncio\runners.py", line 127, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\AppData\Local\Python\pythoncore-3.14-64\Lib\asyncio\base_events.py", line 719, in run_until_complete
    return future.result()
           ~~~~~~~~~~~~~^^
  File "C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\PycharmProjects\PythonProject12\112.py", line 1002, in main
    db_start()
    ~~~~~~~~^^
  File "C:\Users\–í–ª–∞–¥–∏–º–∏—Ä\PycharmProjects\PythonProject12\112.py", line 33, in db_start
    cursor.execute("""CREATE TABLE IF NOT EXISTS users (
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        user_id INTEGER PRIMARY KEY,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<5 lines>...
        group_id INTEGER DEFAULT 0
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
    )""")
    ^^^^^
sqlite3.DatabaseError: database disk image is malformed

Process finished with exit code 1


