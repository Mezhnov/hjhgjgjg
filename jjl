#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shellapi.h>
#include <dwmapi.h>
#include <wchar.h>
#include <cmath>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "dwmapi.lib")

using namespace Gdiplus;

// ================= CONFIG =================
const int W = 1200;
const int H = 700;

const wchar_t* BG_URL    = L"https://images.unsplash.com/photo-1557683311-973673bafdbd?w=1800";
const wchar_t* BG_FILE   = L"background.jpg";
const wchar_t* LOGO_URL  = L"https://i.imgur.com/placeholder.png"; // ← замените
const wchar_t* LOGO_FILE = L"logo.png";

const wchar_t* GTA_PATH = L"C:\\Games\\GTA5\\GTA5.exe";

// ================= ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ =================
ULONG_PTR gdiToken;
Image* background = nullptr;
Image* logo = nullptr;
bool isFullscreen = false;
RECT normalRect;
float progress = 0.0f;
bool showNews = false;
bool showSettings = false;
int currentNewsIndex = 0;

// ================= НОВОСТИ =================
struct NewsItem {
    const wchar_t* title;
    const wchar_t* description;
    const wchar_t* imageUrl;
    const wchar_t* imageFile;
};

NewsItem newsItems[] = {
    { L"Обновление 1.5: Новые машины!", L"Добавлены новые автомобили и миссии. Подробности на форуме.", L"https://picsum.photos/760/120?random=1", L"news1.jpg" },
    { L"Конкурс на лучший билд", L"Участвуйте и выигрывайте призы! Срок до 20.01.2026.", L"https://picsum.photos/760/120?random=2", L"news2.jpg" },
    { L"Бан волна читеров", L"Очищаем сервер от нарушителей. Спасибо за репорты!", L"https://picsum.photos/760/120?random=3", L"news3.jpg" },
};
const int numNews = sizeof(newsItems) / sizeof(NewsItem);
Image* newsImages[3] = { nullptr };

// ================= НАСТРОЙКИ =================
bool settingFullscreen    = false;
bool settingAutoUpdate    = true;
bool settingSoundEffects  = true;
int  settingVolume        = 75;   // 0–100

// ================= UI СТРУКТУРЫ =================
struct Button {
    RECT rect;
    const wchar_t* text;
    bool hover;
    Color normalColor;
    Color hoverColor;
    int fontSize;
    const wchar_t* tooltip;
};

struct Panel {
    RECT rect;
    Color bgColor;
    int borderRadius;
};

// ================= КНОПКИ =================
Button btnPlay       { {450,500,750,580}, L"ЗАПУСТИТЬ ИГРУ", false, Color(80, 220,140,220), Color(100,255,180,255), 24, L"Запустить GTA V" };
Button btnNews       { {50, 180,350,250}, L"НОВОСТИ",        false, Color(50, 50, 70,160),  Color(80, 80,100,200),  18, L"Последние новости" };
Button btnSettings   { {50, 270,350,340}, L"НАСТРОЙКИ",      false, Color(50, 50, 70,160),  Color(80, 80,100,200),  18, L"Настройки лаунчера" };
Button btnDiscord    { {50, 360,350,430}, L"DISCORD",        false, Color(88,101,242,220),  Color(110,130,255,255),18, L"Discord сообщество" };
Button btnForum      { {50, 450,350,520}, L"ФОРУМ",          false, Color(50, 50, 70,160),  Color(80, 80,100,200),  18, L"Форум Majestic" };
Button btnDonate     { {850,180,1150,250},L"ДОНАТ",          false, Color(255,215,80,220),  Color(255,235,120,255),18, L"Поддержать проект" };
Button btnStats      { {850,270,1150,340},L"СТАТИСТИКА",     false, Color(50, 50, 70,160),  Color(80, 80,100,200),  18, L"Ваша статистика" };
Button btnRules      { {850,360,1150,430},L"ПРАВИЛА",        false, Color(220,60,60,180),   Color(240,90,90,220),   18, L"Правила сервера" };
Button btnEvents     { {50, 540,350,610}, L"СОБЫТИЯ",        false, Color(140,0,200,200),   Color(180,40,240,240),  18, L"Ближайшие ивенты" };

Button btnMinimize   { {W-140,10,W-100,40}, L"—", false, Color(0,0,0,0), Color(180,180,180,220), 20, L"Свернуть" };
Button btnMaximize   { {W-90, 10,W-50, 40}, L"□", false, Color(0,0,0,0), Color(180,180,180,220), 20, L"Развернуть" };
Button btnClose      { {W-40, 10,W-10, 40}, L"✕", false, Color(0,0,0,0), Color(220,60,60,240),   20, L"Закрыть" };

Button btnNewsBack   { {50,  50,150,100}, L"НАЗАД", false, Color(60,60,80,180), Color(100,100,130,220), 18, L"Вернуться" };
Button btnNewsPrev   { {400,600,500,650}, L"<",    false, Color(60,60,80,180), Color(100,100,130,220), 24, L"Предыдущая новость" };
Button btnNewsNext   { {700,600,800,650}, L">",    false, Color(60,60,80,180), Color(100,100,130,220), 24, L"Следующая новость" };

Button btnSettingsBack { {50,  50,150,100}, L"НАЗАД", false, Color(60,60,80,180), Color(100,100,130,220), 18, L"Вернуться" };

Button btnCheckFullscreen  { {250,180,700,220}, L"Запускать игру в полноэкранном режиме", false, Color(0,0,0,0), Color(90,90,110,140), 16, L"" };
Button btnCheckAutoUpdate  { {250,240,700,280}, L"Автоматически проверять обновления",     false, Color(0,0,0,0), Color(90,90,110,140), 16, L"" };
Button btnCheckSound       { {250,300,700,340}, L"Включить звуковые эффекты лаунчера",     false, Color(0,0,0,0), Color(90,90,110,140), 16, L"" };

// ================= ПАНЕЛИ =================
Panel mainPanel    { {30,  150,370,640}, Color(30,30,45,140), 16 };
Panel rightPanel   { {830, 150,1170,460},Color(30,30,45,140), 16 };
Panel playPanel    { {430, 480,770,600}, Color(20,20,35,100), 24 };
Panel newsPanel    { {200, 100,1000,550},Color(35,35,50,160), 20 };
Panel settingsPanel{ {200, 100,1000,550},Color(35,35,50,160), 20 };

// ================= УТИЛИТЫ =================
bool InRect(const POINT& p, const RECT& r) {
    return p.x >= r.left && p.x <= r.right && p.y >= r.top && p.y <= r.bottom;
}

void DrawRoundedRect(Graphics& g, Brush* brush, const RectF& rect, REAL radius) {
    GraphicsPath path;
    path.AddArc(rect.X, rect.Y, radius*2, radius*2, 180, 90);
    path.AddArc(rect.X + rect.Width - radius*2, rect.Y, radius*2, radius*2, 270, 90);
    path.AddArc(rect.X + rect.Width - radius*2, rect.Y + rect.Height - radius*2, radius*2, radius*2, 0, 90);
    path.AddArc(rect.X, rect.Y + rect.Height - radius*2, radius*2, radius*2, 90, 90);
    path.CloseFigure();
    g.FillPath(brush, &path);
}

void DrawPanel(Graphics& g, const Panel& p) {
    SolidBrush brush(p.bgColor);
    RectF rect((REAL)p.rect.left, (REAL)p.rect.top, (REAL)(p.rect.right - p.rect.left), (REAL)(p.rect.bottom - p.rect.top));
    DrawRoundedRect(g, &brush, rect, (REAL)p.borderRadius);

    // лёгкая обводка
    Pen border(Color(120, 140, 160, 80), 1.2f);
    g.DrawPath(&border, [&rect, radius = (REAL)p.borderRadius](GraphicsPath& path){
        path.AddArc(rect.X, rect.Y, radius*2, radius*2, 180, 90);
        path.AddArc(rect.X + rect.Width - radius*2, rect.Y, radius*2, radius*2, 270, 90);
        path.AddArc(rect.X + rect.Width - radius*2, rect.Y + rect.Height - radius*2, radius*2, radius*2, 0, 90);
        path.AddArc(rect.X, rect.Y + rect.Height - radius*2, radius*2, radius*2, 90, 90);
        path.CloseFigure();
    });
}

void DrawButton(Graphics& g, const Button& b) {
    Color bg = b.hover ? b.hoverColor : b.normalColor;
    SolidBrush brush(bg);
    RectF r((REAL)b.rect.left, (REAL)b.rect.top, (REAL)(b.rect.right - b.rect.left), (REAL)(b.rect.bottom - b.rect.top));
    DrawRoundedRect(g, &brush, r, 12.0f);

    if (b.hover) {
        Pen pen(Color(220, 255, 255, 220), 2.0f);
        pen.SetDashStyle(DashStyleDot);
        g.DrawRectangle(&pen, r);
    }

    FontFamily ff(L"Segoe UI");
    Font font(&ff, (REAL)b.fontSize, FontStyleBold);
    SolidBrush text(Color(245,245,255));
    SolidBrush shadow(Color(60,0,0,0));

    StringFormat fmt;
    fmt.SetAlignment(StringAlignmentCenter);
    fmt.SetLineAlignment(StringAlignmentCenter);

    // тень под текстом
    g.DrawString(b.text, -1, &font, PointF(r.X+1.5f, r.Y+1.5f), &fmt, &shadow);
    g.DrawString(b.text, -1, &font, r, &fmt, &text);
}

void DrawCheckbox(Graphics& g, const Button& b, bool checked) {
    RectF r((REAL)b.rect.left, (REAL)b.rect.top, (REAL)(b.rect.right - b.rect.left), (REAL)(b.rect.bottom - b.rect.top));

    SolidBrush bg(b.hover ? Color(70,70,90,160) : Color(50,50,60,120));
    g.FillRectangle(&bg, r);

    RectF box(r.X + 12, r.Y + (r.Height-24)/2, 24, 24);
    Pen pen(Color(220,220,230), 2.2f);
    g.DrawRectangle(&pen, box);

    if (checked) {
        SolidBrush fill(Color(60,220,100));
        g.FillRectangle(&fill, box.X+4, box.Y+4, box.Width-8, box.Height-8);
    }

    FontFamily ff(L"Segoe UI");
    Font font(&ff, 16);
    SolidBrush text(Color(235,235,245));
    RectF textRect(r.X + 48, r.Y, r.Width - 50, r.Height);
    StringFormat fmt; fmt.SetLineAlignment(StringAlignmentCenter);
    g.DrawString(b.text, -1, &font, textRect, &fmt, &text);
}

void DrawVolumeSlider(Graphics& g, int volume) {
    RectF track(250, 380, 500, 10);
    SolidBrush trackBg(Color(60,60,70));
    g.FillRectangle(&trackBg, track);

    float pos = volume / 100.0f;
    RectF fill(250, 380, 500 * pos, 10);
    LinearGradientBrush grad(PointF(250,380), PointF(750,380), Color(80,200,255), Color(0,140,255));
    g.FillRectangle(&grad, fill);

    REAL x = 250 + 500 * pos - 14;
    RectF circle(x, 380 - 14, 28, 28);
    SolidBrush circleBrush(Color(240,240,255));
    g.FillEllipse(&circleBrush, circle);

    Pen border(Color(180,180,200), 2.5f);
    g.DrawEllipse(&border, circle);

    wchar_t txt[32];
    swprintf_s(txt, L"Громкость: %d%%", volume);
    FontFamily ff(L"Segoe UI");
    Font font(&ff, 14);
    SolidBrush text(Color(220,220,240));
    g.DrawString(txt, -1, &font, PointF(250, 410), &text);
}

void DrawGradientOverlay(Graphics& g) {
    LinearGradientBrush gradient(Point(0,0), Point(0,H), Color(180,0,0,0), Color(220,0,0,0));
    g.FillRectangle(&gradient, 0, 0, W, H);
}

void DrawHeader(Graphics& g) {
    LinearGradientBrush headerGrad(Point(0,0), Point(0,70), Color(160,20,20,50), Color(60,10,10,30));
    g.FillRectangle(&headerGrad, 0, 0, W, 70);

    if (logo) g.DrawImage(logo, 24, 10, 50, 50);

    FontFamily ff(L"Segoe UI");
    Font titleFont(&ff, 34.0f, FontStyleBold);
    SolidBrush shadow(Color(120,0,0,0));
    SolidBrush orange(Color(255,220,100));
    SolidBrush white(Color(255,255,255));

    g.DrawString(L"MAJESTIC", -1, &titleFont, PointF(90,14), &shadow);
    g.DrawString(L"MAJESTIC", -1, &titleFont, PointF(86,10), &orange);

    g.DrawString(L"ROLEPLAY", -1, &titleFont, PointF(280,14), &shadow);
    g.DrawString(L"ROLEPLAY", -1, &titleFont, PointF(276,10), &white);
}

void DrawServerInfo(Graphics& g) {
    FontFamily ff(L"Segoe UI");
    Font infoFont(&ff, 15.0f, FontStyleBold);
    Font smallFont(&ff, 12.0f);
    SolidBrush white(Color::White), green(Color(40,255,80)), gray(Color(200,220,220,220));

    g.DrawString(L"● ONLINE", -1, &infoFont, PointF((REAL)W - 260, 22), &green);
    g.DrawString(L"Онлайн: 2847 / 3000", -1, &smallFont, PointF((REAL)W - 400, 25), &gray);
}

void DrawTooltip(Graphics& g, const wchar_t* text, POINT mouse) {
    if (!text || !*text) return;

    FontFamily ff(L"Segoe UI");
    Font font(&ff, 14.0f);
    RectF bound;
    g.MeasureString(text, -1, &font, PointF(0,0), &bound);

    REAL w = bound.Width + 24;
    REAL h = bound.Height + 16;
    REAL x = mouse.x + 20;
    REAL y = mouse.y + 28;

    if (x + w > W) x = mouse.x - w - 12;
    if (y + h > H) y = mouse.y - h - 12;

    RectF rect(x, y, w, h);
    SolidBrush bg(Color(240, 35, 35, 55));
    DrawRoundedRect(g, &bg, rect, 10.0f);

    Pen border(Color(160, 140, 180, 220), 1.4f);
    g.DrawRectangle(&border, rect);

    SolidBrush txtBrush(Color::WhiteSmoke);
    StringFormat fmt;
    fmt.SetAlignment(StringAlignmentCenter);
    fmt.SetLineAlignment(StringAlignmentCenter);
    g.DrawString(text, -1, &font, rect, &fmt, &txtBrush);
}

// остальные Draw-функции (DrawProgressBar, DrawNews, DrawSettings) остаются почти без изменений

void DrawProgressBar(Graphics& g, float progress) {
    RectF bgRect(450, 630, 300, 14);
    RectF progressRect(450, 630, 300 * progress, 14);

    SolidBrush bgBrush(Color(70, 50, 50, 60));
    LinearGradientBrush progressBrush(PointF(450,630), PointF(750,630), Color(255,240,100), Color(255,180,40));

    DrawRoundedRect(g, &bgBrush, bgRect, 7);
    DrawRoundedRect(g, &progressBrush, progressRect, 7);

    wchar_t txt[16];
    swprintf_s(txt, L"%.0f%%", progress * 100);
    FontFamily ff(L"Segoe UI");
    Font font(&ff, 11.0f);
    SolidBrush textBrush(Color(255,255,240));
    g.DrawString(txt, -1, &font, PointF(580, 633), &textBrush);
}

// ... (DrawNews и DrawSettings остаются как были, только цвета можно подправить аналогично)

// ================= WINDOW PROC =================
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static POINT mousePos;
    static const Button* hoveredButton = nullptr;

    switch (msg)
    {
    case WM_CREATE:
    {
        DWM_WINDOW_CORNER_PREFERENCE pref = DWMWCP_ROUND;
        DwmSetWindowAttribute(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &pref, sizeof(pref));

        URLDownloadToFileW(nullptr, BG_URL, BG_FILE, 0, nullptr);
        URLDownloadToFileW(nullptr, LOGO_URL, LOGO_FILE, 0, nullptr);
        background = Image::FromFile(BG_FILE);
        logo = Image::FromFile(LOGO_FILE);

        for (int i = 0; i < numNews; ++i) {
            URLDownloadToFileW(nullptr, newsItems[i].imageUrl, newsItems[i].imageFile, 0, nullptr);
            newsImages[i] = Image::FromFile(newsItems[i].imageFile);
        }

        SetTimer(hwnd, 1, 33, nullptr); // ~30 fps — достаточно плавно и экономно
        break;
    }

    case WM_TIMER:
        if (wParam == 1) {
            progress += 0.008f;
            if (progress > 1.0f) progress = 1.0f;
            InvalidateRect(hwnd, nullptr, FALSE);
        }
        break;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP memBmp = CreateCompatibleBitmap(hdc, W, H);
        SelectObject(memDC, memBmp);

        Graphics g(memDC);
        g.SetSmoothingMode(SmoothingModeAntiAlias);
        g.SetTextRenderingHint(TextRenderingHintAntiAlias);
        g.SetInterpolationMode(InterpolationModeHighQualityBicubic);

        if (background) g.DrawImage(background, 0, 0, W, H);
        DrawGradientOverlay(g);
        DrawHeader(g);
        DrawServerInfo(g);

        if (!showNews && !showSettings) {
            DrawPanel(g, mainPanel);
            DrawPanel(g, rightPanel);
            DrawButton(g, btnNews);
            DrawButton(g, btnSettings);
            DrawButton(g, btnDiscord);
            DrawButton(g, btnForum);
            DrawButton(g, btnDonate);
            DrawButton(g, btnStats);
            DrawButton(g, btnRules);
            DrawButton(g, btnEvents);
            // DrawInfoBoxes(g);  // закомментировано — выглядит устаревше
            DrawButton(g, btnPlay);
            DrawProgressBar(g, progress);
        }
        else if (showNews) {
            DrawNews(g);
        }
        else if (showSettings) {
            DrawSettings(g);
        }

        DrawButton(g, btnMinimize);
        DrawButton(g, btnMaximize);
        DrawButton(g, btnClose);

        if (hoveredButton && hoveredButton->tooltip && *hoveredButton->tooltip) {
            DrawTooltip(g, hoveredButton->tooltip, mousePos);
        }

        BitBlt(hdc, 0, 0, W, H, memDC, 0, 0, SRCCOPY);
        DeleteObject(memBmp);
        DeleteDC(memDC);
        EndPaint(hwnd, &ps);
        break;
    }

    case WM_MOUSEMOVE:
    {
        POINT p;
        GetCursorPos(&p);
        ScreenToClient(hwnd, &p);
        mousePos = p;

        static Button* mainButtons[] = {
            &btnPlay, &btnNews, &btnSettings, &btnDiscord,
            &btnForum, &btnDonate, &btnStats, &btnRules,
            &btnEvents, &btnMinimize, &btnMaximize, &btnClose
        };

        static Button* newsButtons[] = {
            &btnNewsBack, &btnNewsPrev, &btnNewsNext,
            &btnMinimize, &btnMaximize, &btnClose
        };

        static Button* settingsButtons[] = {
            &btnSettingsBack, &btnCheckFullscreen,
            &btnCheckAutoUpdate, &btnCheckSound,
            &btnMinimize, &btnMaximize, &btnClose
        };

        Button** buttons = nullptr;
        int count = 0;

        if (showSettings) {
            buttons = settingsButtons;
            count = _countof(settingsButtons);
        }
        else if (showNews) {
            buttons = newsButtons;
            count = _countof(newsButtons);
        }
        else {
            buttons = mainButtons;
            count = _countof(mainButtons);
        }

        bool needRedraw = false;
        const Button* newHover = nullptr;

        for (int i = 0; i < count; ++i) {
            Button* b = buttons[i];
            bool old = b->hover;
            b->hover = InRect(p, b->rect);
            if (old != b->hover) needRedraw = true;
            if (b->hover) newHover = b;
        }

        if (hoveredButton != newHover) {
            hoveredButton = newHover;
            needRedraw = true;
        }

        if (needRedraw) InvalidateRect(hwnd, nullptr, FALSE);

        TRACKMOUSEEVENT tme = { sizeof(tme), TME_LEAVE, hwnd, 0 };
        TrackMouseEvent(&tme);
        break;
    }

    case WM_MOUSELEAVE:
        hoveredButton = nullptr;
        InvalidateRect(hwnd, nullptr, FALSE);
        break;

    // WM_LBUTTONDOWN, WM_DESTROY — без изменений (оставлены как в оригинале)

    case WM_DESTROY:
        delete background;
        delete logo;
        for (int i = 0; i < numNews; ++i) delete newsImages[i];
        GdiplusShutdown(gdiToken);
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow)
{
    GdiplusStartupInput gdiplusStartupInput;
    GdiplusStartup(&gdiToken, &gdiplusStartupInput, nullptr);

    WNDCLASSW wc = {};
    wc.lpfnWndProc    = WndProc;
    wc.hInstance      = hInstance;
    wc.lpszClassName  = L"MAJESTIC_LAUNCHER";
    wc.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    RegisterClassW(&wc);

    HWND hwnd = CreateWindowExW(
        WS_EX_LAYERED | WS_EX_APPWINDOW,
        wc.lpszClassName,
        L"Majestic RP Launcher",
        WS_POPUP,
        (GetSystemMetrics(SM_CXSCREEN) - W) / 2,
        (GetSystemMetrics(SM_CYSCREEN) - H) / 2,
        W, H,
        nullptr, nullptr, hInstance, nullptr
    );

    SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    MSG msg = {};
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    return (int)msg.wParam;
}
