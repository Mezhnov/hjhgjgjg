// Launcher_MajesticStyle.cpp
// ============================================================
// "Majestic-like" GTA RP launcher style (Win32 + GDI+ only)
// - Single file
// - No third-party libs
// - INI settings
// - Pages: Home / News / Settings
// - Modern titlebar (minimize + close only), F11 fullscreen
// - Double-buffer painting, hover/press animations
//
// Build notes (Visual Studio):
// - Project: Windows Desktop Application (C++)
// - Character Set: Unicode
// - Linker Input: gdiplus.lib comctl32.lib
//
// IMPORTANT: This is a UI demo launcher.
// ============================================================

#define UNICODE
#define _UNICODE

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shellapi.h>
#include <gdiplus.h>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "comctl32.lib")

using namespace Gdiplus;

// ============================================================
// Global config
// ============================================================

static int   gWinW = 1100;
static int   gWinH = 650;

static const wchar_t* APP_CLASS = L"MAJESTIC_STYLE_LAUNCHER_DEMO";
static const wchar_t* APP_TITLE = L"Majestic RP Launcher (Style Demo)";
static const wchar_t* INI_FILE  = L"launcher_settings.ini";

// ============================================================
// Utility
// ============================================================

static inline float ClampF(float v, float a, float b) { return (v < a) ? a : (v > b) ? b : v; }
static inline int   ClampI(int v, int a, int b) { return (v < a) ? a : (v > b) ? b : v; }

static std::wstring WStr(const wchar_t* s) { return s ? std::wstring(s) : L""; }

static std::wstring GetExeDir()
{
    wchar_t path[MAX_PATH]{0};
    GetModuleFileNameW(NULL, path, MAX_PATH);
    std::wstring p(path);
    size_t pos = p.find_last_of(L"\\/");
    if (pos != std::wstring::npos) p = p.substr(0, pos);
    return p;
}

static bool FileExists(const std::wstring& p)
{
    DWORD attr = GetFileAttributesW(p.c_str());
    return (attr != INVALID_FILE_ATTRIBUTES) && !(attr & FILE_ATTRIBUTE_DIRECTORY);
}

static std::wstring IniRead(const wchar_t* section, const wchar_t* key, const wchar_t* def)
{
    wchar_t buf[4096]{0};
    GetPrivateProfileStringW(section, key, def, buf, (DWORD)std::size(buf), INI_FILE);
    return buf;
}

static void IniWrite(const wchar_t* section, const wchar_t* key, const std::wstring& val)
{
    WritePrivateProfileStringW(section, key, val.c_str(), INI_FILE);
}

static int IniReadInt(const wchar_t* section, const wchar_t* key, int def)
{
    return GetPrivateProfileIntW(section, key, def, INI_FILE);
}

static void IniWriteInt(const wchar_t* section, const wchar_t* key, int val)
{
    wchar_t buf[64]; wsprintfW(buf, L"%d", val);
    WritePrivateProfileStringW(section, key, buf, INI_FILE);
}

static std::wstring OpenFileDialog(HWND hwnd, const wchar_t* filter, const wchar_t* title)
{
    OPENFILENAMEW ofn{};
    wchar_t file[MAX_PATH]{0};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = filter;
    ofn.lpstrFile = file;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;
    ofn.lpstrTitle = title;
    if (GetOpenFileNameW(&ofn))
        return file;
    return L"";
}

static void ShellOpenUrl(const std::wstring& url)
{
    ShellExecuteW(NULL, L"open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);
}

static void MsgBox(HWND hwnd, const std::wstring& title, const std::wstring& text)
{
    MessageBoxW(hwnd, text.c_str(), title.c_str(), MB_OK | MB_ICONINFORMATION);
}

// Launch EXE with arguments (simple)
static bool LaunchProcess(const std::wstring& exePath, const std::wstring& args, const std::wstring& workDir)
{
    std::wstring cmd = L"\"" + exePath + L"\"";
    if (!args.empty())
        cmd += L" " + args;

    STARTUPINFOW si{};
    si.cb = sizeof(si);
    PROCESS_INFORMATION pi{};

    std::wstring cmdMutable = cmd; // CreateProcess needs mutable buffer
    BOOL ok = CreateProcessW(
        NULL,
        cmdMutable.data(),
        NULL, NULL,
        FALSE,
        0,
        NULL,
        workDir.empty() ? NULL : workDir.c_str(),
        &si,
        &pi
    );
    if (ok)
    {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return true;
    }
    return false;
}

// ============================================================
// GDI+ Helpers: rounded rect + shadow
// ============================================================

static GraphicsPath* MakeRoundedRectPath(RectF r, float radius)
{
    radius = std::max(0.0f, radius);
    float d = radius * 2.0f;

    GraphicsPath* path = new GraphicsPath();
    if (radius <= 0.01f)
    {
        path->AddRectangle(r);
        path->CloseFigure();
        return path;
    }

    path->AddArc(r.X, r.Y, d, d, 180, 90);
    path->AddArc(r.X + r.Width - d, r.Y, d, d, 270, 90);
    path->AddArc(r.X + r.Width - d, r.Y + r.Height - d, d, d, 0, 90);
    path->AddArc(r.X, r.Y + r.Height - d, d, d, 90, 90);
    path->CloseFigure();
    return path;
}

static void DrawShadow(Graphics& g, RectF r, float radius, int layers, Color base)
{
    // Soft fake shadow by drawing multiple strokes
    // base alpha must be low (e.g. 40..90)
    for (int i = 0; i < layers; ++i)
    {
        float t = (float)i / (float)layers;
        float expand = 2.0f + t * 10.0f;
        int a = (int)(base.GetA() * (1.0f - t) * 0.55f);
        Pen pen(Color((BYTE)a, base.GetR(), base.GetG(), base.GetB()), 2.0f + t * 6.0f);
        RectF rr = r;
        rr.X -= expand; rr.Y -= expand;
        rr.Width += expand * 2; rr.Height += expand * 2;
        GraphicsPath* p = MakeRoundedRectPath(rr, radius + expand);
        g.DrawPath(&pen, p);
        delete p;
    }
}

// ============================================================
// Theme
// ============================================================

enum class ThemeMode { Dark = 0, Neon = 1 };

struct Theme
{
    ThemeMode mode = ThemeMode::Dark;

    Color bg0;
    Color bg1;
    Color panel;
    Color panel2;
    Color stroke;
    Color stroke2;

    Color text0;
    Color text1;
    Color text2;

    Color accent;
    Color accent2;
    Color danger;
    Color warn;

    void Apply(ThemeMode m)
    {
        mode = m;
        if (m == ThemeMode::Dark)
        {
            bg0 = Color(255, 7, 10, 18);
            bg1 = Color(255, 11, 16, 32);
            panel = Color(180, 255, 255, 255);   // used as alpha with composite
            panel2 = Color(200, 255, 255, 255);

            stroke  = Color(50, 255, 255, 255);
            stroke2 = Color(85, 255, 255, 255);

            text0 = Color(235, 255, 255, 255);
            text1 = Color(190, 255, 255, 255);
            text2 = Color(140, 255, 255, 255);

            accent  = Color(255, 59, 130, 246);
            accent2 = Color(255, 34, 197, 94);
            danger  = Color(255, 239, 68, 68);
            warn    = Color(255, 245, 158, 11);
        }
        else
        {
            bg0 = Color(255, 6, 6, 14);
            bg1 = Color(255, 16, 8, 32);
            panel = Color(180, 255, 255, 255);
            panel2 = Color(200, 255, 255, 255);

            stroke  = Color(55, 255, 255, 255);
            stroke2 = Color(95, 255, 255, 255);

            text0 = Color(235, 255, 255, 255);
            text1 = Color(190, 255, 255, 255);
            text2 = Color(145, 255, 255, 255);

            accent  = Color(255, 124, 58, 237); // neon purple
            accent2 = Color(255, 34, 197, 94);
            danger  = Color(255, 239, 68, 68);
            warn    = Color(255, 245, 158, 11);
        }
    }
};

static Theme gTheme;

// ============================================================
// Simple UI system
// ============================================================

enum class Page { Home, News, Settings };
enum class BtnKind { Primary, Secondary, Ghost, Danger, Icon };

struct UIContext
{
    HWND hwnd = nullptr;
    int w = 0;
    int h = 0;
    bool mouseDown = false;
    POINT mousePos{0,0};
    bool focusOnText = false;
};

struct Anim
{
    float v = 0.0f;       // 0..1
    float target = 0.0f;  // 0..1
    float speed = 0.18f;  // smoothing
    void Tick()
    {
        // simple exponential smoothing
        v = v + (target - v) * speed;
        if (fabs(v - target) < 0.001f) v = target;
    }
};

struct Button
{
    int id = 0;
    RectF rect{};
    std::wstring text;
    BtnKind kind = BtnKind::Secondary;
    bool enabled = true;

    bool hover = false;
    bool down = false;
    Anim glow; // hover glow
};

struct Toggle
{
    int id = 0;
    RectF rect{};
    std::wstring text;
    bool value = false;
    bool hover = false;
    Anim anim; // 0 off -> 1 on
};

struct TextBox
{
    int id = 0;
    RectF rect{};
    std::wstring label;
    std::wstring value;
    std::wstring placeholder;
    bool hover = false;
    bool focused = false;
    bool password = false;
    int caret = 0;
    bool caretOn = true;
    DWORD lastBlink = 0;
};

struct Dropdown
{
    int id = 0;
    RectF rect{};
    std::wstring label;
    std::vector<std::wstring> items;
    int selected = 0;
    bool hover = false;
    bool open = false;
    int hoverIndex = -1;
};

struct ScrollArea
{
    RectF rect{};
    float scroll = 0.0f;
    float maxScroll = 0.0f;
};

// IDs
enum UI_ID
{
    ID_BTN_CLOSE = 1,
    ID_BTN_MIN,
    ID_BTN_THEME,
    ID_BTN_HOME,
    ID_BTN_NEWS,
    ID_BTN_SETTINGS,
    ID_BTN_PLAY,
    ID_BTN_DISCORD,
    ID_BTN_OPEN_GAME,
    ID_BTN_SAVE_SETTINGS,
    ID_BTN_ADD_SERVER,
    ID_BTN_DEL_SERVER,
    ID_BTN_F11,
    ID_BTN_SEED_NEWS,
    ID_BTN_OPEN_LOG,

    ID_TX_GAMEPATH = 200,
    ID_TX_ARGS,
    ID_TX_DISCORD,
    ID_TX_BG,
    ID_TX_NICK,

    ID_TG_AUTOLAUNCH = 300,
    ID_TG_FULLSCREEN,
    ID_TG_ANIMATIONS,

    ID_DD_SERVER = 400,
    ID_DD_THEME,
};

// ============================================================
// Launcher state / settings
// ============================================================

struct ServerItem
{
    std::wstring name;
    std::wstring host;
    int port = 0;
};

struct Settings
{
    std::wstring gamePath;
    std::wstring gameArgs;
    std::wstring discordUrl;
    std::wstring backgroundPath;
    std::wstring nickname;

    bool autoLaunch = false;
    bool startFullscreen = false;
    bool animations = true;

    ThemeMode theme = ThemeMode::Dark;

    std::vector<ServerItem> servers;
    int selectedServer = 0;
};

static Settings gSet;

// pages
static Page gPage = Page::Home;

// news
static std::vector<std::wstring> gNews = {
    L"[01.01.2026] –ù–æ–≤—ã–π –∏–≤–µ–Ω—Ç: –ó–∏–º–Ω–∏–π —Ñ–µ—Å—Ç–∏–≤–∞–ª—å!",
    L"[02.01.2026] –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –±–∞–≥–∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞",
    L"[05.01.2026] –†–æ–∑—ã–≥—Ä—ã—à –≤–Ω—É—Ç—Ä–∏–∏–≥—Ä–æ–≤—ã—Ö –¥–µ–Ω–µ–≥",
    L"[10.01.2026] –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ñ—Ä–∞–∫—Ü–∏–π –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ",
    L"[12.01.2026] –£–ª—É—á—à–µ–Ω–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ —Å–ª–∞–±—ã—Ö –ü–ö",
    L"[15.01.2026] –î–æ–±–∞–≤–ª–µ–Ω—ã –Ω–æ–≤—ã–µ –∞–≤—Ç–æ –∏ —Ç—é–Ω–∏–Ω–≥",
    L"[18.01.2026] –ü–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞ —ç–∫–æ–Ω–æ–º–∏–∫–∏: –±–∞–ª–∞–Ω—Å—ã –∏ —Ü–µ–Ω—ã",
    L"[20.01.2026] –ù–æ–≤—ã–π —Å–µ–∑–æ–Ω, –Ω–æ–≤—ã–µ –Ω–∞–≥—Ä–∞–¥—ã"
};
static int gNewsIndex = 0;

// UI objects (stored per-frame layout)
static std::vector<Button>   gButtons;
static std::vector<TextBox>  gTextBoxes;
static std::vector<Toggle>   gToggles;
static std::vector<Dropdown> gDropdowns;

static ScrollArea gNewsScroll;

// Background image (optional)
static ULONG_PTR gGdiToken = 0;
static Image* gBgImage = nullptr;

// Window management
static bool gFullscreen = false;
static RECT gRestoreRect{};
static DWORD gRestoreStyle = 0;
static DWORD gRestoreExStyle = 0;

// Timers
static const UINT_PTR T_ANIM = 1;
static const UINT_PTR T_NEWS = 2;
static const UINT_PTR T_CARET = 3;

// ============================================================
// Settings load/save
// ============================================================

static void LoadSettings()
{
    gSet.gamePath = IniRead(L"Launcher", L"GamePath", L"");
    gSet.gameArgs = IniRead(L"Launcher", L"GameArgs", L"");
    gSet.discordUrl = IniRead(L"Launcher", L"Discord", L"https://discord.gg/");
    gSet.backgroundPath = IniRead(L"Appearance", L"Background", L"");
    gSet.nickname = IniRead(L"Account", L"Nickname", L"Player");

    gSet.autoLaunch = IniReadInt(L"Launcher", L"AutoLaunch", 0) != 0;
    gSet.startFullscreen = IniReadInt(L"Launcher", L"StartFullscreen", 0) != 0;
    gSet.animations = IniReadInt(L"Appearance", L"Animations", 1) != 0;

    int t = IniReadInt(L"Appearance", L"Theme", 0);
    gSet.theme = (t == 1) ? ThemeMode::Neon : ThemeMode::Dark;

    // servers: stored as ServerCount and Server{i}=name|host|port
    int count = IniReadInt(L"Servers", L"Count", 3);
    count = ClampI(count, 0, 50);

    gSet.servers.clear();
    for (int i = 0; i < count; ++i)
    {
        wchar_t key[64]; wsprintfW(key, L"Server%d", i);
        std::wstring line = IniRead(L"Servers", key, L"");
        if (line.empty())
            continue;

        // parse name|host|port
        ServerItem s;
        size_t p1 = line.find(L"|");
        size_t p2 = line.rfind(L"|");
        if (p1 != std::wstring::npos && p2 != std::wstring::npos && p2 > p1)
        {
            s.name = line.substr(0, p1);
            s.host = line.substr(p1 + 1, p2 - (p1 + 1));
            s.port = _wtoi(line.substr(p2 + 1).c_str());
        }
        if (s.name.empty()) s.name = L"Server";
        if (s.host.empty()) s.host = L"127.0.0.1";
        if (s.port <= 0) s.port = 7777;
        gSet.servers.push_back(s);
    }

    if (gSet.servers.empty())
    {
        gSet.servers = {
            {L"Lobby", L"127.0.0.1", 7777},
            {L"Game-01", L"127.0.0.1", 7778},
            {L"Game-02", L"127.0.0.1", 7779},
        };
    }

    gSet.selectedServer = ClampI(IniReadInt(L"Servers", L"Selected", 0), 0, (int)gSet.servers.size()-1);

    // Apply theme
    gTheme.Apply(gSet.theme);

    // Load background if exists
    if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
    if (!gSet.backgroundPath.empty() && FileExists(gSet.backgroundPath))
    {
        gBgImage = Image::FromFile(gSet.backgroundPath.c_str());
        if (gBgImage && gBgImage->GetLastStatus() != Ok)
        {
            delete gBgImage;
            gBgImage = nullptr;
        }
    }
}

static void SaveSettings()
{
    IniWrite(L"Launcher", L"GamePath", gSet.gamePath);
    IniWrite(L"Launcher", L"GameArgs", gSet.gameArgs);
    IniWrite(L"Launcher", L"Discord", gSet.discordUrl);
    IniWrite(L"Appearance", L"Background", gSet.backgroundPath);
    IniWrite(L"Account", L"Nickname", gSet.nickname);

    IniWriteInt(L"Launcher", L"AutoLaunch", gSet.autoLaunch ? 1 : 0);
    IniWriteInt(L"Launcher", L"StartFullscreen", gSet.startFullscreen ? 1 : 0);
    IniWriteInt(L"Appearance", L"Animations", gSet.animations ? 1 : 0);
    IniWriteInt(L"Appearance", L"Theme", (gSet.theme == ThemeMode::Neon) ? 1 : 0);

    IniWriteInt(L"Servers", L"Count", (int)gSet.servers.size());
    IniWriteInt(L"Servers", L"Selected", gSet.selectedServer);

    for (int i = 0; i < (int)gSet.servers.size(); ++i)
    {
        wchar_t key[64]; wsprintfW(key, L"Server%d", i);
        const auto& s = gSet.servers[i];
        std::wstring line = s.name + L"|" + s.host + L"|" + std::to_wstring(s.port);
        IniWrite(L"Servers", key, line);
    }

    toast(L"Saved", L"Settings written to INI", L"ok");
}

// ============================================================
// Drawing helpers (fonts + colors)
// ============================================================

static void DrawTextW_GDI(Graphics& g, const std::wstring& txt, const RectF& r, float size, int weight,
                          Color color, StringAlignment align = StringAlignmentNear, StringAlignment vAlign = StringAlignmentCenter,
                          bool wrap = false)
{
    FontFamily ff(L"Segoe UI");
    FontStyle style = FontStyleRegular;
    if (weight >= 700) style = FontStyleBold;

    Font font(&ff, size, style, UnitPixel);
    SolidBrush brush(color);

    StringFormat fmt;
    fmt.SetAlignment(align);
    fmt.SetLineAlignment(vAlign);
    fmt.SetTrimming(StringTrimmingEllipsisCharacter);
    fmt.SetFormatFlags(wrap ? 0 : StringFormatFlagsNoWrap);

    g.DrawString(txt.c_str(), -1, &font, r, &fmt, &brush);
}

static void FillRounded(Graphics& g, RectF r, float radius, Brush* b)
{
    GraphicsPath* p = MakeRoundedRectPath(r, radius);
    g.FillPath(b, p);
    delete p;
}

static void StrokeRounded(Graphics& g, RectF r, float radius, Pen* p)
{
    GraphicsPath* gp = MakeRoundedRectPath(r, radius);
    g.DrawPath(p, gp);
    delete gp;
}

static void DrawGlassPanel(Graphics& g, RectF r, float radius)
{
    // shadow
    DrawShadow(g, r, radius, 10, Color(80, 0, 0, 0));

    // fill (semi-transparent)
    SolidBrush fill(Color(65, 255, 255, 255));
    FillRounded(g, r, radius, &fill);

    // subtle gradient overlay
    LinearGradientBrush grad(r, Color(45, 255, 255, 255), Color(10, 255, 255, 255), LinearGradientModeVertical);
    FillRounded(g, r, radius, &grad);

    // stroke
    Pen stroke(gTheme.stroke, 1.0f);
    StrokeRounded(g, r, radius, &stroke);
}

static void DrawTopGradientBG(Graphics& g, int w, int h)
{
    // If background image exists -> draw it with cover
    if (gBgImage)
    {
        // cover fit (center crop)
        const float iw = (float)gBgImage->GetWidth();
        const float ih = (float)gBgImage->GetHeight();
        float scale = std::max(w / iw, h / ih);
        float dw = iw * scale;
        float dh = ih * scale;
        float dx = (w - dw) * 0.5f;
        float dy = (h - dh) * 0.5f;

        g.DrawImage(gBgImage, RectF(dx, dy, dw, dh));

        // dark overlay for readability
        SolidBrush ov(Color(160, 0, 0, 0));
        g.FillRectangle(&ov, 0, 0, (REAL)w, (REAL)h);
        return;
    }

    // Otherwise draw procedural background
    RectF rr(0,0,(REAL)w,(REAL)h);
    LinearGradientBrush base(rr, gTheme.bg0, gTheme.bg1, LinearGradientModeVertical);
    g.FillRectangle(&base, rr);

    // accent blobs
    auto blob = [&](float cx, float cy, float rad, Color c){
        GraphicsPath p;
        p.AddEllipse(cx-rad, cy-rad, rad*2, rad*2);
        PathGradientBrush b(&p);
        b.SetCenterColor(c);
        Color edges[1] = { Color(0, c.GetR(), c.GetG(), c.GetB()) };
        int count = 1;
        b.SetSurroundColors(edges, &count);
        g.FillEllipse(&b, cx-rad, cy-rad, rad*2, rad*2);
    };

    blob(w*0.18f, h*0.22f, 420.0f, Color(90, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()));
    blob(w*0.82f, h*0.28f, 380.0f, Color(80, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()));
    blob(w*0.50f, h*0.86f, 520.0f, Color(50, gTheme.warn.GetR(), gTheme.warn.GetG(), gTheme.warn.GetB()));

    // vignette
    SolidBrush vign(Color(120, 0, 0, 0));
    g.FillRectangle(&vign, 0, 0, (REAL)w, (REAL)h);
}

// ============================================================
// UI build layout
// ============================================================

static void UI_Clear()
{
    gButtons.clear();
    gTextBoxes.clear();
    gToggles.clear();
    gDropdowns.clear();
}

static Button* UI_AddButton(int id, RectF r, const std::wstring& txt, BtnKind kind)
{
    Button b;
    b.id = id;
    b.rect = r;
    b.text = txt;
    b.kind = kind;
    b.enabled = true;
    b.glow.v = 0;
    b.glow.target = 0;
    gButtons.push_back(b);
    return &gButtons.back();
}

static TextBox* UI_AddTextBox(int id, RectF r, const std::wstring& label, const std::wstring& value, const std::wstring& placeholder, bool password=false)
{
    TextBox t;
    t.id = id;
    t.rect = r;
    t.label = label;
    t.value = value;
    t.placeholder = placeholder;
    t.password = password;
    t.caret = (int)t.value.size();
    t.lastBlink = GetTickCount();
    gTextBoxes.push_back(t);
    return &gTextBoxes.back();
}

static Toggle* UI_AddToggle(int id, RectF r, const std::wstring& text, bool value)
{
    Toggle t;
    t.id = id;
    t.rect = r;
    t.text = text;
    t.value = value;
    t.anim.v = value ? 1.0f : 0.0f;
    t.anim.target = value ? 1.0f : 0.0f;
    gToggles.push_back(t);
    return &gToggles.back();
}

static Dropdown* UI_AddDropdown(int id, RectF r, const std::wstring& label, const std::vector<std::wstring>& items, int selected)
{
    Dropdown d;
    d.id = id;
    d.rect = r;
    d.label = label;
    d.items = items;
    d.selected = ClampI(selected, 0, (int)items.size()-1);
    gDropdowns.push_back(d);
    return &gDropdowns.back();
}

static void BuildLayout(UIContext& ui)
{
    UI_Clear();

    const float W = (float)ui.w;
    const float H = (float)ui.h;

    // Titlebar area: top 54 px
    const float titleH = 54.0f;
    const float pad = 16.0f;

    // Control buttons (top-right): only minimize + close
    UI_AddButton(ID_BTN_MIN, RectF(W - 92.0f, 10.0f, 36.0f, 30.0f), L"‚Äî", BtnKind::Icon);
    UI_AddButton(ID_BTN_CLOSE, RectF(W - 48.0f, 10.0f, 36.0f, 30.0f), L"‚úï", BtnKind::Icon);

    // Left sidebar (like Majestic launcher)
    RectF side(pad, titleH + pad, 240.0f, H - (titleH + pad*2));
    // Main area
    RectF main(side.X + side.Width + pad, titleH + pad, W - (side.X + side.Width + pad*2), H - (titleH + pad*2));

    // Sidebar buttons
    float y = side.Y + 16.0f;
    UI_AddButton(ID_BTN_HOME, RectF(side.X + 14, y, side.Width - 28, 44), L"üè† Home", BtnKind::Secondary); y += 54;
    UI_AddButton(ID_BTN_NEWS, RectF(side.X + 14, y, side.Width - 28, 44), L"üì∞ News", BtnKind::Secondary); y += 54;
    UI_AddButton(ID_BTN_SETTINGS, RectF(side.X + 14, y, side.Width - 28, 44), L"‚öô Settings", BtnKind::Secondary); y += 54;

    // Bottom area buttons
    UI_AddButton(ID_BTN_DISCORD, RectF(side.X + 14, side.Y + side.Height - 58, side.Width - 28, 44), L"Discord", BtnKind::Secondary);
    UI_AddButton(ID_BTN_THEME, RectF(side.X + 14, side.Y + side.Height - 112, side.Width - 28, 44), L"Theme", BtnKind::Secondary);

    // Content by page
    if (gPage == Page::Home)
    {
        // Hero card
        RectF hero(main.X, main.Y, main.Width, 220.0f);
        // Play button big
        UI_AddButton(ID_BTN_PLAY, RectF(main.X + main.Width - 240.0f, main.Y + 150.0f, 220.0f, 56.0f), L"PLAY", BtnKind::Primary);

        // Server dropdown
        std::vector<std::wstring> sv;
        for (auto& s : gSet.servers)
        {
            sv.push_back(s.name + L" ‚Ä¢ " + s.host + L":" + std::to_wstring(s.port));
        }
        UI_AddDropdown(ID_DD_SERVER, RectF(main.X + 20.0f, main.Y + 150.0f, main.Width - 280.0f, 44.0f), L"Server", sv, gSet.selectedServer);

        // Account badge + nickname edit
        UI_AddTextBox(ID_TX_NICK, RectF(main.X + 20.0f, main.Y + 96.0f, 320.0f, 44.0f), L"Nickname", gSet.nickname, L"Enter nickname");

        // Quick actions card
        RectF q(main.X, main.Y + hero.Height + 16.0f, main.Width, 220.0f);
        UI_AddButton(ID_BTN_OPEN_GAME, RectF(q.X + 20.0f, q.Y + 150.0f, 200.0f, 44.0f), L"Choose Game EXE", BtnKind::Secondary);
        UI_AddButton(ID_BTN_F11, RectF(q.X + 230.0f, q.Y + 150.0f, 200.0f, 44.0f), L"Fullscreen (F11)", BtnKind::Secondary);
        UI_AddButton(ID_BTN_OPEN_LOG, RectF(q.X + 440.0f, q.Y + 150.0f, 200.0f, 44.0f), L"Show Info", BtnKind::Secondary);

        // Show a small settings summary (readonly look -> textbox)
        UI_AddTextBox(ID_TX_GAMEPATH, RectF(q.X + 20.0f, q.Y + 44.0f, q.Width - 40.0f, 44.0f), L"Game Path", gSet.gamePath, L"Select game exe path");
        UI_AddTextBox(ID_TX_ARGS, RectF(q.X + 20.0f, q.Y + 96.0f, q.Width - 40.0f, 44.0f), L"Args", gSet.gameArgs, L"Optional args (e.g. -nolauncher)");
    }
    else if (gPage == Page::News)
    {
        // Big news panel + buttons
        RectF news(main.X, main.Y, main.Width, main.Height);
        UI_AddButton(ID_BTN_SEED_NEWS, RectF(news.X + news.Width - 220.0f, news.Y + 14.0f, 200.0f, 40.0f), L"Next News", BtnKind::Secondary);

        // Scroll area for long list
        gNewsScroll.rect = RectF(news.X + 14, news.Y + 70, news.Width - 28, news.Height - 84);
        // maxScroll calculated in drawing
    }
    else if (gPage == Page::Settings)
    {
        RectF s(main.X, main.Y, main.Width, main.Height);

        // Left column (launcher)
        float colW = (main.Width - 16.0f) * 0.55f;
        RectF left(s.X, s.Y, colW, s.Height);
        RectF right(s.X + colW + 16.0f, s.Y, main.Width - colW - 16.0f, s.Height);

        // Inputs left
        UI_AddTextBox(ID_TX_GAMEPATH, RectF(left.X + 16, left.Y + 62, left.Width - 32, 44), L"Game EXE path", gSet.gamePath, L"C:\\Games\\GTA5\\GTA5.exe");
        UI_AddButton(ID_BTN_OPEN_GAME, RectF(left.X + 16, left.Y + 110, 200, 40), L"Browse...", BtnKind::Secondary);

        UI_AddTextBox(ID_TX_ARGS, RectF(left.X + 16, left.Y + 162, left.Width - 32, 44), L"Launch args", gSet.gameArgs, L"-arg1 -arg2");
        UI_AddTextBox(ID_TX_DISCORD, RectF(left.X + 16, left.Y + 214, left.Width - 32, 44), L"Discord URL", gSet.discordUrl, L"https://discord.gg/xxxx");
        UI_AddTextBox(ID_TX_BG, RectF(left.X + 16, left.Y + 266, left.Width - 32, 44), L"Background image", gSet.backgroundPath, L"(optional) path to JPG/PNG");
        UI_AddButton(ID_BTN_OPEN_LOG, RectF(left.X + 16, left.Y + 314, 200, 40), L"Browse BG...", BtnKind::Secondary);

        UI_AddToggle(ID_TG_AUTOLAUNCH, RectF(left.X + 16, left.Y + 372, left.Width - 32, 32), L"Auto-launch on open", gSet.autoLaunch);
        UI_AddToggle(ID_TG_FULLSCREEN, RectF(left.X + 16, left.Y + 410, left.Width - 32, 32), L"Start fullscreen (F11)", gSet.startFullscreen);
        UI_AddToggle(ID_TG_ANIMATIONS, RectF(left.X + 16, left.Y + 448, left.Width - 32, 32), L"UI animations", gSet.animations);

        // Servers right
        UI_AddButton(ID_BTN_ADD_SERVER, RectF(right.X + 16, right.Y + 62, 160, 40), L"+ Add server", BtnKind::Secondary);
        UI_AddButton(ID_BTN_DEL_SERVER, RectF(right.X + 184, right.Y + 62, 160, 40), L"‚àí Remove", BtnKind::Secondary);

        // Theme dropdown
        std::vector<std::wstring> th = { L"Dark", L"Neon" };
        UI_AddDropdown(ID_DD_THEME, RectF(right.X + 16, right.Y + 114, right.Width - 32, 44), L"Theme", th, (gSet.theme==ThemeMode::Neon)?1:0);

        UI_AddButton(ID_BTN_SAVE_SETTINGS, RectF(right.X + right.Width - 200 - 16, right.Y + right.Height - 52, 200, 44), L"Save Settings", BtnKind::Primary);

        // Selected server dropdown (edit-like)
        std::vector<std::wstring> sv;
        for (auto& s0 : gSet.servers)
            sv.push_back(s0.name + L" ‚Ä¢ " + s0.host + L":" + std::to_wstring(s0.port));

        UI_AddDropdown(ID_DD_SERVER, RectF(right.X + 16, right.Y + 170, right.Width - 32, 44), L"Default server", sv, gSet.selectedServer);

        // Simple inline server editor (3 textboxes)
        // We'll edit selected server fields:
        const auto& cur = gSet.servers[ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1)];
        UI_AddTextBox(9001, RectF(right.X + 16, right.Y + 230, right.Width - 32, 44), L"Server name", cur.name, L"Lobby");
        UI_AddTextBox(9002, RectF(right.X + 16, right.Y + 282, right.Width - 32, 44), L"Host", cur.host, L"127.0.0.1");
        UI_AddTextBox(9003, RectF(right.X + 16, right.Y + 334, right.Width - 32, 44), L"Port", std::to_wstring(cur.port), L"7777");
    }
}

// ============================================================
// UI drawing
// ============================================================

static void DrawTitleBar(Graphics& g, UIContext& ui)
{
    RectF r(0,0,(REAL)ui.w, 54.0f);

    // top bar glass
    SolidBrush bg(Color(120, 0,0,0));
    g.FillRectangle(&bg, r);

    // subtle bottom line
    Pen line(Color(50,255,255,255), 1.0f);
    g.DrawLine(&line, 0, 54, (REAL)ui.w, 54);

    // Title + status
    DrawTextW_GDI(g, L"MAJESTIC ROLEPLAY", RectF(16, 10, 520, 20), 18, 900, gTheme.text0);
    DrawTextW_GDI(g, L"ONLINE ‚Ä¢ Launcher v2 (Demo)", RectF(16, 28, 520, 18), 12, 400, gTheme.text2);

    // Right hints
    DrawTextW_GDI(g, L"F11 Fullscreen", RectF((REAL)ui.w - 260, 18, 160, 20), 12, 600, gTheme.text2, StringAlignmentFar);

    // Control buttons drawn via buttons list (Icon kind)
}

static void DrawButton(Graphics& g, Button& b)
{
    RectF r = b.rect;

    b.glow.target = b.hover ? 1.0f : 0.0f;
    b.glow.speed = gSet.animations ? 0.22f : 1.0f;
    b.glow.Tick();

    bool pressed = b.down && b.hover;

    // Colors by kind
    Color stroke = gTheme.stroke;
    Color fillA = Color(40,255,255,255);
    Color fillB = Color(25,255,255,255);
    Color text = gTheme.text0;

    float radius = 14.0f;
    if (b.kind == BtnKind::Icon) radius = 12.0f;

    if (!b.enabled)
    {
        fillA = Color(20,255,255,255);
        fillB = Color(18,255,255,255);
        text = gTheme.text2;
        stroke = Color(35,255,255,255);
    }
    else if (b.kind == BtnKind::Primary)
    {
        // gradient accent
        // We'll draw gradient ourselves
    }
    else if (b.kind == BtnKind::Danger)
    {
        fillA = Color(40, gTheme.danger.GetR(), gTheme.danger.GetG(), gTheme.danger.GetB());
        fillB = Color(24, gTheme.danger.GetR(), gTheme.danger.GetG(), gTheme.danger.GetB());
        stroke = Color(110, gTheme.danger.GetR(), gTheme.danger.GetG(), gTheme.danger.GetB());
    }

    if (pressed) {
        fillA = Color((BYTE)ClampI(fillA.GetA()+40,0,255), fillA.GetR(), fillA.GetG(), fillA.GetB());
        fillB = Color((BYTE)ClampI(fillB.GetA()+30,0,255), fillB.GetR(), fillB.GetG(), fillB.GetB());
    }
    if (b.hover && b.enabled && b.kind != BtnKind::Primary) {
        fillA = Color((BYTE)ClampI(fillA.GetA()+30,0,255), fillA.GetR(), fillA.GetG(), fillA.GetB());
        fillB = Color((BYTE)ClampI(fillB.GetA()+24,0,255), fillB.GetR(), fillB.GetG(), fillB.GetB());
        stroke = gTheme.stroke2;
    }

    // Shadow
    DrawShadow(g, r, radius, 8, Color(70,0,0,0));

    if (b.kind == BtnKind::Primary)
    {
        // Primary gradient
        LinearGradientBrush grad(r,
            Color(255, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()),
            Color(255, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()),
            LinearGradientModeHorizontal
        );
        FillRounded(g, r, radius, &grad);

        Pen st(Color(90,255,255,255), 1.0f);
        StrokeRounded(g, r, radius, &st);

        // hover shine
        if (b.hover)
        {
            LinearGradientBrush shine(r,
                Color((BYTE)(45 + b.glow.v*60), 255,255,255),
                Color(0,255,255,255),
                LinearGradientModeVertical
            );
            FillRounded(g, r, radius, &shine);
        }
    }
    else
    {
        // Secondary/other
        SolidBrush f1(fillA);
        FillRounded(g, r, radius, &f1);

        LinearGradientBrush grad(r, fillA, fillB, LinearGradientModeVertical);
        FillRounded(g, r, radius, &grad);

        Pen st(stroke, 1.0f);
        StrokeRounded(g, r, radius, &st);
    }

    // Glow outline
    if (b.glow.v > 0.01f && b.enabled)
    {
        Color glow(
            (BYTE)(b.glow.v * 120),
            gTheme.accent.GetR(),
            gTheme.accent.GetG(),
            gTheme.accent.GetB()
        );
        Pen p(glow, 2.0f);
        StrokeRounded(g, r, radius, &p);
    }

    // Text
    float fontSize = (b.kind == BtnKind::Icon) ? 16.0f : (b.kind == BtnKind::Primary ? 16.0f : 14.0f);
    int weight = (b.kind == BtnKind::Primary) ? 1000 : 800;
    DrawTextW_GDI(g, b.text, r, fontSize, weight, text,
        StringAlignmentCenter, StringAlignmentCenter, false);
}

static void DrawTextBox(Graphics& g, TextBox& t)
{
    RectF r = t.rect;

    // label above
    DrawTextW_GDI(g, t.label, RectF(r.X, r.Y - 18, r.Width, 16), 12, 700, gTheme.text2);

    bool active = t.focused;
    Color stroke = active ? Color(160, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()) : gTheme.stroke;
    Color fill = active ? Color(60, 255,255,255) : Color(38,255,255,255);

    DrawShadow(g, r, 14.0f, 7, Color(60,0,0,0));

    SolidBrush f(fill);
    FillRounded(g, r, 14.0f, &f);

    LinearGradientBrush grad(r, Color(20,255,255,255), Color(0,255,255,255), LinearGradientModeVertical);
    FillRounded(g, r, 14.0f, &grad);

    Pen p(stroke, 1.2f);
    StrokeRounded(g, r, 14.0f, &p);

    // text
    std::wstring show = t.value;
    if (t.password)
        show = std::wstring(show.size(), L'‚Ä¢');

    if (show.empty())
    {
        DrawTextW_GDI(g, t.placeholder, RectF(r.X+12, r.Y, r.Width-24, r.Height), 14, 500, gTheme.text2,
            StringAlignmentNear, StringAlignmentCenter, false);
    }
    else
    {
        DrawTextW_GDI(g, show, RectF(r.X+12, r.Y, r.Width-24, r.Height), 14, 700, gTheme.text0,
            StringAlignmentNear, StringAlignmentCenter, false);
    }

    // caret (very simple; not accurate glyph measuring)
    if (t.focused)
    {
        DWORD now = GetTickCount();
        if (now - t.lastBlink > 520)
        {
            t.caretOn = !t.caretOn;
            t.lastBlink = now;
        }
        if (t.caretOn)
        {
            // approximate caret x by character count * 7 px
            int count = (int)(t.password ? std::wstring(t.value.size(), L'‚Ä¢').size() : t.value.size());
            count = ClampI(t.caret, 0, count);
            float x = r.X + 12.0f + (float)count * 7.0f;
            x = std::min(x, r.X + r.Width - 12.0f);

            Pen caretPen(Color(210, 255,255,255), 1.6f);
            g.DrawLine(&caretPen, x, r.Y + 10.0f, x, r.Y + r.Height - 10.0f);
        }
    }
}

static void DrawToggle(Graphics& g, Toggle& t)
{
    t.anim.target = t.value ? 1.0f : 0.0f;
    t.anim.speed = gSet.animations ? 0.22f : 1.0f;
    t.anim.Tick();

    RectF r = t.rect;

    // Switch area on left
    float swW = 52.0f;
    float swH = 26.0f;
    float swX = r.X;
    float swY = r.Y + (r.Height - swH) * 0.5f;
    RectF sw(swX, swY, swW, swH);

    // text area
    RectF tr(swX + swW + 12.0f, r.Y, r.Width - (swW + 12.0f), r.Height);

    // background switch
    Color onC = gTheme.accent2;
    Color offC = Color(80, 255,255,255);

    Color fill = Color(
        (BYTE)(60 + t.anim.v * 40),
        (BYTE)((offC.GetR() * (1.0f - t.anim.v)) + (onC.GetR() * t.anim.v)),
        (BYTE)((offC.GetG() * (1.0f - t.anim.v)) + (onC.GetG() * t.anim.v)),
        (BYTE)((offC.GetB() * (1.0f - t.anim.v)) + (onC.GetB() * t.anim.v))
    );

    DrawShadow(g, sw, 999.0f, 6, Color(50,0,0,0));
    SolidBrush f(fill);
    FillRounded(g, sw, 999.0f, &f);

    Pen st(t.hover ? gTheme.stroke2 : gTheme.stroke, 1.0f);
    StrokeRounded(g, sw, 999.0f, &st);

    // knob
    float knobR = 20.0f;
    float knobX = sw.X + 4.0f + t.anim.v * (sw.Width - 8.0f - knobR);
    RectF knob(knobX, sw.Y + 3.0f, knobR, knobR);

    SolidBrush kb(Color(220, 255,255,255));
    FillRounded(g, knob, 999.0f, &kb);

    // text
    DrawTextW_GDI(g, t.text, tr, 14, 700, gTheme.text1, StringAlignmentNear, StringAlignmentCenter);
}

static void DrawDropdown(Graphics& g, Dropdown& d)
{
    RectF r = d.rect;

    // label
    DrawTextW_GDI(g, d.label, RectF(r.X, r.Y - 18, r.Width, 16), 12, 700, gTheme.text2);

    // base box
    DrawShadow(g, r, 14.0f, 7, Color(60,0,0,0));
    SolidBrush f(Color(38,255,255,255));
    FillRounded(g, r, 14.0f, &f);

    LinearGradientBrush grad(r, Color(20,255,255,255), Color(0,255,255,255), LinearGradientModeVertical);
    FillRounded(g, r, 14.0f, &grad);

    Pen st(d.hover ? gTheme.stroke2 : gTheme.stroke, 1.2f);
    StrokeRounded(g, r, 14.0f, &st);

    // selected text
    std::wstring txt = d.items.empty() ? L"(empty)" : d.items[ClampI(d.selected,0,(int)d.items.size()-1)];
    DrawTextW_GDI(g, txt, RectF(r.X+12, r.Y, r.Width-44, r.Height), 14, 700, gTheme.text0);

    // arrow
    DrawTextW_GDI(g, d.open ? L"‚ñ≤" : L"‚ñº", RectF(r.X + r.Width - 34, r.Y, 24, r.Height), 12, 900, gTheme.text2, StringAlignmentCenter);

    // open list
    if (d.open && !d.items.empty())
    {
        float itemH = 36.0f;
        float listH = std::min(6.0f, (float)d.items.size()) * itemH + 12.0f;
        RectF list(r.X, r.Y + r.Height + 8.0f, r.Width, listH);

        DrawGlassPanel(g, list, 16.0f);

        // items
        int maxItems = (int)std::min(6.0f, (float)d.items.size());
        for (int i=0;i<maxItems;i++)
        {
            RectF ir(list.X+8, list.Y+8 + i*itemH, list.Width-16, itemH-4);
            bool hov = (i == d.hoverIndex);
            bool sel = (i == d.selected);

            if (hov || sel)
            {
                SolidBrush hi(sel ? Color(50, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB())
                                  : Color(30,255,255,255));
                FillRounded(g, ir, 12.0f, &hi);
            }

            DrawTextW_GDI(g, d.items[i], RectF(ir.X+10, ir.Y, ir.Width-20, ir.Height),
                13, sel?900:700, sel?gTheme.text0:gTheme.text1, StringAlignmentNear, StringAlignmentCenter);
        }
    }
}

// ============================================================
// Page drawing
// ============================================================

static void DrawSidebar(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    DrawGlassPanel(g, side, 20.0f);

    // top user chip
    RectF chip(side.X + 14, side.Y + 14, side.Width - 28, 64);
    DrawShadow(g, chip, 18.0f, 6, Color(65,0,0,0));
    SolidBrush c1(Color(25,255,255,255));
    FillRounded(g, chip, 18.0f, &c1);

    // avatar circle
    RectF ava(chip.X + 12, chip.Y + 12, 40, 40);
    SolidBrush avaB(Color(50, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()));
    FillRounded(g, ava, 16.0f, &avaB);
    DrawTextW_GDI(g, L"M", ava, 18, 1000, Color(240,255,255,255), StringAlignmentCenter);

    DrawTextW_GDI(g, gSet.nickname.empty()?L"Player":gSet.nickname, RectF(ava.X+ava.Width+10, chip.Y+16, chip.Width-ava.Width-22, 20),
        14, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Status: ONLINE", RectF(ava.X+ava.Width+10, chip.Y+36, chip.Width-ava.Width-22, 16),
        12, 700, gTheme.accent2);

    // page hint
    std::wstring pageName = (gPage==Page::Home?L"Home":gPage==Page::News?L"News":L"Settings");
    DrawTextW_GDI(g, L"Page", RectF(side.X+14, side.Y+92, side.Width-28, 16), 12, 700, gTheme.text2);
    DrawTextW_GDI(g, pageName, RectF(side.X+14, side.Y+108, side.Width-28, 22), 16, 1000, gTheme.text0);

    // rest drawn by buttons
}

static void DrawHomePage(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    RectF main(side.X + side.Width + 16.0f, side.Y, (float)ui.w - (side.X + side.Width + 32.0f), side.Height);

    // Hero
    RectF hero(main.X, main.Y, main.Width, 220.0f);
    DrawGlassPanel(g, hero, 22.0f);

    // Hero art overlay
    RectF art(hero.X, hero.Y, hero.Width, hero.Height);
    GraphicsPath p; p.AddEllipse(art.X-120, art.Y-140, 520, 520);
    PathGradientBrush b(&p);
    b.SetCenterColor(Color(90, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()));
    Color edges[1] = { Color(0, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()) };
    int c = 1; b.SetSurroundColors(edges, &c);
    g.FillEllipse(&b, art.X-120, art.Y-140, 520, 520);

    GraphicsPath p2; p2.AddEllipse(art.X+art.Width-380, art.Y-120, 520, 520);
    PathGradientBrush b2(&p2);
    b2.SetCenterColor(Color(80, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()));
    Color edges2[1] = { Color(0, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()) };
    int c2 = 1; b2.SetSurroundColors(edges2, &c2);
    g.FillEllipse(&b2, art.X+art.Width-380, art.Y-120, 520, 520);

    // Hero texts
    DrawTextW_GDI(g, L"MAJESTIC ROLEPLAY", RectF(hero.X+20, hero.Y+18, hero.Width-40, 32), 22, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"GTA RP launcher ‚Ä¢ premium UI (Win32/GDI+)", RectF(hero.X+20, hero.Y+48, hero.Width-40, 18), 13, 700, gTheme.text2);

    // Status chips
    RectF chips(hero.X+20, hero.Y+78, hero.Width-40, 30);
    DrawTextW_GDI(g, L"‚Ä¢ ONLINE", RectF(chips.X, chips.Y, 100, chips.Height), 13, 900, gTheme.accent2);
    DrawTextW_GDI(g, L"‚Ä¢ Anti-cheat: Demo", RectF(chips.X+100, chips.Y, 170, chips.Height), 13, 700, gTheme.text2);
    DrawTextW_GDI(g, L"‚Ä¢ Ping: 22ms", RectF(chips.X+280, chips.Y, 140, chips.Height), 13, 700, gTheme.text2);

    // Divider
    Pen dl(Color(40,255,255,255), 1.0f);
    g.DrawLine(&dl, hero.X+20, hero.Y+124, hero.X+hero.Width-20, hero.Y+124);

    // Right-side: show selected news preview
    std::wstring preview = gNews.empty()?L"No news":gNews[gNewsIndex];
    DrawTextW_GDI(g, L"Latest news", RectF(hero.X+20, hero.Y+132, hero.Width-300, 16), 12, 700, gTheme.text2);
    DrawTextW_GDI(g, preview, RectF(hero.X+20, hero.Y+148, hero.Width-300, 56), 14, 800, gTheme.text0,
        StringAlignmentNear, StringAlignmentNear, true);

    // Secondary card
    RectF q(main.X, main.Y + hero.Height + 16.0f, main.Width, 220.0f);
    DrawGlassPanel(g, q, 22.0f);

    DrawTextW_GDI(g, L"Quick actions", RectF(q.X+20, q.Y+16, q.Width-40, 22), 16, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Set game path, tune args, then press PLAY. Press F11 for fullscreen.", RectF(q.X+20, q.Y+40, q.Width-40, 18),
        13, 700, gTheme.text2);

    // Subtle footer note
    DrawTextW_GDI(g, L"Tip: Settings page contains server list & background.", RectF(q.X+20, q.Y+q.Height-28, q.Width-40, 18),
        12, 700, gTheme.text2);
}

static void DrawNewsPage(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    RectF main(side.X + side.Width + 16.0f, side.Y, (float)ui.w - (side.X + side.Width + 32.0f), side.Height);

    DrawGlassPanel(g, main, 22.0f);
    DrawTextW_GDI(g, L"News", RectF(main.X+16, main.Y+14, main.Width-32, 24), 18, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Auto-rotates every 6s. Use mouse wheel to scroll.", RectF(main.X+16, main.Y+40, main.Width-32, 16),
        12, 700, gTheme.text2);

    // Scroll area
    RectF area = gNewsScroll.rect;
    // compute maxScroll: item count * item height minus area height
    float itemH = 74.0f;
    float contentH = 14.0f + (float)gNews.size() * itemH;
    gNewsScroll.maxScroll = std::max(0.0f, contentH - area.Height);
    gNewsScroll.scroll = ClampF(gNewsScroll.scroll, 0.0f, gNewsScroll.maxScroll);

    // clip
    Region oldClip;
    g.GetClip(&oldClip);
    g.SetClip(area);

    float y = area.Y + 12.0f - gNewsScroll.scroll;
    for (int i=0;i<(int)gNews.size();++i)
    {
        RectF card(area.X + 12.0f, y, area.Width - 24.0f, itemH - 12.0f);
        bool active = (i == gNewsIndex);

        // card bg
        DrawShadow(g, card, 18.0f, 6, Color(55,0,0,0));
        SolidBrush fill(active ? Color(55, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB())
                              : Color(28,255,255,255));
        FillRounded(g, card, 18.0f, &fill);

        Pen st(active ? Color(130, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()) : gTheme.stroke, 1.0f);
        StrokeRounded(g, card, 18.0f, &st);

        DrawTextW_GDI(g, L"Update", RectF(card.X+14, card.Y+10, 120, 16), 12, 900, active?gTheme.text0:gTheme.text2);
        DrawTextW_GDI(g, gNews[i], RectF(card.X+14, card.Y+26, card.Width-28, card.Height-30),
            14, active?1000:800, gTheme.text0, StringAlignmentNear, StringAlignmentNear, true);

        y += itemH;
    }

    // restore clip
    g.SetClip(&oldClip);

    // scrollbar
    if (gNewsScroll.maxScroll > 0.0f)
    {
        float barW = 10.0f;
        RectF track(area.X + area.Width - barW - 6.0f, area.Y + 8.0f, barW, area.Height - 16.0f);
        SolidBrush tr(Color(25,255,255,255));
        FillRounded(g, track, 999.0f, &tr);

        float ratio = area.Height / contentH;
        float thumbH = std::max(36.0f, track.Height * ratio);
        float t = gNewsScroll.scroll / gNewsScroll.maxScroll;
        float thumbY = track.Y + t * (track.Height - thumbH);
        RectF thumb(track.X, thumbY, track.Width, thumbH);

        SolidBrush th(Color(90,255,255,255));
        FillRounded(g, thumb, 999.0f, &th);
    }
}

static void DrawSettingsPage(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    RectF main(side.X + side.Width + 16.0f, side.Y, (float)ui.w - (side.X + side.Width + 32.0f), side.Height);

    DrawGlassPanel(g, main, 22.0f);

    DrawTextW_GDI(g, L"Settings", RectF(main.X+16, main.Y+14, main.Width-32, 24), 18, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"All stored in INI file. No external libraries. Demo only.", RectF(main.X+16, main.Y+40, main.Width-32, 16),
        12, 700, gTheme.text2);

    // column split background (visual separators)
    float colW = (main.Width - 16.0f) * 0.55f;
    RectF left(main.X+8, main.Y+58, colW, main.Height-66);
    RectF right(main.X+8+colW+8, main.Y+58, main.Width - colW - 16, main.Height-66);

    // draw subtle columns
    SolidBrush colBg(Color(18,255,255,255));
    FillRounded(g, left, 18.0f, &colBg);
    FillRounded(g, right, 18.0f, &colBg);

    Pen st(gTheme.stroke, 1.0f);
    StrokeRounded(g, left, 18.0f, &st);
    StrokeRounded(g, right, 18.0f, &st);

    DrawTextW_GDI(g, L"Launcher", RectF(left.X+16, left.Y+10, left.Width-32, 18), 14, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Servers & Appearance", RectF(right.X+16, right.Y+10, right.Width-32, 18), 14, 1000, gTheme.text0);

    // server list preview (simple)
    float y = right.Y + 390.0f;
    DrawTextW_GDI(g, L"Server list (preview)", RectF(right.X+16, y, right.Width-32, 18), 12, 900, gTheme.text2);
    y += 20;

    int show = std::min(6, (int)gSet.servers.size());
    for (int i=0;i<show;i++)
    {
        const auto& s = gSet.servers[i];
        RectF rr(right.X+16, y, right.Width-32, 36);
        SolidBrush f(Color(i==gSet.selectedServer?40:18, 255,255,255));
        FillRounded(g, rr, 14.0f, &f);
        Pen p(i==gSet.selectedServer?Color(120,gTheme.accent.GetR(),gTheme.accent.GetG(),gTheme.accent.GetB()):gTheme.stroke, 1.0f);
        StrokeRounded(g, rr, 14.0f, &p);

        DrawTextW_GDI(g, s.name, RectF(rr.X+12, rr.Y, rr.Width-24, rr.Height), 13, 900, gTheme.text0);
        DrawTextW_GDI(g, s.host + L":" + std::to_wstring(s.port), RectF(rr.X+12, rr.Y+16, rr.Width-24, rr.Height), 12, 700, gTheme.text2, StringAlignmentNear, StringAlignmentNear);
        y += 44;
    }
}

// ============================================================
// UI hit testing
// ============================================================

static bool PtInRectF(const POINT& p, const RectF& r)
{
    return p.x >= r.X && p.x <= (r.X + r.Width) && p.y >= r.Y && p.y <= (r.Y + r.Height);
}

static Button* HitButton(const POINT& p)
{
    for (auto& b : gButtons)
        if (PtInRectF(p, b.rect)) return &b;
    return nullptr;
}

static TextBox* HitTextBox(const POINT& p)
{
    for (auto& t : gTextBoxes)
        if (PtInRectF(p, t.rect)) return &t;
    return nullptr;
}

static Toggle* HitToggle(const POINT& p)
{
    for (auto& t : gToggles)
        if (PtInRectF(p, t.rect)) return &t;
    return nullptr;
}

static Dropdown* HitDropdown(const POINT& p)
{
    for (auto& d : gDropdowns)
        if (PtInRectF(p, d.rect)) return &d;
    return nullptr;
}

static void ClearTextFocus()
{
    for (auto& t : gTextBoxes) t.focused = false;
}

// ============================================================
// Dropdown interactions
// ============================================================

static void CloseAllDropdowns()
{
    for (auto& d : gDropdowns) { d.open = false; d.hoverIndex = -1; }
}

static bool DropdownHitOpenItem(Dropdown& d, const POINT& p, int& outIndex)
{
    if (!d.open) return false;
    float itemH = 36.0f;
    float listH = std::min(6.0f, (float)d.items.size()) * itemH + 12.0f;
    RectF list(d.rect.X, d.rect.Y + d.rect.Height + 8.0f, d.rect.Width, listH);
    if (!PtInRectF(p, list)) return false;

    // items area inside list
    RectF inner(list.X+8, list.Y+8, list.Width-16, list.Height-16);
    float relY = (float)p.y - inner.Y;
    int idx = (int)(relY / itemH);
    idx = ClampI(idx, 0, (int)std::min(6.0f, (float)d.items.size())-1);
    outIndex = idx;
    return true;
}

// ============================================================
// Actions (button click handlers)
// ============================================================

static void ToggleFullscreen(HWND hwnd)
{
    if (!gFullscreen)
    {
        gRestoreStyle = GetWindowLongW(hwnd, GWL_STYLE);
        gRestoreExStyle = GetWindowLongW(hwnd, GWL_EXSTYLE);
        GetWindowRect(hwnd, &gRestoreRect);

        SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP);
        SetWindowLongW(hwnd, GWL_EXSTYLE, gRestoreExStyle);

        int sw = GetSystemMetrics(SM_CXSCREEN);
        int sh = GetSystemMetrics(SM_CYSCREEN);
        SetWindowPos(hwnd, HWND_TOP, 0, 0, sw, sh, SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        gFullscreen = true;
    }
    else
    {
        SetWindowLongW(hwnd, GWL_STYLE, gRestoreStyle);
        SetWindowLongW(hwnd, GWL_EXSTYLE, gRestoreExStyle);

        SetWindowPos(hwnd, HWND_TOP,
            gRestoreRect.left, gRestoreRect.top,
            gRestoreRect.right - gRestoreRect.left,
            gRestoreRect.bottom - gRestoreRect.top,
            SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        gFullscreen = false;
    }
}

static void ApplyTextBoxToSettings()
{
    for (auto& t : gTextBoxes)
    {
        if (t.id == ID_TX_GAMEPATH) gSet.gamePath = t.value;
        if (t.id == ID_TX_ARGS) gSet.gameArgs = t.value;
        if (t.id == ID_TX_DISCORD) gSet.discordUrl = t.value;
        if (t.id == ID_TX_BG) gSet.backgroundPath = t.value;
        if (t.id == ID_TX_NICK) gSet.nickname = t.value;

        // server editor fields (settings page)
        if (t.id == 9001)
        {
            int idx = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
            gSet.servers[idx].name = t.value;
        }
        if (t.id == 9002)
        {
            int idx = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
            gSet.servers[idx].host = t.value;
        }
        if (t.id == 9003)
        {
            int idx = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
            int p = _wtoi(t.value.c_str());
            if (p <= 0) p = 7777;
            gSet.servers[idx].port = p;
        }
    }
}

static void ApplyToggleToSettings()
{
    for (auto& t : gToggles)
    {
        if (t.id == ID_TG_AUTOLAUNCH) gSet.autoLaunch = t.value;
        if (t.id == ID_TG_FULLSCREEN) gSet.startFullscreen = t.value;
        if (t.id == ID_TG_ANIMATIONS) gSet.animations = t.value;
    }
}

static void ApplyDropdownToSettings(HWND hwnd)
{
    for (auto& d : gDropdowns)
    {
        if (d.id == ID_DD_SERVER)
        {
            gSet.selectedServer = d.selected;
        }
        if (d.id == ID_DD_THEME)
        {
            gSet.theme = (d.selected == 1) ? ThemeMode::Neon : ThemeMode::Dark;
            gTheme.Apply(gSet.theme);

            // reload background
            if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
            if (!gSet.backgroundPath.empty() && FileExists(gSet.backgroundPath))
            {
                gBgImage = Image::FromFile(gSet.backgroundPath.c_str());
                if (gBgImage && gBgImage->GetLastStatus() != Ok)
                {
                    delete gBgImage;
                    gBgImage = nullptr;
                }
            }

            InvalidateRect(hwnd, NULL, FALSE);
        }
    }
}

static void HandleButtonClick(HWND hwnd, int id)
{
    if (id == ID_BTN_CLOSE)
    {
        PostMessageW(hwnd, WM_CLOSE, 0, 0);
        return;
    }
    if (id == ID_BTN_MIN)
    {
        ShowWindow(hwnd, SW_MINIMIZE);
        return;
    }

    if (id == ID_BTN_HOME) { gPage = Page::Home; InvalidateRect(hwnd,NULL,FALSE); return; }
    if (id == ID_BTN_NEWS) { gPage = Page::News; InvalidateRect(hwnd,NULL,FALSE); return; }
    if (id == ID_BTN_SETTINGS) { gPage = Page::Settings; InvalidateRect(hwnd,NULL,FALSE); return; }

    if (id == ID_BTN_DISCORD)
    {
        ApplyTextBoxToSettings();
        if (!gSet.discordUrl.empty()) ShellOpenUrl(gSet.discordUrl);
        else toast(L"Discord", L"URL is empty", L"warn");
        return;
    }

    if (id == ID_BTN_THEME)
    {
        // toggle theme quick
        gSet.theme = (gSet.theme == ThemeMode::Dark) ? ThemeMode::Neon : ThemeMode::Dark;
        gTheme.Apply(gSet.theme);
        IniWriteInt(L"Appearance", L"Theme", (gSet.theme==ThemeMode::Neon)?1:0);
        toast(L"Theme", (gSet.theme==ThemeMode::Neon)?L"Neon":L"Dark", L"ok");
        InvalidateRect(hwnd,NULL,FALSE);
        return;
    }

    if (id == ID_BTN_SEED_NEWS)
    {
        gNewsIndex = (gNewsIndex + 1) % (int)gNews.size();
        InvalidateRect(hwnd,NULL,FALSE);
        return;
    }

    if (id == ID_BTN_OPEN_GAME)
    {
        std::wstring p = OpenFileDialog(hwnd,
            L"Executable (*.exe)\0*.exe\0All files (*.*)\0*.*\0\0",
            L"Select game executable");
        if (!p.empty())
        {
            gSet.gamePath = p;
            // reflect into textboxes
            for (auto& tb : gTextBoxes)
                if (tb.id == ID_TX_GAMEPATH) { tb.value = p; tb.caret = (int)tb.value.size(); }
            toast(L"Selected", p, L"ok");
            InvalidateRect(hwnd,NULL,FALSE);
        }
        return;
    }

    if (id == ID_BTN_OPEN_LOG)
    {
        if (gPage == Page::Home)
        {
            MsgBox(hwnd, L"Info", L"This demo launcher uses:\n- Win32 + GDI+ only\n- INI settings\n- Custom UI + animations\n\nNext steps: login/auth, patcher, auto-updater.");
        }
        else if (gPage == Page::Settings)
        {
            std::wstring p = OpenFileDialog(hwnd,
                L"Images (*.png;*.jpg;*.jpeg)\0*.png;*.jpg;*.jpeg\0All files (*.*)\0*.*\0\0",
                L"Select background image");
            if (!p.empty())
            {
                gSet.backgroundPath = p;
                for (auto& tb : gTextBoxes)
                    if (tb.id == ID_TX_BG) { tb.value = p; tb.caret = (int)tb.value.size(); }

                if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
                gBgImage = Image::FromFile(p.c_str());
                if (gBgImage && gBgImage->GetLastStatus() != Ok)
                {
                    delete gBgImage;
                    gBgImage = nullptr;
                    toast(L"Background", L"Failed to load image", L"err");
                }
                else toast(L"Background", L"Loaded", L"ok");

                InvalidateRect(hwnd,NULL,FALSE);
            }
        }
        return;
    }

    if (id == ID_BTN_F11)
    {
        ToggleFullscreen(hwnd);
        return;
    }

    if (id == ID_BTN_PLAY)
    {
        ApplyTextBoxToSettings();
        ApplyDropdownToSettings(hwnd);

        if (gSet.gamePath.empty() || !FileExists(gSet.gamePath))
        {
            toast(L"Play", L"Game EXE path not set. Open Settings / Choose Game EXE.", L"err");
            return;
        }

        // If server selected, append args like --connect host:port (demo)
        int idx = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
        std::wstring extra;
        if (!gSet.servers.empty())
        {
            const auto& s = gSet.servers[idx];
            extra = L"--connect " + s.host + L":" + std::to_wstring(s.port);
        }

        std::wstring args = gSet.gameArgs;
        if (!extra.empty())
        {
            if (!args.empty()) args += L" ";
            args += extra;
        }

        std::wstring wd = GetExeDir(); // or derive from exe path
        // try derive working dir from gamePath
        {
            std::wstring p = gSet.gamePath;
            size_t pos = p.find_last_of(L"\\/");
            if (pos != std::wstring::npos) wd = p.substr(0, pos);
        }

        bool ok = LaunchProcess(gSet.gamePath, args, wd);
        if (ok) toast(L"Launching", L"Game started (demo)", L"ok");
        else toast(L"Launch failed", L"CreateProcess failed. Check path/permissions.", L"err");
        return;
    }

    if (id == ID_BTN_ADD_SERVER)
    {
        ServerItem s;
        s.name = L"Server-" + std::to_wstring((int)gSet.servers.size()+1);
        s.host = L"127.0.0.1";
        s.port = 7777;
        gSet.servers.push_back(s);
        gSet.selectedServer = (int)gSet.servers.size()-1;
        toast(L"Server", L"Added", L"ok");
        InvalidateRect(hwnd,NULL,FALSE);
        return;
    }

    if (id == ID_BTN_DEL_SERVER)
    {
        if (gSet.servers.size() <= 1)
        {
            toast(L"Server", L"At least 1 server required", L"warn");
            return;
        }
        int idx = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
        gSet.servers.erase(gSet.servers.begin() + idx);
        gSet.selectedServer = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
        toast(L"Server", L"Removed", L"ok");
        InvalidateRect(hwnd,NULL,FALSE);
        return;
    }

    if (id == ID_BTN_SAVE_SETTINGS)
    {
        ApplyTextBoxToSettings();
        ApplyToggleToSettings();
        ApplyDropdownToSettings(hwnd);

        // Validate some fields
        if (!gSet.discordUrl.empty() && gSet.discordUrl.find(L"http") != 0)
        {
            toast(L"Discord URL", L"Must start with http/https", L"warn");
        }

        SaveSettings();

        // reload background if changed
        if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
        if (!gSet.backgroundPath.empty() && FileExists(gSet.backgroundPath))
        {
            gBgImage = Image::FromFile(gSet.backgroundPath.c_str());
            if (gBgImage && gBgImage->GetLastStatus() != Ok)
            {
                delete gBgImage;
                gBgImage = nullptr;
            }
        }

        InvalidateRect(hwnd,NULL,FALSE);
        return;
    }
}

// ============================================================
// Painting (double buffer)
// ============================================================

static void Paint(HWND hwnd)
{
    RECT rc; GetClientRect(hwnd, &rc);
    int w = rc.right - rc.left;
    int h = rc.bottom - rc.top;

    HDC hdc = GetDC(hwnd);
    HDC mem = CreateCompatibleDC(hdc);
    HBITMAP bmp = CreateCompatibleBitmap(hdc, w, h);
    HBITMAP old = (HBITMAP)SelectObject(mem, bmp);

    Graphics g(mem);
    g.SetSmoothingMode(SmoothingModeAntiAlias);
    g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
    g.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    // background
    DrawTopGradientBG(g, w, h);

    UIContext ui;
    ui.hwnd = hwnd;
    ui.w = w;
    ui.h = h;

    BuildLayout(ui);

    // TitleBar
    DrawTitleBar(g, ui);

    // Sidebar panel
    DrawSidebar(g, ui);

    // Main page area panel depends
    if (gPage == Page::Home) DrawHomePage(g, ui);
    else if (gPage == Page::News) DrawNewsPage(g, ui);
    else DrawSettingsPage(g, ui);

    // Update nav button active styles (visual using hover/glow, but active for page)
    // We'll just draw buttons and set their text/appearance by page state
    for (auto& b : gButtons)
    {
        if (b.id == ID_BTN_HOME) b.kind = (gPage==Page::Home) ? BtnKind::Primary : BtnKind::Secondary;
        if (b.id == ID_BTN_NEWS) b.kind = (gPage==Page::News) ? BtnKind::Primary : BtnKind::Secondary;
        if (b.id == ID_BTN_SETTINGS) b.kind = (gPage==Page::Settings) ? BtnKind::Primary : BtnKind::Secondary;

        // Close/min icon style
        if (b.id == ID_BTN_CLOSE) b.kind = BtnKind::Danger;
        if (b.id == ID_BTN_MIN) b.kind = BtnKind::Secondary;

        DrawButton(g, b);
    }

    for (auto& t : gTextBoxes) DrawTextBox(g, t);
    for (auto& t : gToggles) DrawToggle(g, t);
    for (auto& d : gDropdowns) DrawDropdown(g, d);

    // present
    BitBlt(hdc, 0, 0, w, h, mem, 0, 0, SRCCOPY);

    SelectObject(mem, old);
    DeleteObject(bmp);
    DeleteDC(mem);
    ReleaseDC(hwnd, hdc);
}

// ============================================================
// Hover animation updates
// ============================================================

static void UpdateHover(UIContext& ui)
{
    // Buttons hover
    for (auto& b : gButtons)
    {
        bool h = PtInRectF(ui.mousePos, b.rect);
        b.hover = h;
        if (!ui.mouseDown) b.down = false;
    }

    // Textboxes hover
    for (auto& t : gTextBoxes)
    {
        t.hover = PtInRectF(ui.mousePos, t.rect);
    }

    // Toggles hover
    for (auto& t : gToggles)
        t.hover = PtInRectF(ui.mousePos, t.rect);

    // Dropdown hover + open list hover
    for (auto& d : gDropdowns)
    {
        d.hover = PtInRectF(ui.mousePos, d.rect);
        if (d.open)
        {
            int idx = -1;
            if (DropdownHitOpenItem(d, ui.mousePos, idx))
                d.hoverIndex = idx;
            else
                d.hoverIndex = -1;
        }
    }
}

// ============================================================
// Message handling
// ============================================================

static void ApplyInitialFullscreen(HWND hwnd)
{
    if (gSet.startFullscreen)
        ToggleFullscreen(hwnd);
}

static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM w, LPARAM l)
{
    static UIContext ui;
    static bool dragging = false;
    static POINT dragStart{};
    static RECT wndStart{};

    switch (msg)
    {
    case WM_CREATE:
    {
        ui.hwnd = hwnd;
        SetTimer(hwnd, T_ANIM, 16, NULL);
        SetTimer(hwnd, T_NEWS, 6000, NULL);
        SetTimer(hwnd, T_CARET, 120, NULL);
        return 0;
    }

    case WM_TIMER:
    {
        if (w == T_NEWS)
        {
            gNewsIndex = (gNewsIndex + 1) % (int)gNews.size();
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (w == T_ANIM)
        {
            // just repaint for smooth hover animations
            if (gSet.animations)
                InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (w == T_CARET)
        {
            // caret blink update occurs in DrawTextBox; repaint if any focused
            bool any = false;
            for (auto& t : gTextBoxes) if (t.focused) { any = true; break; }
            if (any) InvalidateRect(hwnd, NULL, FALSE);
        }
        return 0;
    }

    case WM_SIZE:
    {
        RECT rc; GetClientRect(hwnd, &rc);
        ui.w = rc.right - rc.left;
        ui.h = rc.bottom - rc.top;
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_MOUSEMOVE:
    {
        ui.mousePos.x = GET_X_LPARAM(l);
        ui.mousePos.y = GET_Y_LPARAM(l);
        UpdateHover(ui);

        // dragging window via titlebar
        if (dragging)
        {
            POINT cur; GetCursorPos(&cur);
            int dx = cur.x - dragStart.x;
            int dy = cur.y - dragStart.y;
            SetWindowPos(hwnd, NULL, wndStart.left + dx, wndStart.top + dy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        }

        if (!gSet.animations)
            InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_MOUSEWHEEL:
    {
        if (gPage == Page::News)
        {
            int delta = GET_WHEEL_DELTA_WPARAM(w);
            float step = (delta > 0) ? -48.0f : 48.0f;
            gNewsScroll.scroll = ClampF(gNewsScroll.scroll + step, 0.0f, gNewsScroll.maxScroll);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        return 0;
    }

    case WM_LBUTTONDOWN:
    {
        ui.mouseDown = true;
        SetCapture(hwnd);

        POINT p{ GET_X_LPARAM(l), GET_Y_LPARAM(l) };

        // Dropdown open item click
        for (auto& d : gDropdowns)
        {
            int idx = -1;
            if (DropdownHitOpenItem(d, p, idx))
            {
                d.selected = idx;
                d.open = false;
                ApplyDropdownToSettings(hwnd);
                InvalidateRect(hwnd, NULL, FALSE);
                ReleaseCapture();
                ui.mouseDown = false;
                return 0;
            }
        }

        // Button click start
        if (Button* b = HitButton(p))
        {
            b->down = true;
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }

        // Toggle click
        if (Toggle* t = HitToggle(p))
        {
            t->value = !t->value;
            t->anim.target = t->value ? 1.0f : 0.0f;
            ApplyToggleToSettings();
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }

        // Dropdown click open
        if (Dropdown* d = HitDropdown(p))
        {
            // close others
            for (auto& dd : gDropdowns)
                if (dd.id != d->id) dd.open = false;

            d->open = !d->open;
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }
        else
        {
            // click outside closes dropdowns
            CloseAllDropdowns();
        }

        // Textbox focus
        if (TextBox* t = HitTextBox(p))
        {
            ClearTextFocus();
            t->focused = true;
            t->caretOn = true;
            t->lastBlink = GetTickCount();
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }
        else
        {
            ClearTextFocus();
        }

        // Titlebar drag region (avoid top-right buttons)
        if (p.y <= 54 && p.x < ui.w - 120)
        {
            dragging = true;
            GetCursorPos(&dragStart);
            GetWindowRect(hwnd, &wndStart);
        }

        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_LBUTTONUP:
    {
        ui.mouseDown = false;
        ReleaseCapture();
        dragging = false;

        POINT p{ GET_X_LPARAM(l), GET_Y_LPARAM(l) };

        // If any button was pressed and released over it -> click
        for (auto& b : gButtons)
        {
            bool wasDown = b.down;
            b.down = false;
            if (wasDown && PtInRectF(p, b.rect) && b.enabled)
            {
                HandleButtonClick(hwnd, b.id);
                break;
            }
        }

        // Close dropdown if clicked elsewhere
        bool clickedDropdown = false;
        for (auto& d : gDropdowns)
        {
            if (PtInRectF(p, d.rect)) clickedDropdown = true;
        }
        if (!clickedDropdown)
        {
            // if click outside dropdown list also close
            bool hitOpenList = false;
            for (auto& d : gDropdowns)
            {
                int idx=-1;
                if (DropdownHitOpenItem(d, p, idx)) hitOpenList = true;
            }
            if (!hitOpenList) CloseAllDropdowns();
        }

        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_CHAR:
    {
        // Handle text input for focused textbox
        wchar_t ch = (wchar_t)w;
        if (ch == 0) return 0;

        for (auto& t : gTextBoxes)
        {
            if (!t.focused) continue;

            if (ch == 8) // backspace
            {
                if (!t.value.empty() && t.caret > 0)
                {
                    t.value.erase(t.value.begin() + (t.caret - 1));
                    t.caret--;
                }
            }
            else if (ch == 13) // enter
            {
                // apply quickly if nickname changed
                if (t.id == ID_TX_NICK)
                {
                    ApplyTextBoxToSettings();
                    toast(L"Nickname", L"Updated", L"ok");
                }
                t.focused = false;
            }
            else if (ch >= 32)
            {
                // Insert at caret
                if ((int)t.value.size() < 180)
                {
                    t.value.insert(t.value.begin() + t.caret, ch);
                    t.caret++;
                }
            }
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }
        return 0;
    }

    case WM_KEYDOWN:
    {
        if (w == VK_F11)
        {
            ToggleFullscreen(hwnd);
            return 0;
        }

        // simple caret movement
        for (auto& t : gTextBoxes)
        {
            if (!t.focused) continue;
            if (w == VK_LEFT) { t.caret = ClampI(t.caret - 1, 0, (int)t.value.size()); InvalidateRect(hwnd,NULL,FALSE); return 0; }
            if (w == VK_RIGHT){ t.caret = ClampI(t.caret + 1, 0, (int)t.value.size()); InvalidateRect(hwnd,NULL,FALSE); return 0; }
            if (w == VK_HOME){ t.caret = 0; InvalidateRect(hwnd,NULL,FALSE); return 0; }
            if (w == VK_END){ t.caret = (int)t.value.size(); InvalidateRect(hwnd,NULL,FALSE); return 0; }
        }
        return 0;
    }

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        BeginPaint(hwnd, &ps);
        Paint(hwnd);
        EndPaint(hwnd, &ps);
        return 0;
    }

    case WM_ERASEBKGND:
        return 1; // prevent flicker

    case WM_DESTROY:
        KillTimer(hwnd, T_ANIM);
        KillTimer(hwnd, T_NEWS);
        KillTimer(hwnd, T_CARET);
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProcW(hwnd, msg, w, l);
    }
}

// ============================================================
// WinMain
// ============================================================

int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE, PWSTR, int)
{
    // GDI+
    GdiplusStartupInput gdiplusStartupInput;
    if (GdiplusStartup(&gGdiToken, &gdiplusStartupInput, NULL) != Ok)
        return 0;

    // Load settings
    LoadSettings();

    // Register class
    WNDCLASSW wc{};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInst;
    wc.lpszClassName = APP_CLASS;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    RegisterClassW(&wc);

    // Create window (frameless)
    DWORD style = WS_POPUP;
    DWORD ex = WS_EX_APPWINDOW;

    HWND hwnd = CreateWindowExW(
        ex,
        APP_CLASS,
        APP_TITLE,
        style,
        120, 80,
        gWinW, gWinH,
        NULL, NULL,
        hInst,
        NULL
    );

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    // Apply fullscreen if configured
    if (gSet.startFullscreen)
        ToggleFullscreen(hwnd);

    // Autolaunch if enabled (demo behavior: only if gamePath valid)
    if (gSet.autoLaunch && !gSet.gamePath.empty() && FileExists(gSet.gamePath))
    {
        // delay a little (in real we‚Äôd do PostMessage + timer)
        toast(L"AutoLaunch", L"Enabled (demo). Press PLAY to confirm.", L"warn");
    }

    // Message loop
    MSG msg{};
    while (GetMessageW(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    // cleanup
    if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
    GdiplusShutdown(gGdiToken);
    return 0;
}

/*
============================================================
WHAT YOU GET (Investor / Showcase points):
- Clean frameless window with custom titlebar
- "Majestic-like" premium visual language:
  - Glass panels, shadows, gradients, glow states
  - Sidebar navigation with active state
  - Large hero card + big CTA (PLAY)
  - News page with scrolling and auto-rotation
  - Settings page with toggles, dropdowns, server management
- No third-party UI libs, only Win32 + GDI+ (system)
- INI persistence for all settings

NEXT UP (if you want "real launcher"):
- Auth (login/register) via your API (HTTPS)
- Auto-updater: manifest.json + hash + signature
- Server status/ping querying
- Embedded browser panel for news / shop
- Anti-cheat bootstrapper / integrity checks
============================================================
*/
–°–±–æ—Ä–∫–∞ –Ω–∞—á–∞—Ç–∞ –≤ 14:50...
1>------ –°–±–æ—Ä–∫–∞ –Ω–∞—á–∞—Ç–∞: –ø—Ä–æ–µ–∫—Ç: WindowsProject4, –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è: Debug x64 ------
1>WindowsProject4.cpp
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(19,9): warning C4005: UNICODE: –∏–∑–º–µ–Ω–µ–Ω–∏–µ –º–∞–∫—Ä–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(19,9):
1>    "UNICODE" —Ä–∞–Ω–µ–µ –æ–±—ä—è–≤–ª–µ–Ω –≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(20,9): warning C4005: _UNICODE: –∏–∑–º–µ–Ω–µ–Ω–∏–µ –º–∞–∫—Ä–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(20,9):
1>    "_UNICODE" —Ä–∞–Ω–µ–µ –æ–±—ä—è–≤–ª–µ–Ω –≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(134,15): error C2664: "BOOL CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION)": –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç 2 –∏–∑ "const _Elem *" –≤ "LPWSTR"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(134,15): error C2664:         with
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(134,15): error C2664:         [
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(134,15): error C2664:             _Elem=wchar_t
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(134,15): error C2664:         ]
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(136,24):
1>    –í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ç–µ—Ä—è—é—Ç—Å—è –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\processthreadsapi.h(386,1):
1>     —Å–º. –æ–±—ä—è–≤–ª–µ–Ω–∏–µ "CreateProcessW"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(134,15):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(int, const _Elem *, int, int, int, int, int, const _Elem *, STARTUPINFOW *, PROCESS_INFORMATION *)"
1>        with
1>        [
1>            _Elem=wchar_t
1>        ]
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(160,19): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(160,19): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(558,5): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(625,28): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(625,28): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(635,11): error C2666: "Gdiplus::Graphics::FillRectangle": –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–æ—Ö–æ–∂–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(997,12):
1>    –º–æ–∂–µ—Ç –±—ã—Ç—å "Gdiplus::Status Gdiplus::Graphics::FillRectangle(const Gdiplus::Brush *,INT,INT,INT,INT)"
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(967,12):
1>    –∏–ª–∏       "Gdiplus::Status Gdiplus::Graphics::FillRectangle(const Gdiplus::Brush *,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL)"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(635,11):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(Gdiplus::SolidBrush *, int, int, Gdiplus::REAL, Gdiplus::REAL)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(662,7): error C2666: "Gdiplus::Graphics::FillRectangle": –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–æ—Ö–æ–∂–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(997,12):
1>    –º–æ–∂–µ—Ç –±—ã—Ç—å "Gdiplus::Status Gdiplus::Graphics::FillRectangle(const Gdiplus::Brush *,INT,INT,INT,INT)"
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(967,12):
1>    –∏–ª–∏       "Gdiplus::Status Gdiplus::Graphics::FillRectangle(const Gdiplus::Brush *,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL)"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(662,7):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(Gdiplus::SolidBrush *, int, int, Gdiplus::REAL, Gdiplus::REAL)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(862,7): error C2666: "Gdiplus::Graphics::DrawLine": –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–æ—Ö–æ–∂–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(460,12):
1>    –º–æ–∂–µ—Ç –±—ã—Ç—å "Gdiplus::Status Gdiplus::Graphics::DrawLine(const Gdiplus::Pen *,INT,INT,INT,INT)"
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(433,12):
1>    –∏–ª–∏       "Gdiplus::Status Gdiplus::Graphics::DrawLine(const Gdiplus::Pen *,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL)"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(862,7):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(Gdiplus::Pen *, int, int, Gdiplus::REAL, int)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1035,22): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1035,22): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1120,28): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1120,28): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1126,34): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1126,34): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1191,23): error C2666: "Gdiplus::GraphicsPath::AddEllipse": –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–æ—Ö–æ–∂–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusPath.h(512,12):
1>    –º–æ–∂–µ—Ç –±—ã—Ç—å "Gdiplus::Status Gdiplus::GraphicsPath::AddEllipse(INT,INT,INT,INT)"
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusPath.h(495,12):
1>    –∏–ª–∏       "Gdiplus::Status Gdiplus::GraphicsPath::AddEllipse(Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL)"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1191,23):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(Gdiplus::REAL, Gdiplus::REAL, int, int)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1196,7): error C2666: "Gdiplus::Graphics::FillEllipse": –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–æ—Ö–æ–∂–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(1079,12):
1>    –º–æ–∂–µ—Ç –±—ã—Ç—å "Gdiplus::Status Gdiplus::Graphics::FillEllipse(const Gdiplus::Brush *,INT,INT,INT,INT)"
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(1062,12):
1>    –∏–ª–∏       "Gdiplus::Status Gdiplus::Graphics::FillEllipse(const Gdiplus::Brush *,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL)"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1196,7):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(Gdiplus::PathGradientBrush *, Gdiplus::REAL, Gdiplus::REAL, int, int)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1198,25): error C2666: "Gdiplus::GraphicsPath::AddEllipse": –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–æ—Ö–æ–∂–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusPath.h(512,12):
1>    –º–æ–∂–µ—Ç –±—ã—Ç—å "Gdiplus::Status Gdiplus::GraphicsPath::AddEllipse(INT,INT,INT,INT)"
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusPath.h(495,12):
1>    –∏–ª–∏       "Gdiplus::Status Gdiplus::GraphicsPath::AddEllipse(Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL)"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1198,25):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(Gdiplus::REAL, Gdiplus::REAL, int, int)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1203,7): error C2666: "Gdiplus::Graphics::FillEllipse": –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–æ—Ö–æ–∂–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(1079,12):
1>    –º–æ–∂–µ—Ç –±—ã—Ç—å "Gdiplus::Status Gdiplus::Graphics::FillEllipse(const Gdiplus::Brush *,INT,INT,INT,INT)"
1>    C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\GdiplusGraphics.h(1062,12):
1>    –∏–ª–∏       "Gdiplus::Status Gdiplus::Graphics::FillEllipse(const Gdiplus::Brush *,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL,Gdiplus::REAL)"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1203,7):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(Gdiplus::PathGradientBrush *, Gdiplus::REAL, Gdiplus::REAL, int, int)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1253,34): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1253,34): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1295,29): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1295,29): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1338,21): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1338,21): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1409,24): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1409,24): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1417,36): error C2589: (: –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –ª–µ–∫—Å–µ–º–∞ —Å–ø—Ä–∞–≤–∞ –æ—Ç "::"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1417,11): error C2660: ClampI: —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç 2 –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(53,21):
1>     —Å–º. –æ–±—ä—è–≤–ª–µ–Ω–∏–µ "ClampI"
1>    C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1417,11):
1>    –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ "(int, int)"
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1417,72): error C2059: —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: )
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1550,14): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1560,9): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1583,13): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1612,21): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1614,22): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1635,13): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1664,17): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1665,14): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1677,9): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1686,13): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1692,9): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(1706,13): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(2079,21): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>C:\Users\User\source\repos\WindowsProject4\WindowsProject4\WindowsProject4.cpp(2192,9): error C3861: toast: –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω
1>–°–±–æ—Ä–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞ "WindowsProject4.vcxproj" –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–æ–π.
========== –°–±–æ—Ä–∫–∞: —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ¬†‚Äî 0 , —Å–æ —Å–±–æ–µ–º¬†‚Äî 1, –≤ –∞–∫—Ç—É–∞–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏¬†‚Äî 0, –ø—Ä–æ–ø—É—â–µ–Ω–æ¬†‚Äî 0 ==========
========== –°–±–æ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –≤ 14:50 –∏ –∑–∞–Ω—è–ª–æ 00,886 —Å ==========
