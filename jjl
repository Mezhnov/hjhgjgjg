// Launcher_MajesticStyle_FIXED.cpp
// ============================================================
// Majestic-like GTA RP launcher style demo (Win32 + GDI+ only)
// - Single file
// - No third-party libs
// - INI settings
// - Pages: Home / News / Settings
// - Custom titlebar (minimize + close), F11 fullscreen
// - Double-buffer painting, hover animations, toast
// - News/Banners: HTML-like strings rendered by mini parser (GDI+)
//   Supports: <h1> <h2> <p> <br> <b> <i> <a href="...">text</a>
//
// Build notes (Visual Studio):
// - Project: Windows Desktop Application (C++)
// - Character Set: Unicode
// - C++ Language Standard: at least C++14 (works with default MSVC too)
// - Linker -> Input: gdiplus.lib comctl32.lib
//
// ============================================================

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shellapi.h>
#include <gdiplus.h>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cctype>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "comctl32.lib")

using namespace Gdiplus;

// ============================================================
// Global config
// ============================================================

static int gWinW = 1100;
static int gWinH = 650;

static const wchar_t* APP_CLASS = L"MAJESTIC_STYLE_LAUNCHER_DEMO_FIXED";
static const wchar_t* APP_TITLE = L"Majestic RP Launcher (Style Demo) - FIXED";
static const wchar_t* INI_FILE  = L"launcher_settings.ini";

// ============================================================
// Utility
// ============================================================

static inline float ClampF(float v, float a, float b) { return (v < a) ? a : (v > b) ? b : v; }
static inline int   ClampI(int v, int a, int b) { return (v < a) ? a : (v > b) ? b : v; }

static bool FileExists(const std::wstring& p)
{
    DWORD attr = GetFileAttributesW(p.c_str());
    return (attr != INVALID_FILE_ATTRIBUTES) && !(attr & FILE_ATTRIBUTE_DIRECTORY);
}

static std::wstring GetExeDir()
{
    wchar_t path[MAX_PATH]{0};
    GetModuleFileNameW(NULL, path, MAX_PATH);
    std::wstring p(path);
    size_t pos = p.find_last_of(L"\\/");
    if (pos != std::wstring::npos) p = p.substr(0, pos);
    return p;
}

static std::wstring IniRead(const wchar_t* section, const wchar_t* key, const wchar_t* def)
{
    wchar_t buf[4096]{0};
    GetPrivateProfileStringW(section, key, def, buf, (DWORD)_countof(buf), INI_FILE);
    return buf;
}

static void IniWrite(const wchar_t* section, const wchar_t* key, const std::wstring& val)
{
    WritePrivateProfileStringW(section, key, val.c_str(), INI_FILE);
}

static int IniReadInt(const wchar_t* section, const wchar_t* key, int def)
{
    return GetPrivateProfileIntW(section, key, def, INI_FILE);
}

static void IniWriteInt(const wchar_t* section, const wchar_t* key, int val)
{
    wchar_t buf[64];
    wsprintfW(buf, L"%d", val);
    WritePrivateProfileStringW(section, key, buf, INI_FILE);
}

static std::wstring OpenFileDialog(HWND hwnd, const wchar_t* filter, const wchar_t* title)
{
    OPENFILENAMEW ofn{};
    wchar_t file[MAX_PATH]{0};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = filter;
    ofn.lpstrFile = file;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;
    ofn.lpstrTitle = title;
    if (GetOpenFileNameW(&ofn))
        return file;
    return L"";
}

static void ShellOpenUrl(const std::wstring& url)
{
    ShellExecuteW(NULL, L"open", url.c_str(), NULL, NULL, SW_SHOWNORMAL);
}

static void MsgBox(HWND hwnd, const std::wstring& title, const std::wstring& text)
{
    MessageBoxW(hwnd, text.c_str(), title.c_str(), MB_OK | MB_ICONINFORMATION);
}

// Launch EXE with arguments (fixed CreateProcessW LPWSTR)
static bool LaunchProcess(const std::wstring& exePath, const std::wstring& args, const std::wstring& workDir)
{
    std::wstring cmd = L"\"" + exePath + L"\"";
    if (!args.empty())
        cmd += L" " + args;

    // CreateProcessW wants writable buffer for lpCommandLine
    std::vector<wchar_t> cmdBuf(cmd.begin(), cmd.end());
    cmdBuf.push_back(L'\0');

    STARTUPINFOW si{};
    si.cb = sizeof(si);
    PROCESS_INFORMATION pi{};

    BOOL ok = CreateProcessW(
        NULL,
        cmdBuf.data(),           // LPWSTR (writable)
        NULL, NULL,
        FALSE,
        0,
        NULL,
        workDir.empty() ? NULL : workDir.c_str(),
        &si,
        &pi
    );

    if (ok)
    {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return true;
    }
    return false;
}

// ============================================================
// GDI+ Helpers: rounded rect + shadow
// ============================================================

static GraphicsPath* MakeRoundedRectPath(RectF r, float radius)
{
    radius = std::max(0.0f, radius);
    float d = radius * 2.0f;

    GraphicsPath* path = new GraphicsPath();
    if (radius <= 0.01f)
    {
        path->AddRectangle(r);
        path->CloseFigure();
        return path;
    }

    path->AddArc(r.X, r.Y, d, d, 180, 90);
    path->AddArc(r.X + r.Width - d, r.Y, d, d, 270, 90);
    path->AddArc(r.X + r.Width - d, r.Y + r.Height - d, d, d, 0, 90);
    path->AddArc(r.X, r.Y + r.Height - d, d, d, 90, 90);
    path->CloseFigure();
    return path;
}

static void DrawShadow(Graphics& g, RectF r, float radius, int layers, Color base)
{
    for (int i = 0; i < layers; ++i)
    {
        float t = (float)i / (float)layers;
        float expand = 2.0f + t * 10.0f;
        int a = (int)(base.GetA() * (1.0f - t) * 0.55f);
        Pen pen(Color((BYTE)a, base.GetR(), base.GetG(), base.GetB()), 2.0f + t * 6.0f);
        RectF rr = r;
        rr.X -= expand; rr.Y -= expand;
        rr.Width += expand * 2; rr.Height += expand * 2;
        GraphicsPath* p = MakeRoundedRectPath(rr, radius + expand);
        g.DrawPath(&pen, p);
        delete p;
    }
}

static void FillRounded(Graphics& g, RectF r, float radius, Brush* b)
{
    GraphicsPath* p = MakeRoundedRectPath(r, radius);
    g.FillPath(b, p);
    delete p;
}

static void StrokeRounded(Graphics& g, RectF r, float radius, Pen* p)
{
    GraphicsPath* gp = MakeRoundedRectPath(r, radius);
    g.DrawPath(p, gp);
    delete gp;
}

// ============================================================
// Theme
// ============================================================

enum class ThemeMode { Dark = 0, Neon = 1 };

struct Theme
{
    ThemeMode mode = ThemeMode::Dark;

    Color bg0, bg1;
    Color stroke, stroke2;
    Color text0, text1, text2;
    Color accent, accent2, danger, warn;

    void Apply(ThemeMode m)
    {
        mode = m;
        if (m == ThemeMode::Dark)
        {
            bg0 = Color(255, 7, 10, 18);
            bg1 = Color(255, 11, 16, 32);

            stroke  = Color(50, 255, 255, 255);
            stroke2 = Color(85, 255, 255, 255);

            text0 = Color(235, 255, 255, 255);
            text1 = Color(190, 255, 255, 255);
            text2 = Color(140, 255, 255, 255);

            accent  = Color(255, 59, 130, 246);
            accent2 = Color(255, 34, 197, 94);
            danger  = Color(255, 239, 68, 68);
            warn    = Color(255, 245, 158, 11);
        }
        else
        {
            bg0 = Color(255, 6, 6, 14);
            bg1 = Color(255, 16, 8, 32);

            stroke  = Color(55, 255, 255, 255);
            stroke2 = Color(95, 255, 255, 255);

            text0 = Color(235, 255, 255, 255);
            text1 = Color(190, 255, 255, 255);
            text2 = Color(145, 255, 255, 255);

            accent  = Color(255, 124, 58, 237);
            accent2 = Color(255, 34, 197, 94);
            danger  = Color(255, 239, 68, 68);
            warn    = Color(255, 245, 158, 11);
        }
    }
};

static Theme gTheme;

// ============================================================
// Toast system (added)
// ============================================================

struct ToastState
{
    bool active = false;
    DWORD start = 0;
    DWORD dur = 3200;
    std::wstring title;
    std::wstring msg;
    std::wstring kind; // ok/warn/err
};

static ToastState gToast;

static void toast(const std::wstring& title, const std::wstring& msg, const std::wstring& kind)
{
    gToast.active = true;
    gToast.start = GetTickCount();
    gToast.dur = (kind == L"err") ? 5200 : (kind == L"warn" ? 4200 : 3200);
    gToast.title = title;
    gToast.msg = msg;
    gToast.kind = kind;
}

// ============================================================
// Pages/UI structs
// ============================================================

enum class Page { Home, News, Settings };
enum class BtnKind { Primary, Secondary, Icon, Danger };

struct UIContext
{
    HWND hwnd = nullptr;
    int w = 0;
    int h = 0;
    bool mouseDown = false;
    POINT mousePos{0,0};
};

struct Anim
{
    float v = 0.0f;
    float target = 0.0f;
    float speed = 0.22f;
    void Tick(bool enabled)
    {
        float s = enabled ? speed : 1.0f;
        v = v + (target - v) * s;
        if (fabs(v - target) < 0.001f) v = target;
    }
};

struct Button
{
    int id = 0;
    RectF rect{};
    std::wstring text;
    BtnKind kind = BtnKind::Secondary;
    bool enabled = true;
    bool hover = false;
    bool down = false;
    Anim glow;
};

struct Toggle
{
    int id = 0;
    RectF rect{};
    std::wstring text;
    bool value = false;
    bool hover = false;
    Anim anim;
};

struct TextBox
{
    int id = 0;
    RectF rect{};
    std::wstring label;
    std::wstring value;
    std::wstring placeholder;
    bool hover = false;
    bool focused = false;
    int caret = 0;
    bool caretOn = true;
    DWORD lastBlink = 0;
};

struct Dropdown
{
    int id = 0;
    RectF rect{};
    std::wstring label;
    std::vector<std::wstring> items;
    int selected = 0;
    bool hover = false;
    bool open = false;
    int hoverIndex = -1;
};

struct ScrollArea
{
    RectF rect{};
    float scroll = 0.0f;
    float maxScroll = 0.0f;
};

// IDs
enum UI_ID
{
    ID_BTN_CLOSE = 1,
    ID_BTN_MIN,
    ID_BTN_THEME,
    ID_BTN_HOME,
    ID_BTN_NEWS,
    ID_BTN_SETTINGS,
    ID_BTN_PLAY,
    ID_BTN_DISCORD,
    ID_BTN_OPEN_GAME,
    ID_BTN_SAVE_SETTINGS,
    ID_BTN_ADD_SERVER,
    ID_BTN_DEL_SERVER,
    ID_BTN_F11,
    ID_BTN_NEXT_NEWS,
    ID_BTN_BG_BROWSE,

    ID_TX_GAMEPATH = 200,
    ID_TX_ARGS,
    ID_TX_DISCORD,
    ID_TX_BG,
    ID_TX_NICK,

    ID_TG_AUTOLAUNCH = 300,
    ID_TG_FULLSCREEN,
    ID_TG_ANIMATIONS,

    ID_DD_SERVER = 400,
    ID_DD_THEME,
};

// ============================================================
// Launcher settings
// ============================================================

struct ServerItem
{
    std::wstring name;
    std::wstring host;
    int port = 7777;
};

struct Settings
{
    std::wstring gamePath;
    std::wstring gameArgs;
    std::wstring discordUrl;
    std::wstring backgroundPath;
    std::wstring nickname;

    bool autoLaunch = false;
    bool startFullscreen = false;
    bool animations = true;

    ThemeMode theme = ThemeMode::Dark;

    std::vector<ServerItem> servers;
    int selectedServer = 0;
};

static Settings gSet;
static Page gPage = Page::Home;

static ULONG_PTR gGdiToken = 0;
static Image* gBgImage = nullptr;

static bool gFullscreen = false;
static RECT gRestoreRect{};
static DWORD gRestoreStyle = 0;
static DWORD gRestoreExStyle = 0;

static const UINT_PTR T_ANIM  = 1;
static const UINT_PTR T_NEWS  = 2;
static const UINT_PTR T_CARET = 3;

// UI lists (rebuilt per paint)
static std::vector<Button> gButtons;
static std::vector<TextBox> gTextBoxes;
static std::vector<Toggle> gToggles;
static std::vector<Dropdown> gDropdowns;

static ScrollArea gNewsScroll;

// ============================================================
// HTML-like news/banners (added)
// ============================================================

// Each item is "HTML-like" string. Our mini renderer draws it with styles and links.
static std::vector<std::wstring> gNewsHtml =
{
    L"<h1>–ó–∏–º–Ω–∏–π —Ñ–µ—Å—Ç–∏–≤–∞–ª—å 2026</h1>"
    L"<p>–°—Ç–∞—Ä—Ç—É–µ–º <b>—Å–µ–≥–æ–¥–Ω—è</b>. –ó–∞—Ö–æ–¥–∏ –≤ –∏–≥—Ä—É –∏ –∑–∞–±–∏—Ä–∞–π –Ω–∞–≥—Ä–∞–¥—ã.</p>"
    L"<p><a href=\"https://example.com/event\">–û—Ç–∫—Ä—ã—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏–≤–µ–Ω—Ç–∞</a></p>",

    L"<h2>–ü–∞—Ç—á: –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è</h2>"
    L"<p>–ú—ã —É–ª—É—á—à–∏–ª–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–∞ —Å–ª–∞–±—ã—Ö –ü–ö –∏ —É–±—Ä–∞–ª–∏ —Ñ—Ä–∏–∑—ã —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞.</p>"
    L"<p><b>–í–∞–∂–Ω–æ:</b> –æ–±–Ω–æ–≤–∏ –∫–ª–∏–µ–Ω—Ç –ø–µ—Ä–µ–¥ –≤—Ö–æ–¥–æ–º.</p>",

    L"<h2>–†–æ–∑—ã–≥—Ä—ã—à</h2>"
    L"<p>–ö–∞–∂–¥—ã–µ 24 —á–∞—Å–∞ —Ä–∞–∑—ã–≥—Ä—ã–≤–∞–µ–º –≤–Ω—É—Ç—Ä–∏–∏–≥—Ä–æ–≤—ã–µ –¥–µ–Ω—å–≥–∏.</p>"
    L"<p><a href=\"https://example.com/giveaway\">–£—Å–ª–æ–≤–∏—è —É—á–∞—Å—Ç–∏—è</a></p>",

    L"<h2>–ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ñ—Ä–∞–∫—Ü–∏–π</h2>"
    L"<p>–í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ: –Ω–æ–≤—ã–µ —Ä–∞–Ω–≥–∏, –∑–∞–¥–∞—á–∏, –∑–∞—Ä–ø–ª–∞—Ç—ã. –°–ª–µ–¥–∏ –∑–∞ –Ω–æ–≤–æ—Å—Ç—è–º–∏.</p>",

    L"<h2>–ù–æ–≤—ã–µ –∞–≤—Ç–æ –∏ —Ç—é–Ω–∏–Ω–≥</h2>"
    L"<p>–î–æ–±–∞–≤–∏–ª–∏ –Ω–æ–≤—ã–µ –º–∞—à–∏–Ω—ã –∏ —Ä–∞—Å—à–∏—Ä–∏–ª–∏ –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏—é.</p>"
    L"<p><a href=\"https://example.com/cars\">–°–ø–∏—Å–æ–∫ –∞–≤—Ç–æ</a></p>"
};

static int gNewsIndex = 0;

// Clickable link rects built each paint for News page
struct LinkHit
{
    RectF r;
    std::wstring url;
};
static std::vector<LinkHit> gLinkHits;

// ============================================================
// Settings load/save
// ============================================================

static void LoadSettings()
{
    gSet.gamePath = IniRead(L"Launcher", L"GamePath", L"");
    gSet.gameArgs = IniRead(L"Launcher", L"GameArgs", L"");
    gSet.discordUrl = IniRead(L"Launcher", L"Discord", L"https://discord.gg/");
    gSet.backgroundPath = IniRead(L"Appearance", L"Background", L"");
    gSet.nickname = IniRead(L"Account", L"Nickname", L"Player");

    gSet.autoLaunch = IniReadInt(L"Launcher", L"AutoLaunch", 0) != 0;
    gSet.startFullscreen = IniReadInt(L"Launcher", L"StartFullscreen", 0) != 0;
    gSet.animations = IniReadInt(L"Appearance", L"Animations", 1) != 0;

    int t = IniReadInt(L"Appearance", L"Theme", 0);
    gSet.theme = (t == 1) ? ThemeMode::Neon : ThemeMode::Dark;

    // servers
    int count = IniReadInt(L"Servers", L"Count", 3);
    count = ClampI(count, 0, 50);

    gSet.servers.clear();
    for (int i = 0; i < count; ++i)
    {
        wchar_t key[64];
        wsprintfW(key, L"Server%d", i);
        std::wstring line = IniRead(L"Servers", key, L"");
        if (line.empty()) continue;

        // name|host|port
        ServerItem s;
        size_t p1 = line.find(L"|");
        size_t p2 = line.rfind(L"|");
        if (p1 != std::wstring::npos && p2 != std::wstring::npos && p2 > p1)
        {
            s.name = line.substr(0, p1);
            s.host = line.substr(p1 + 1, p2 - (p1 + 1));
            s.port = _wtoi(line.substr(p2 + 1).c_str());
        }

        if (s.name.empty()) s.name = L"Server";
        if (s.host.empty()) s.host = L"127.0.0.1";
        if (s.port <= 0) s.port = 7777;

        gSet.servers.push_back(s);
    }

    if (gSet.servers.empty())
    {
        gSet.servers = {
            {L"Lobby", L"127.0.0.1", 7777},
            {L"Game-01", L"127.0.0.1", 7778},
            {L"Game-02", L"127.0.0.1", 7779},
        };
    }

    gSet.selectedServer = IniReadInt(L"Servers", L"Selected", 0);
    gSet.selectedServer = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size() - 1);

    gTheme.Apply(gSet.theme);

    // bg
    if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
    if (!gSet.backgroundPath.empty() && FileExists(gSet.backgroundPath))
    {
        gBgImage = Image::FromFile(gSet.backgroundPath.c_str());
        if (!gBgImage || gBgImage->GetLastStatus() != Ok)
        {
            delete gBgImage;
            gBgImage = nullptr;
        }
    }
}

static void SaveSettings()
{
    IniWrite(L"Launcher", L"GamePath", gSet.gamePath);
    IniWrite(L"Launcher", L"GameArgs", gSet.gameArgs);
    IniWrite(L"Launcher", L"Discord", gSet.discordUrl);
    IniWrite(L"Appearance", L"Background", gSet.backgroundPath);
    IniWrite(L"Account", L"Nickname", gSet.nickname);

    IniWriteInt(L"Launcher", L"AutoLaunch", gSet.autoLaunch ? 1 : 0);
    IniWriteInt(L"Launcher", L"StartFullscreen", gSet.startFullscreen ? 1 : 0);
    IniWriteInt(L"Appearance", L"Animations", gSet.animations ? 1 : 0);
    IniWriteInt(L"Appearance", L"Theme", (gSet.theme == ThemeMode::Neon) ? 1 : 0);

    IniWriteInt(L"Servers", L"Count", (int)gSet.servers.size());
    IniWriteInt(L"Servers", L"Selected", gSet.selectedServer);

    for (int i = 0; i < (int)gSet.servers.size(); ++i)
    {
        wchar_t key[64];
        wsprintfW(key, L"Server%d", i);
        const auto& s = gSet.servers[i];
        std::wstring line = s.name + L"|" + s.host + L"|" + std::to_wstring(s.port);
        IniWrite(L"Servers", key, line);
    }

    toast(L"Saved", L"Settings written to INI", L"ok");
}

// ============================================================
// Text rendering helper
// ============================================================

static void DrawTextW_GDI(Graphics& g, const std::wstring& txt, const RectF& r,
                         float size, int weight, Color color,
                         StringAlignment align = StringAlignmentNear,
                         StringAlignment vAlign = StringAlignmentCenter,
                         bool wrap = false)
{
    FontFamily ff(L"Segoe UI");
    FontStyle style = (weight >= 700) ? FontStyleBold : FontStyleRegular;
    Font font(&ff, size, style, UnitPixel);
    SolidBrush brush(color);

    StringFormat fmt;
    fmt.SetAlignment(align);
    fmt.SetLineAlignment(vAlign);
    fmt.SetTrimming(StringTrimmingEllipsisCharacter);
    fmt.SetFormatFlags(wrap ? 0 : StringFormatFlagsNoWrap);

    g.DrawString(txt.c_str(), -1, &font, r, &fmt, &brush);
}

// ============================================================
// Background
// ============================================================

static void DrawTopGradientBG(Graphics& g, int w, int h)
{
    if (gBgImage)
    {
        float iw = (float)gBgImage->GetWidth();
        float ih = (float)gBgImage->GetHeight();
        float scale = std::max((float)w / iw, (float)h / ih);
        float dw = iw * scale;
        float dh = ih * scale;
        float dx = ((float)w - dw) * 0.5f;
        float dy = ((float)h - dh) * 0.5f;

        g.DrawImage(gBgImage, RectF(dx, dy, dw, dh));

        SolidBrush ov(Color(160, 0, 0, 0));
        g.FillRectangle(&ov, 0.0f, 0.0f, (REAL)w, (REAL)h);
        return;
    }

    RectF rr(0.0f, 0.0f, (REAL)w, (REAL)h);
    LinearGradientBrush base(rr, gTheme.bg0, gTheme.bg1, LinearGradientModeVertical);
    g.FillRectangle(&base, rr);

    auto blob = [&](float cx, float cy, float rad, Color c){
        GraphicsPath p;
        p.AddEllipse((REAL)(cx - rad), (REAL)(cy - rad), (REAL)(rad * 2.0f), (REAL)(rad * 2.0f));
        PathGradientBrush b(&p);
        b.SetCenterColor(c);
        Color edges[1] = { Color(0, c.GetR(), c.GetG(), c.GetB()) };
        int count = 1;
        b.SetSurroundColors(edges, &count);
        g.FillEllipse(&b, (REAL)(cx - rad), (REAL)(cy - rad), (REAL)(rad * 2.0f), (REAL)(rad * 2.0f));
    };

    blob(w*0.18f, h*0.22f, 420.0f, Color(90, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()));
    blob(w*0.82f, h*0.28f, 380.0f, Color(80, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()));
    blob(w*0.50f, h*0.86f, 520.0f, Color(50, gTheme.warn.GetR(), gTheme.warn.GetG(), gTheme.warn.GetB()));

    SolidBrush vign(Color(120, 0, 0, 0));
    g.FillRectangle(&vign, 0.0f, 0.0f, (REAL)w, (REAL)h);
}

// ============================================================
// Glass panel
// ============================================================

static void DrawGlassPanel(Graphics& g, RectF r, float radius)
{
    DrawShadow(g, r, radius, 10, Color(80, 0, 0, 0));
    SolidBrush fill(Color(65, 255, 255, 255));
    FillRounded(g, r, radius, &fill);

    LinearGradientBrush grad(r, Color(45, 255, 255, 255), Color(10, 255, 255, 255), LinearGradientModeVertical);
    FillRounded(g, r, radius, &grad);

    Pen stroke(gTheme.stroke, 1.0f);
    StrokeRounded(g, r, radius, &stroke);
}

// ============================================================
// Mini HTML renderer (added)
// ============================================================

struct HtmlStyle
{
    bool bold = false;
    bool italic = false;
    bool underline = false;
    Color color = Color(255,255,255,255);
    float size = 13.0f;
    int weight = 700;
};

static std::wstring ToLower(const std::wstring& s)
{
    std::wstring out = s;
    for (auto& ch : out) ch = (wchar_t)towlower(ch);
    return out;
}

static bool StartsWith(const std::wstring& a, const std::wstring& b)
{
    if (a.size() < b.size()) return false;
    return std::equal(b.begin(), b.end(), a.begin());
}

static std::wstring Trim(const std::wstring& s)
{
    size_t i = 0;
    while (i < s.size() && iswspace(s[i])) i++;
    size_t j = s.size();
    while (j > i && iswspace(s[j-1])) j--;
    return s.substr(i, j - i);
}

static std::wstring ExtractAttr(const std::wstring& tag, const std::wstring& attr)
{
    // very small parser: find attr="..."
    std::wstring low = ToLower(tag);
    std::wstring key = ToLower(attr) + L"=\"";
    size_t p = low.find(key);
    if (p == std::wstring::npos) return L"";
    p += key.size();
    size_t e = tag.find(L"\"", p);
    if (e == std::wstring::npos) return L"";
    return tag.substr(p, e - p);
}

static Font MakeFont(const HtmlStyle& st)
{
    FontFamily ff(L"Segoe UI");
    int fs = FontStyleRegular;
    if (st.bold) fs |= FontStyleBold;
    if (st.italic) fs |= FontStyleItalic;
    if (st.underline) fs |= FontStyleUnderline;
    Font f(&ff, st.size, (FontStyle)fs, UnitPixel);
    return f;
}

static void HtmlDrawBlock(Graphics& g, const std::wstring& html, RectF area, std::vector<LinkHit>& outLinks)
{
    // Layout: simple line wrapping using MeasureString.
    // We parse tags and render text segments sequentially.
    // Tags: h1/h2/p/br/b/i/a
    // We also support closing tags.

    float x = area.X;
    float y = area.Y;
    float lineH = 18.0f;

    HtmlStyle st;
    st.color = gTheme.text0;
    st.size = 13.0f;
    st.weight = 700;

    bool inLink = false;
    std::wstring linkUrl;

    auto newLine = [&]() {
        x = area.X;
        y += lineH;
    };

    auto setHeading = [&](int level) {
        if (level == 1) { st.size = 20.0f; st.bold = true; st.italic = false; lineH = 28.0f; }
        if (level == 2) { st.size = 16.0f; st.bold = true; st.italic = false; lineH = 22.0f; }
    };

    auto setParagraph = [&]() {
        st.size = 13.0f;
        lineH = 18.0f;
        st.bold = false;
        st.italic = false;
    };

    auto drawTextRun = [&](const std::wstring& txt)
    {
        std::wstring t = txt;
        if (t.empty()) return;

        // collapse whitespace a bit
        // (not full HTML behavior, just nicer)
        // keep single spaces
        std::wstring norm;
        norm.reserve(t.size());
        bool lastSpace = false;
        for (wchar_t c : t)
        {
            if (c == L'\r' || c == L'\n' || c == L'\t') c = L' ';
            if (c == L' ')
            {
                if (!lastSpace) norm.push_back(c);
                lastSpace = true;
            }
            else
            {
                norm.push_back(c);
                lastSpace = false;
            }
        }
        t = norm;

        if (Trim(t).empty()) return;

        Font font = MakeFont(st);
        SolidBrush brush(st.color);

        // basic word wrap
        size_t i = 0;
        while (i < t.size())
        {
            // skip leading spaces on new line
            if (x == area.X)
            {
                while (i < t.size() && t[i] == L' ') i++;
            }
            if (i >= t.size()) break;

            // take a chunk, try to fit
            size_t j = i;
            size_t lastFit = i;

            RectF measureR(0,0,9999,9999);
            while (j < t.size())
            {
                j++;
                std::wstring sub = t.substr(i, j - i);
                RectF bound;
                g.MeasureString(sub.c_str(), -1, &font, measureR, &bound);

                if (x + bound.Width <= area.X + area.Width)
                {
                    lastFit = j;
                    continue;
                }
                else
                {
                    break;
                }
            }

            if (lastFit == i)
            {
                // at least one char
                lastFit = std::min(i + (size_t)1, t.size());
            }
            else
            {
                // prefer breaking at last space
                size_t k = lastFit;
                while (k > i && t[k-1] != L' ') k--;
                if (k > i + 1) lastFit = k;
            }

            std::wstring chunk = t.substr(i, lastFit - i);
            RectF bound;
            g.MeasureString(chunk.c_str(), -1, &font, measureR, &bound);

            // draw
            RectF drawR(x, y, bound.Width + 2.0f, lineH);
            g.DrawString(chunk.c_str(), -1, &font, PointF(x, y), &brush);

            if (inLink && !linkUrl.empty())
            {
                // store clickable rect
                LinkHit lh;
                lh.r = RectF(drawR.X, drawR.Y, drawR.Width, drawR.Height);
                lh.url = linkUrl;
                outLinks.push_back(lh);
            }

            x += bound.Width;

            // line overflow if we stopped due to width
            if (x >= area.X + area.Width - 2.0f)
            {
                newLine();
            }

            i = lastFit;
        }
    };

    // Parse tags
    size_t p = 0;
    while (p < html.size())
    {
        if (html[p] == L'<')
        {
            size_t end = html.find(L'>', p);
            if (end == std::wstring::npos)
            {
                drawTextRun(html.substr(p));
                break;
            }

            std::wstring tag = html.substr(p + 1, end - (p + 1));
            std::wstring tagLow = ToLower(Trim(tag));

            // closing?
            bool closing = false;
            if (!tagLow.empty() && tagLow[0] == L'/')
            {
                closing = true;
                tagLow = Trim(tagLow.substr(1));
            }

            if (!closing)
            {
                if (tagLow == L"br" || tagLow == L"br/")
                {
                    newLine();
                }
                else if (tagLow == L"p")
                {
                    setParagraph();
                    newLine();
                }
                else if (tagLow == L"h1")
                {
                    setHeading(1);
                    newLine();
                }
                else if (tagLow == L"h2")
                {
                    setHeading(2);
                    newLine();
                }
                else if (tagLow == L"b")
                {
                    st.bold = true;
                }
                else if (tagLow == L"i")
                {
                    st.italic = true;
                }
                else if (StartsWith(tagLow, L"a "))
                {
                    // link open
                    linkUrl = ExtractAttr(tag, L"href");
                    if (!linkUrl.empty())
                    {
                        inLink = true;
                        st.underline = true;
                        st.color = gTheme.accent;
                    }
                }
            }
            else
            {
                if (tagLow == L"p")
                {
                    setParagraph();
                    newLine();
                }
                else if (tagLow == L"h1" || tagLow == L"h2")
                {
                    setParagraph();
                    newLine();
                }
                else if (tagLow == L"b")
                {
                    st.bold = false;
                }
                else if (tagLow == L"i")
                {
                    st.italic = false;
                }
                else if (tagLow == L"a")
                {
                    // link close
                    inLink = false;
                    linkUrl.clear();
                    st.underline = false;
                    st.color = gTheme.text0;
                }
            }

            p = end + 1;
        }
        else
        {
            size_t next = html.find(L'<', p);
            std::wstring text = (next == std::wstring::npos) ? html.substr(p) : html.substr(p, next - p);
            drawTextRun(text);
            if (next == std::wstring::npos) break;
            p = next;
        }

        // Stop drawing if we are out of area
        if (y > area.Y + area.Height - 20.0f)
            break;
    }
}

// ============================================================
// UI build
// ============================================================

static void UI_Clear()
{
    gButtons.clear();
    gTextBoxes.clear();
    gToggles.clear();
    gDropdowns.clear();
}

static Button* UI_AddButton(int id, RectF r, const std::wstring& txt, BtnKind kind)
{
    Button b;
    b.id = id;
    b.rect = r;
    b.text = txt;
    b.kind = kind;
    b.enabled = true;
    b.glow.v = 0;
    b.glow.target = 0;
    gButtons.push_back(b);
    return &gButtons.back();
}

static TextBox* UI_AddTextBox(int id, RectF r, const std::wstring& label,
                             const std::wstring& value, const std::wstring& placeholder)
{
    TextBox t;
    t.id = id;
    t.rect = r;
    t.label = label;
    t.value = value;
    t.placeholder = placeholder;
    t.caret = (int)t.value.size();
    t.lastBlink = GetTickCount();
    gTextBoxes.push_back(t);
    return &gTextBoxes.back();
}

static Toggle* UI_AddToggle(int id, RectF r, const std::wstring& text, bool value)
{
    Toggle t;
    t.id = id;
    t.rect = r;
    t.text = text;
    t.value = value;
    t.anim.v = value ? 1.0f : 0.0f;
    t.anim.target = value ? 1.0f : 0.0f;
    gToggles.push_back(t);
    return &gToggles.back();
}

static Dropdown* UI_AddDropdown(int id, RectF r, const std::wstring& label,
                               const std::vector<std::wstring>& items, int selected)
{
    Dropdown d;
    d.id = id;
    d.rect = r;
    d.label = label;
    d.items = items;
    d.selected = items.empty() ? 0 : ClampI(selected, 0, (int)items.size() - 1);
    gDropdowns.push_back(d);
    return &gDropdowns.back();
}

static void BuildLayout(UIContext& ui)
{
    UI_Clear();

    const float W = (float)ui.w;
    const float H = (float)ui.h;

    const float titleH = 54.0f;
    const float pad = 16.0f;

    UI_AddButton(ID_BTN_MIN,   RectF(W - 92.0f, 10.0f, 36.0f, 30.0f), L"‚Äî", BtnKind::Icon);
    UI_AddButton(ID_BTN_CLOSE, RectF(W - 48.0f, 10.0f, 36.0f, 30.0f), L"‚úï", BtnKind::Icon);

    RectF side(pad, titleH + pad, 240.0f, H - (titleH + pad*2));
    RectF main(side.X + side.Width + pad, titleH + pad, W - (side.X + side.Width + pad*2), H - (titleH + pad*2));

    float y = side.Y + 16.0f;
    UI_AddButton(ID_BTN_HOME,     RectF(side.X + 14, y, side.Width - 28, 44), L"üè† Home", BtnKind::Secondary); y += 54;
    UI_AddButton(ID_BTN_NEWS,     RectF(side.X + 14, y, side.Width - 28, 44), L"üì∞ News", BtnKind::Secondary); y += 54;
    UI_AddButton(ID_BTN_SETTINGS, RectF(side.X + 14, y, side.Width - 28, 44), L"‚öô Settings", BtnKind::Secondary); y += 54;

    UI_AddButton(ID_BTN_DISCORD, RectF(side.X + 14, side.Y + side.Height - 58, side.Width - 28, 44), L"Discord", BtnKind::Secondary);
    UI_AddButton(ID_BTN_THEME,   RectF(side.X + 14, side.Y + side.Height - 112, side.Width - 28, 44), L"Theme", BtnKind::Secondary);

    if (gPage == Page::Home)
    {
        // hero card
        UI_AddTextBox(ID_TX_NICK, RectF(main.X + 20.0f, main.Y + 96.0f, 320.0f, 44.0f), L"Nickname", gSet.nickname, L"Enter nickname");

        std::vector<std::wstring> sv;
        for (auto& s : gSet.servers)
            sv.push_back(s.name + L" ‚Ä¢ " + s.host + L":" + std::to_wstring(s.port));
        UI_AddDropdown(ID_DD_SERVER, RectF(main.X + 20.0f, main.Y + 150.0f, main.Width - 280.0f, 44.0f), L"Server", sv, gSet.selectedServer);

        UI_AddButton(ID_BTN_PLAY, RectF(main.X + main.Width - 240.0f, main.Y + 150.0f, 220.0f, 56.0f), L"PLAY", BtnKind::Primary);

        RectF q(main.X, main.Y + 220.0f + 16.0f, main.Width, 220.0f);
        UI_AddButton(ID_BTN_OPEN_GAME, RectF(q.X + 20.0f, q.Y + 150.0f, 200.0f, 44.0f), L"Choose Game EXE", BtnKind::Secondary);
        UI_AddButton(ID_BTN_F11,       RectF(q.X + 230.0f, q.Y + 150.0f, 200.0f, 44.0f), L"Fullscreen (F11)", BtnKind::Secondary);
        UI_AddButton(ID_BTN_NEXT_NEWS, RectF(q.X + 440.0f, q.Y + 150.0f, 200.0f, 44.0f), L"Next News", BtnKind::Secondary);

        UI_AddTextBox(ID_TX_GAMEPATH, RectF(q.X + 20.0f, q.Y + 44.0f, q.Width - 40.0f, 44.0f), L"Game Path", gSet.gamePath, L"Select game exe path");
        UI_AddTextBox(ID_TX_ARGS,     RectF(q.X + 20.0f, q.Y + 96.0f, q.Width - 40.0f, 44.0f), L"Args", gSet.gameArgs, L"Optional args");
    }
    else if (gPage == Page::News)
    {
        UI_AddButton(ID_BTN_NEXT_NEWS, RectF(main.X + main.Width - 220.0f, main.Y + 14.0f, 200.0f, 40.0f), L"Next News", BtnKind::Secondary);
        gNewsScroll.rect = RectF(main.X + 14, main.Y + 70, main.Width - 28, main.Height - 84);
    }
    else if (gPage == Page::Settings)
    {
        float colW = (main.Width - 16.0f) * 0.55f;
        RectF left(main.X, main.Y, colW, main.Height);
        RectF right(main.X + colW + 16.0f, main.Y, main.Width - colW - 16.0f, main.Height);

        UI_AddTextBox(ID_TX_GAMEPATH, RectF(left.X + 16, left.Y + 62, left.Width - 32, 44), L"Game EXE path", gSet.gamePath, L"C:\\Games\\GTA5\\GTA5.exe");
        UI_AddButton(ID_BTN_OPEN_GAME, RectF(left.X + 16, left.Y + 110, 200, 40), L"Browse...", BtnKind::Secondary);

        UI_AddTextBox(ID_TX_ARGS, RectF(left.X + 16, left.Y + 162, left.Width - 32, 44), L"Launch args", gSet.gameArgs, L"-arg1 -arg2");
        UI_AddTextBox(ID_TX_DISCORD, RectF(left.X + 16, left.Y + 214, left.Width - 32, 44), L"Discord URL", gSet.discordUrl, L"https://discord.gg/xxxx");
        UI_AddTextBox(ID_TX_BG, RectF(left.X + 16, left.Y + 266, left.Width - 32, 44), L"Background image", gSet.backgroundPath, L"(optional) path to JPG/PNG");
        UI_AddButton(ID_BTN_BG_BROWSE, RectF(left.X + 16, left.Y + 314, 200, 40), L"Browse BG...", BtnKind::Secondary);

        UI_AddToggle(ID_TG_AUTOLAUNCH, RectF(left.X + 16, left.Y + 372, left.Width - 32, 32), L"Auto-launch on open", gSet.autoLaunch);
        UI_AddToggle(ID_TG_FULLSCREEN, RectF(left.X + 16, left.Y + 410, left.Width - 32, 32), L"Start fullscreen (F11)", gSet.startFullscreen);
        UI_AddToggle(ID_TG_ANIMATIONS, RectF(left.X + 16, left.Y + 448, left.Width - 32, 32), L"UI animations", gSet.animations);

        UI_AddButton(ID_BTN_ADD_SERVER, RectF(right.X + 16, right.Y + 62, 160, 40), L"+ Add server", BtnKind::Secondary);
        UI_AddButton(ID_BTN_DEL_SERVER, RectF(right.X + 184, right.Y + 62, 160, 40), L"‚àí Remove", BtnKind::Secondary);

        std::vector<std::wstring> th = { L"Dark", L"Neon" };
        UI_AddDropdown(ID_DD_THEME, RectF(right.X + 16, right.Y + 114, right.Width - 32, 44), L"Theme", th, (gSet.theme == ThemeMode::Neon) ? 1 : 0);

        std::vector<std::wstring> sv;
        for (auto& s0 : gSet.servers)
            sv.push_back(s0.name + L" ‚Ä¢ " + s0.host + L":" + std::to_wstring(s0.port));
        UI_AddDropdown(ID_DD_SERVER, RectF(right.X + 16, right.Y + 170, right.Width - 32, 44), L"Default server", sv, gSet.selectedServer);

        UI_AddButton(ID_BTN_SAVE_SETTINGS, RectF(right.X + right.Width - 200 - 16, right.Y + right.Height - 52, 200, 44), L"Save Settings", BtnKind::Primary);
    }
}

// ============================================================
// Hit testing
// ============================================================

static bool PtInRectF(const POINT& p, const RectF& r)
{
    return p.x >= r.X && p.x <= (r.X + r.Width) && p.y >= r.Y && p.y <= (r.Y + r.Height);
}

static Button* HitButton(const POINT& p)
{
    for (auto& b : gButtons) if (PtInRectF(p, b.rect)) return &b;
    return nullptr;
}
static TextBox* HitTextBox(const POINT& p)
{
    for (auto& t : gTextBoxes) if (PtInRectF(p, t.rect)) return &t;
    return nullptr;
}
static Toggle* HitToggle(const POINT& p)
{
    for (auto& t : gToggles) if (PtInRectF(p, t.rect)) return &t;
    return nullptr;
}
static Dropdown* HitDropdown(const POINT& p)
{
    for (auto& d : gDropdowns) if (PtInRectF(p, d.rect)) return &d;
    return nullptr;
}

static void ClearTextFocus()
{
    for (auto& t : gTextBoxes) t.focused = false;
}

static void CloseAllDropdowns()
{
    for (auto& d : gDropdowns) { d.open = false; d.hoverIndex = -1; }
}

static bool DropdownHitOpenItem(Dropdown& d, const POINT& p, int& outIndex)
{
    if (!d.open) return false;
    float itemH = 36.0f;
    float listH = std::min(6.0f, (float)d.items.size()) * itemH + 12.0f;
    RectF list(d.rect.X, d.rect.Y + d.rect.Height + 8.0f, d.rect.Width, listH);
    if (!PtInRectF(p, list)) return false;

    RectF inner(list.X + 8, list.Y + 8, list.Width - 16, list.Height - 16);
    float relY = (float)p.y - inner.Y;
    int idx = (int)(relY / itemH);
    idx = ClampI(idx, 0, (int)std::min(6.0f, (float)d.items.size()) - 1);
    outIndex = idx;
    return true;
}

// ============================================================
// Update hover
// ============================================================

static void UpdateHover(UIContext& ui)
{
    for (auto& b : gButtons)
    {
        b.hover = PtInRectF(ui.mousePos, b.rect);
        if (!ui.mouseDown) b.down = false;
    }
    for (auto& t : gTextBoxes) t.hover = PtInRectF(ui.mousePos, t.rect);
    for (auto& t : gToggles) t.hover = PtInRectF(ui.mousePos, t.rect);

    for (auto& d : gDropdowns)
    {
        d.hover = PtInRectF(ui.mousePos, d.rect);
        if (d.open)
        {
            int idx = -1;
            if (DropdownHitOpenItem(d, ui.mousePos, idx)) d.hoverIndex = idx;
            else d.hoverIndex = -1;
        }
    }
}

// ============================================================
// Draw UI elements
// ============================================================

static void DrawTitleBar(Graphics& g, UIContext& ui)
{
    RectF r(0.0f, 0.0f, (REAL)ui.w, 54.0f);
    SolidBrush bg(Color(120, 0, 0, 0));
    g.FillRectangle(&bg, r);

    Pen line(Color(50, 255, 255, 255), 1.0f);
    g.DrawLine(&line, 0.0f, 54.0f, (REAL)ui.w, 54.0f);

    DrawTextW_GDI(g, L"MAJESTIC ROLEPLAY", RectF(16, 10, 520, 20), 18, 900, gTheme.text0);
    DrawTextW_GDI(g, L"ONLINE ‚Ä¢ Launcher v2 (Demo) ‚Ä¢ HTML News", RectF(16, 28, 520, 18), 12, 400, gTheme.text2);

    DrawTextW_GDI(g, L"F11 Fullscreen", RectF((REAL)ui.w - 260, 18, 160, 20), 12, 600, gTheme.text2, StringAlignmentFar);
}

static void DrawButton(Graphics& g, Button& b)
{
    b.glow.target = b.hover ? 1.0f : 0.0f;
    b.glow.Tick(gSet.animations);

    bool pressed = b.down && b.hover;

    RectF r = b.rect;
    float radius = (b.kind == BtnKind::Icon) ? 12.0f : 14.0f;

    Color stroke = gTheme.stroke;
    Color fillA = Color(40,255,255,255);
    Color fillB = Color(25,255,255,255);
    Color text = gTheme.text0;

    if (!b.enabled)
    {
        fillA = Color(20,255,255,255);
        fillB = Color(18,255,255,255);
        text = gTheme.text2;
        stroke = Color(35,255,255,255);
    }

    if (b.kind == BtnKind::Danger)
    {
        fillA = Color(40, gTheme.danger.GetR(), gTheme.danger.GetG(), gTheme.danger.GetB());
        fillB = Color(24, gTheme.danger.GetR(), gTheme.danger.GetG(), gTheme.danger.GetB());
        stroke = Color(110, gTheme.danger.GetR(), gTheme.danger.GetG(), gTheme.danger.GetB());
    }

    if (pressed)
    {
        fillA = Color((BYTE)ClampI(fillA.GetA()+40,0,255), fillA.GetR(), fillA.GetG(), fillA.GetB());
        fillB = Color((BYTE)ClampI(fillB.GetA()+30,0,255), fillB.GetR(), fillB.GetG(), fillB.GetB());
    }
    if (b.hover && b.enabled && b.kind != BtnKind::Primary)
    {
        fillA = Color((BYTE)ClampI(fillA.GetA()+30,0,255), fillA.GetR(), fillA.GetG(), fillA.GetB());
        fillB = Color((BYTE)ClampI(fillB.GetA()+24,0,255), fillB.GetR(), fillB.GetG(), fillB.GetB());
        stroke = gTheme.stroke2;
    }

    DrawShadow(g, r, radius, 8, Color(70,0,0,0));

    if (b.kind == BtnKind::Primary)
    {
        LinearGradientBrush grad(r,
            Color(255, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()),
            Color(255, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()),
            LinearGradientModeHorizontal
        );
        FillRounded(g, r, radius, &grad);

        Pen st(Color(90,255,255,255), 1.0f);
        StrokeRounded(g, r, radius, &st);

        if (b.hover)
        {
            LinearGradientBrush shine(r,
                Color((BYTE)(45 + b.glow.v*60), 255,255,255),
                Color(0,255,255,255),
                LinearGradientModeVertical
            );
            FillRounded(g, r, radius, &shine);
        }
    }
    else
    {
        SolidBrush f1(fillA);
        FillRounded(g, r, radius, &f1);

        LinearGradientBrush grad(r, fillA, fillB, LinearGradientModeVertical);
        FillRounded(g, r, radius, &grad);

        Pen st(stroke, 1.0f);
        StrokeRounded(g, r, radius, &st);
    }

    if (b.glow.v > 0.01f && b.enabled && b.kind != BtnKind::Danger)
    {
        Color glow((BYTE)(b.glow.v * 120),
                   gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB());
        Pen p(glow, 2.0f);
        StrokeRounded(g, r, radius, &p);
    }

    float fontSize = (b.kind == BtnKind::Icon) ? 16.0f : (b.kind == BtnKind::Primary ? 16.0f : 14.0f);
    int weight = (b.kind == BtnKind::Primary) ? 1000 : 800;
    DrawTextW_GDI(g, b.text, r, fontSize, weight, text, StringAlignmentCenter);
}

static void DrawTextBox(Graphics& g, TextBox& t)
{
    RectF r = t.rect;

    DrawTextW_GDI(g, t.label, RectF(r.X, r.Y - 18, r.Width, 16), 12, 700, gTheme.text2);

    bool active = t.focused;
    Color stroke = active ? Color(160, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()) : gTheme.stroke;
    Color fill = active ? Color(60, 255,255,255) : Color(38,255,255,255);

    DrawShadow(g, r, 14.0f, 7, Color(60,0,0,0));
    SolidBrush f(fill);
    FillRounded(g, r, 14.0f, &f);

    LinearGradientBrush grad(r, Color(20,255,255,255), Color(0,255,255,255), LinearGradientModeVertical);
    FillRounded(g, r, 14.0f, &grad);

    Pen p(stroke, 1.2f);
    StrokeRounded(g, r, 14.0f, &p);

    if (t.value.empty())
        DrawTextW_GDI(g, t.placeholder, RectF(r.X+12, r.Y, r.Width-24, r.Height), 14, 500, gTheme.text2);
    else
        DrawTextW_GDI(g, t.value, RectF(r.X+12, r.Y, r.Width-24, r.Height), 14, 700, gTheme.text0);

    if (t.focused)
    {
        DWORD now = GetTickCount();
        if (now - t.lastBlink > 520)
        {
            t.caretOn = !t.caretOn;
            t.lastBlink = now;
        }
        if (t.caretOn)
        {
            int count = (int)t.value.size();
            int caret = ClampI(t.caret, 0, count);
            float x = r.X + 12.0f + (float)caret * 7.0f;
            x = std::min(x, r.X + r.Width - 12.0f);

            Pen caretPen(Color(210, 255,255,255), 1.6f);
            g.DrawLine(&caretPen, x, r.Y + 10.0f, x, r.Y + r.Height - 10.0f);
        }
    }
}

static void DrawToggle(Graphics& g, Toggle& t)
{
    t.anim.target = t.value ? 1.0f : 0.0f;
    t.anim.Tick(gSet.animations);

    RectF r = t.rect;

    float swW = 52.0f;
    float swH = 26.0f;
    float swX = r.X;
    float swY = r.Y + (r.Height - swH) * 0.5f;
    RectF sw(swX, swY, swW, swH);

    RectF tr(swX + swW + 12.0f, r.Y, r.Width - (swW + 12.0f), r.Height);

    Color onC = gTheme.accent2;
    Color offC = Color(80, 255,255,255);

    Color fill(
        (BYTE)(60 + t.anim.v * 40),
        (BYTE)((offC.GetR() * (1.0f - t.anim.v)) + (onC.GetR() * t.anim.v)),
        (BYTE)((offC.GetG() * (1.0f - t.anim.v)) + (onC.GetG() * t.anim.v)),
        (BYTE)((offC.GetB() * (1.0f - t.anim.v)) + (onC.GetB() * t.anim.v))
    );

    DrawShadow(g, sw, 999.0f, 6, Color(50,0,0,0));
    SolidBrush f(fill);
    FillRounded(g, sw, 999.0f, &f);

    Pen st(t.hover ? gTheme.stroke2 : gTheme.stroke, 1.0f);
    StrokeRounded(g, sw, 999.0f, &st);

    float knobR = 20.0f;
    float knobX = sw.X + 4.0f + t.anim.v * (sw.Width - 8.0f - knobR);
    RectF knob(knobX, sw.Y + 3.0f, knobR, knobR);

    SolidBrush kb(Color(220, 255,255,255));
    FillRounded(g, knob, 999.0f, &kb);

    DrawTextW_GDI(g, t.text, tr, 14, 700, gTheme.text1);
}

static void DrawDropdown(Graphics& g, Dropdown& d)
{
    RectF r = d.rect;

    DrawTextW_GDI(g, d.label, RectF(r.X, r.Y - 18, r.Width, 16), 12, 700, gTheme.text2);

    DrawShadow(g, r, 14.0f, 7, Color(60,0,0,0));
    SolidBrush f(Color(38,255,255,255));
    FillRounded(g, r, 14.0f, &f);

    LinearGradientBrush grad(r, Color(20,255,255,255), Color(0,255,255,255), LinearGradientModeVertical);
    FillRounded(g, r, 14.0f, &grad);

    Pen st(d.hover ? gTheme.stroke2 : gTheme.stroke, 1.2f);
    StrokeRounded(g, r, 14.0f, &st);

    std::wstring txt = d.items.empty() ? L"(empty)" : d.items[ClampI(d.selected,0,(int)d.items.size()-1)];
    DrawTextW_GDI(g, txt, RectF(r.X+12, r.Y, r.Width-44, r.Height), 14, 700, gTheme.text0);

    DrawTextW_GDI(g, d.open ? L"‚ñ≤" : L"‚ñº", RectF(r.X + r.Width - 34, r.Y, 24, r.Height), 12, 900, gTheme.text2, StringAlignmentCenter);

    if (d.open && !d.items.empty())
    {
        float itemH = 36.0f;
        float listH = std::min(6.0f, (float)d.items.size()) * itemH + 12.0f;
        RectF list(r.X, r.Y + r.Height + 8.0f, r.Width, listH);

        DrawGlassPanel(g, list, 16.0f);

        int maxItems = (int)std::min(6.0f, (float)d.items.size());
        for (int i=0;i<maxItems;i++)
        {
            RectF ir(list.X+8, list.Y+8 + i*itemH, list.Width-16, itemH-4);
            bool hov = (i == d.hoverIndex);
            bool sel = (i == d.selected);

            if (hov || sel)
            {
                SolidBrush hi(sel ? Color(50, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB())
                                  : Color(30,255,255,255));
                FillRounded(g, ir, 12.0f, &hi);
            }

            DrawTextW_GDI(g, d.items[i], RectF(ir.X+10, ir.Y, ir.Width-20, ir.Height),
                13, sel?900:700, sel?gTheme.text0:gTheme.text1, StringAlignmentNear, StringAlignmentCenter);
        }
    }
}

// ============================================================
// Pages drawing
// ============================================================

static void DrawSidebar(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    DrawGlassPanel(g, side, 20.0f);

    RectF chip(side.X + 14, side.Y + 14, side.Width - 28, 64);
    DrawShadow(g, chip, 18.0f, 6, Color(65,0,0,0));
    SolidBrush c1(Color(25,255,255,255));
    FillRounded(g, chip, 18.0f, &c1);

    RectF ava(chip.X + 12, chip.Y + 12, 40, 40);
    SolidBrush avaB(Color(50, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()));
    FillRounded(g, ava, 16.0f, &avaB);
    DrawTextW_GDI(g, L"M", ava, 18, 1000, Color(240,255,255,255), StringAlignmentCenter);

    DrawTextW_GDI(g, gSet.nickname.empty()?L"Player":gSet.nickname, RectF(ava.X+ava.Width+10, chip.Y+16, chip.Width-ava.Width-22, 20),
        14, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Status: ONLINE", RectF(ava.X+ava.Width+10, chip.Y+36, chip.Width-ava.Width-22, 16),
        12, 700, gTheme.accent2);

    std::wstring pageName = (gPage==Page::Home?L"Home":gPage==Page::News?L"News":L"Settings");
    DrawTextW_GDI(g, L"Page", RectF(side.X+14, side.Y+92, side.Width-28, 16), 12, 700, gTheme.text2);
    DrawTextW_GDI(g, pageName, RectF(side.X+14, side.Y+108, side.Width-28, 22), 16, 1000, gTheme.text0);
}

static void DrawHomePage(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    RectF main(side.X + side.Width + 16.0f, side.Y, (float)ui.w - (side.X + side.Width + 32.0f), side.Height);

    RectF hero(main.X, main.Y, main.Width, 220.0f);
    DrawGlassPanel(g, hero, 22.0f);

    // blobs
    {
        GraphicsPath p; p.AddEllipse((REAL)(hero.X-120), (REAL)(hero.Y-140), (REAL)520, (REAL)520);
        PathGradientBrush b(&p);
        b.SetCenterColor(Color(90, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()));
        Color edges[1] = { Color(0, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()) };
        int c = 1; b.SetSurroundColors(edges, &c);
        g.FillEllipse(&b, (REAL)(hero.X-120), (REAL)(hero.Y-140), (REAL)520, (REAL)520);

        GraphicsPath p2; p2.AddEllipse((REAL)(hero.X+hero.Width-380), (REAL)(hero.Y-120), (REAL)520, (REAL)520);
        PathGradientBrush b2(&p2);
        b2.SetCenterColor(Color(80, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()));
        Color edges2[1] = { Color(0, gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB()) };
        int c2 = 1; b2.SetSurroundColors(edges2, &c2);
        g.FillEllipse(&b2, (REAL)(hero.X+hero.Width-380), (REAL)(hero.Y-120), (REAL)520, (REAL)520);
    }

    DrawTextW_GDI(g, L"MAJESTIC ROLEPLAY", RectF(hero.X+20, hero.Y+18, hero.Width-40, 32), 22, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"GTA RP launcher ‚Ä¢ premium UI (Win32/GDI+) ‚Ä¢ FIXED", RectF(hero.X+20, hero.Y+48, hero.Width-40, 18), 13, 700, gTheme.text2);

    std::wstring preview = gNewsHtml.empty()?L"No news":L"(—Å–º. –≤–∫–ª–∞–¥–∫—É News ‚Äî HTML)";
    DrawTextW_GDI(g, L"Latest news (HTML)", RectF(hero.X+20, hero.Y+132, hero.Width-300, 16), 12, 700, gTheme.text2);
    DrawTextW_GDI(g, preview, RectF(hero.X+20, hero.Y+148, hero.Width-300, 56), 14, 800, gTheme.text0, StringAlignmentNear, StringAlignmentNear, true);

    RectF q(main.X, main.Y + hero.Height + 16.0f, main.Width, 220.0f);
    DrawGlassPanel(g, q, 22.0f);

    DrawTextW_GDI(g, L"Quick actions", RectF(q.X+20, q.Y+16, q.Width-40, 22), 16, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Set game path, tune args, then press PLAY. Press F11 for fullscreen.", RectF(q.X+20, q.Y+40, q.Width-40, 18),
        13, 700, gTheme.text2);

    DrawTextW_GDI(g, L"Tip: News page supports <a href> links.", RectF(q.X+20, q.Y+q.Height-28, q.Width-40, 18),
        12, 700, gTheme.text2);
}

static void DrawNewsPage(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    RectF main(side.X + side.Width + 16.0f, side.Y, (float)ui.w - (side.X + side.Width + 32.0f), side.Height);

    DrawGlassPanel(g, main, 22.0f);
    DrawTextW_GDI(g, L"News (HTML)", RectF(main.X+16, main.Y+14, main.Width-32, 24), 18, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Mouse wheel scroll ‚Ä¢ Click links ‚Ä¢ Auto-rotate every 6s", RectF(main.X+16, main.Y+40, main.Width-32, 16),
        12, 700, gTheme.text2);

    RectF area = gNewsScroll.rect;

    float cardH = 170.0f;
    float gap = 14.0f;
    float contentH = 12.0f + (float)gNewsHtml.size() * (cardH + gap);
    gNewsScroll.maxScroll = std::max(0.0f, contentH - area.Height);
    gNewsScroll.scroll = ClampF(gNewsScroll.scroll, 0.0f, gNewsScroll.maxScroll);

    // Clear link hits each frame
    gLinkHits.clear();

    Region oldClip;
    g.GetClip(&oldClip);
    g.SetClip(area);

    float y = area.Y + 12.0f - gNewsScroll.scroll;
    for (int i=0;i<(int)gNewsHtml.size();++i)
    {
        RectF card(area.X + 12.0f, y, area.Width - 24.0f, cardH);
        bool active = (i == gNewsIndex);

        DrawShadow(g, card, 18.0f, 6, Color(55,0,0,0));
        SolidBrush fill(active ? Color(55, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB())
                              : Color(28,255,255,255));
        FillRounded(g, card, 18.0f, &fill);

        Pen st(active ? Color(130, gTheme.accent.GetR(), gTheme.accent.GetG(), gTheme.accent.GetB()) : gTheme.stroke, 1.0f);
        StrokeRounded(g, card, 18.0f, &st);

        // draw HTML content
        RectF htmlArea(card.X + 14, card.Y + 12, card.Width - 28, card.Height - 24);
        HtmlDrawBlock(g, gNewsHtml[i], htmlArea, gLinkHits);

        y += (cardH + gap);
    }

    g.SetClip(&oldClip);

    // scrollbar
    if (gNewsScroll.maxScroll > 0.0f)
    {
        float barW = 10.0f;
        RectF track(area.X + area.Width - barW - 6.0f, area.Y + 8.0f, barW, area.Height - 16.0f);
        SolidBrush tr(Color(25,255,255,255));
        FillRounded(g, track, 999.0f, &tr);

        float ratio = area.Height / contentH;
        float thumbH = std::max(36.0f, track.Height * ratio);
        float t = gNewsScroll.scroll / gNewsScroll.maxScroll;
        float thumbY = track.Y + t * (track.Height - thumbH);
        RectF thumb(track.X, thumbY, track.Width, thumbH);

        SolidBrush th(Color(90,255,255,255));
        FillRounded(g, thumb, 999.0f, &th);
    }
}

static void DrawSettingsPage(Graphics& g, UIContext& ui)
{
    RectF side(16.0f, 54.0f + 16.0f, 240.0f, (float)ui.h - (54.0f + 32.0f));
    RectF main(side.X + side.Width + 16.0f, side.Y, (float)ui.w - (side.X + side.Width + 32.0f), side.Height);

    DrawGlassPanel(g, main, 22.0f);

    DrawTextW_GDI(g, L"Settings", RectF(main.X+16, main.Y+14, main.Width-32, 24), 18, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Stored in INI file. Demo only.", RectF(main.X+16, main.Y+40, main.Width-32, 16), 12, 700, gTheme.text2);

    float colW = (main.Width - 16.0f) * 0.55f;
    RectF left(main.X+8, main.Y+58, colW, main.Height-66);
    RectF right(main.X+8+colW+8, main.Y+58, main.Width - colW - 16, main.Height-66);

    SolidBrush colBg(Color(18,255,255,255));
    FillRounded(g, left, 18.0f, &colBg);
    FillRounded(g, right, 18.0f, &colBg);

    Pen st(gTheme.stroke, 1.0f);
    StrokeRounded(g, left, 18.0f, &st);
    StrokeRounded(g, right, 18.0f, &st);

    DrawTextW_GDI(g, L"Launcher", RectF(left.X+16, left.Y+10, left.Width-32, 18), 14, 1000, gTheme.text0);
    DrawTextW_GDI(g, L"Servers & Appearance", RectF(right.X+16, right.Y+10, right.Width-32, 18), 14, 1000, gTheme.text0);

    // server preview
    float y = right.Y + 390.0f;
    DrawTextW_GDI(g, L"Server list (preview)", RectF(right.X+16, y, right.Width-32, 18), 12, 900, gTheme.text2);
    y += 20;

    int show = std::min(6, (int)gSet.servers.size());
    for (int i=0;i<show;i++)
    {
        const auto& s = gSet.servers[i];
        RectF rr(right.X+16, y, right.Width-32, 36);
        SolidBrush f(Color(i==gSet.selectedServer?40:18, 255,255,255));
        FillRounded(g, rr, 14.0f, &f);
        Pen p(i==gSet.selectedServer?Color(120,gTheme.accent.GetR(),gTheme.accent.GetG(),gTheme.accent.GetB()):gTheme.stroke, 1.0f);
        StrokeRounded(g, rr, 14.0f, &p);

        DrawTextW_GDI(g, s.name, RectF(rr.X+12, rr.Y, rr.Width-24, rr.Height), 13, 900, gTheme.text0);
        DrawTextW_GDI(g, s.host + L":" + std::to_wstring(s.port), RectF(rr.X+12, rr.Y+16, rr.Width-24, rr.Height), 12, 700, gTheme.text2, StringAlignmentNear, StringAlignmentNear);
        y += 44;
    }
}

// ============================================================
// Toast drawing
// ============================================================

static void DrawToast(Graphics& g, UIContext& ui)
{
    if (!gToast.active) return;

    DWORD now = GetTickCount();
    DWORD dt = now - gToast.start;
    if (dt > gToast.dur)
    {
        gToast.active = false;
        return;
    }

    float t = (float)dt / (float)gToast.dur;
    float alphaIn = ClampF((float)dt / 220.0f, 0.0f, 1.0f);
    float alphaOut = ClampF((float)(gToast.dur - dt) / 260.0f, 0.0f, 1.0f);
    float a = std::min(alphaIn, alphaOut);

    float W = (float)ui.w;
    float H = (float)ui.h;

    float boxW = std::min(640.0f, W - 60.0f);
    float boxH = 64.0f;
    RectF r((W - boxW) * 0.5f, H - boxH - 22.0f, boxW, boxH);

    Color base = Color((BYTE)(120 * a), 0,0,0);
    SolidBrush bg(base);
    DrawShadow(g, r, 18.0f, 8, Color((BYTE)(90 * a), 0,0,0));
    FillRounded(g, r, 18.0f, &bg);

    Color border = Color((BYTE)(60 * a), 255,255,255);
    if (gToast.kind == L"ok")   border = Color((BYTE)(90 * a), gTheme.accent2.GetR(), gTheme.accent2.GetG(), gTheme.accent2.GetB());
    if (gToast.kind == L"warn") border = Color((BYTE)(90 * a), gTheme.warn.GetR(), gTheme.warn.GetG(), gTheme.warn.GetB());
    if (gToast.kind == L"err")  border = Color((BYTE)(90 * a), gTheme.danger.GetR(), gTheme.danger.GetG(), gTheme.danger.GetB());

    Pen p(border, 1.2f);
    StrokeRounded(g, r, 18.0f, &p);

    DrawTextW_GDI(g, gToast.title, RectF(r.X+16, r.Y+10, r.Width-32, 20), 14, 1000, Color((BYTE)(235*a),255,255,255));
    DrawTextW_GDI(g, gToast.msg, RectF(r.X+16, r.Y+30, r.Width-32, 22), 12, 700, Color((BYTE)(200*a),255,255,255), StringAlignmentNear, StringAlignmentCenter, true);
}

// ============================================================
// Apply UI data back to settings (simplified)
// ============================================================

static void ApplyTextBoxToSettings()
{
    for (auto& t : gTextBoxes)
    {
        if (t.id == ID_TX_GAMEPATH) gSet.gamePath = t.value;
        if (t.id == ID_TX_ARGS) gSet.gameArgs = t.value;
        if (t.id == ID_TX_DISCORD) gSet.discordUrl = t.value;
        if (t.id == ID_TX_BG) gSet.backgroundPath = t.value;
        if (t.id == ID_TX_NICK) gSet.nickname = t.value;
    }
}

static void ApplyToggleToSettings()
{
    for (auto& t : gToggles)
    {
        if (t.id == ID_TG_AUTOLAUNCH) gSet.autoLaunch = t.value;
        if (t.id == ID_TG_FULLSCREEN) gSet.startFullscreen = t.value;
        if (t.id == ID_TG_ANIMATIONS) gSet.animations = t.value;
    }
}

static void ApplyDropdownToSettings()
{
    for (auto& d : gDropdowns)
    {
        if (d.id == ID_DD_SERVER) gSet.selectedServer = d.selected;
        if (d.id == ID_DD_THEME)
        {
            gSet.theme = (d.selected == 1) ? ThemeMode::Neon : ThemeMode::Dark;
            gTheme.Apply(gSet.theme);
        }
    }
}

// ============================================================
// Fullscreen
// ============================================================

static void ToggleFullscreen(HWND hwnd)
{
    if (!gFullscreen)
    {
        gRestoreStyle = GetWindowLongW(hwnd, GWL_STYLE);
        gRestoreExStyle = GetWindowLongW(hwnd, GWL_EXSTYLE);
        GetWindowRect(hwnd, &gRestoreRect);

        SetWindowLongW(hwnd, GWL_STYLE, WS_POPUP);
        SetWindowLongW(hwnd, GWL_EXSTYLE, gRestoreExStyle);

        int sw = GetSystemMetrics(SM_CXSCREEN);
        int sh = GetSystemMetrics(SM_CYSCREEN);
        SetWindowPos(hwnd, HWND_TOP, 0, 0, sw, sh, SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        gFullscreen = true;
    }
    else
    {
        SetWindowLongW(hwnd, GWL_STYLE, gRestoreStyle);
        SetWindowLongW(hwnd, GWL_EXSTYLE, gRestoreExStyle);

        SetWindowPos(hwnd, HWND_TOP,
            gRestoreRect.left, gRestoreRect.top,
            gRestoreRect.right - gRestoreRect.left,
            gRestoreRect.bottom - gRestoreRect.top,
            SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        gFullscreen = false;
    }
}

// ============================================================
// Actions
// ============================================================

static void HandleButtonClick(HWND hwnd, int id)
{
    if (id == ID_BTN_CLOSE) { PostMessageW(hwnd, WM_CLOSE, 0, 0); return; }
    if (id == ID_BTN_MIN)   { ShowWindow(hwnd, SW_MINIMIZE); return; }

    if (id == ID_BTN_HOME)     { gPage = Page::Home; InvalidateRect(hwnd, NULL, FALSE); return; }
    if (id == ID_BTN_NEWS)     { gPage = Page::News; InvalidateRect(hwnd, NULL, FALSE); return; }
    if (id == ID_BTN_SETTINGS) { gPage = Page::Settings; InvalidateRect(hwnd, NULL, FALSE); return; }

    if (id == ID_BTN_THEME)
    {
        gSet.theme = (gSet.theme == ThemeMode::Dark) ? ThemeMode::Neon : ThemeMode::Dark;
        gTheme.Apply(gSet.theme);
        IniWriteInt(L"Appearance", L"Theme", (gSet.theme==ThemeMode::Neon)?1:0);
        toast(L"Theme", (gSet.theme==ThemeMode::Neon)?L"Neon":L"Dark", L"ok");
        InvalidateRect(hwnd, NULL, FALSE);
        return;
    }

    if (id == ID_BTN_DISCORD)
    {
        ApplyTextBoxToSettings();
        if (!gSet.discordUrl.empty()) ShellOpenUrl(gSet.discordUrl);
        else toast(L"Discord", L"URL is empty", L"warn");
        return;
    }

    if (id == ID_BTN_NEXT_NEWS)
    {
        gNewsIndex = (gNewsIndex + 1) % (int)gNewsHtml.size();
        toast(L"News", L"Switched to next news card", L"ok");
        InvalidateRect(hwnd, NULL, FALSE);
        return;
    }

    if (id == ID_BTN_F11)
    {
        ToggleFullscreen(hwnd);
        return;
    }

    if (id == ID_BTN_OPEN_GAME)
    {
        std::wstring p = OpenFileDialog(hwnd,
            L"Executable (*.exe)\0*.exe\0All files (*.*)\0*.*\0\0",
            L"Select game executable");
        if (!p.empty())
        {
            gSet.gamePath = p;
            for (auto& tb : gTextBoxes)
                if (tb.id == ID_TX_GAMEPATH) { tb.value = p; tb.caret = (int)tb.value.size(); }
            toast(L"Selected", p, L"ok");
            InvalidateRect(hwnd, NULL, FALSE);
        }
        return;
    }

    if (id == ID_BTN_BG_BROWSE)
    {
        std::wstring p = OpenFileDialog(hwnd,
            L"Images (*.png;*.jpg;*.jpeg)\0*.png;*.jpg;*.jpeg\0All files (*.*)\0*.*\0\0",
            L"Select background image");
        if (!p.empty())
        {
            gSet.backgroundPath = p;
            for (auto& tb : gTextBoxes)
                if (tb.id == ID_TX_BG) { tb.value = p; tb.caret = (int)tb.value.size(); }

            if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
            gBgImage = Image::FromFile(p.c_str());
            if (!gBgImage || gBgImage->GetLastStatus() != Ok)
            {
                delete gBgImage;
                gBgImage = nullptr;
                toast(L"Background", L"Failed to load image", L"err");
            }
            else toast(L"Background", L"Loaded", L"ok");

            InvalidateRect(hwnd, NULL, FALSE);
        }
        return;
    }

    if (id == ID_BTN_ADD_SERVER)
    {
        ServerItem s;
        s.name = L"Server-" + std::to_wstring((int)gSet.servers.size()+1);
        s.host = L"127.0.0.1";
        s.port = 7777;
        gSet.servers.push_back(s);
        gSet.selectedServer = (int)gSet.servers.size()-1;
        toast(L"Server", L"Added", L"ok");
        InvalidateRect(hwnd, NULL, FALSE);
        return;
    }

    if (id == ID_BTN_DEL_SERVER)
    {
        if (gSet.servers.size() <= 1)
        {
            toast(L"Server", L"At least 1 server required", L"warn");
            return;
        }
        int idx = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
        gSet.servers.erase(gSet.servers.begin() + idx);
        gSet.selectedServer = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
        toast(L"Server", L"Removed", L"ok");
        InvalidateRect(hwnd, NULL, FALSE);
        return;
    }

    if (id == ID_BTN_SAVE_SETTINGS)
    {
        ApplyTextBoxToSettings();
        ApplyToggleToSettings();
        ApplyDropdownToSettings();

        SaveSettings();

        // reload bg
        if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
        if (!gSet.backgroundPath.empty() && FileExists(gSet.backgroundPath))
        {
            gBgImage = Image::FromFile(gSet.backgroundPath.c_str());
            if (!gBgImage || gBgImage->GetLastStatus() != Ok)
            {
                delete gBgImage;
                gBgImage = nullptr;
            }
        }

        InvalidateRect(hwnd, NULL, FALSE);
        return;
    }

    if (id == ID_BTN_PLAY)
    {
        ApplyTextBoxToSettings();
        ApplyDropdownToSettings();

        if (gSet.gamePath.empty() || !FileExists(gSet.gamePath))
        {
            toast(L"Play", L"Game EXE path not set. Open Settings / Choose Game EXE.", L"err");
            return;
        }

        int idx = ClampI(gSet.selectedServer, 0, (int)gSet.servers.size()-1);
        std::wstring extra;
        if (!gSet.servers.empty())
        {
            const auto& s = gSet.servers[idx];
            extra = L"--connect " + s.host + L":" + std::to_wstring(s.port);
        }

        std::wstring args = gSet.gameArgs;
        if (!extra.empty())
        {
            if (!args.empty()) args += L" ";
            args += extra;
        }

        std::wstring wd = GetExeDir();
        {
            std::wstring p = gSet.gamePath;
            size_t pos = p.find_last_of(L"\\/");
            if (pos != std::wstring::npos) wd = p.substr(0, pos);
        }

        bool ok = LaunchProcess(gSet.gamePath, args, wd);
        if (ok) toast(L"Launching", L"Game started (demo)", L"ok");
        else toast(L"Launch failed", L"CreateProcess failed. Check path/permissions.", L"err");
        return;
    }
}

// ============================================================
// Painting (double buffer)
// ============================================================

static void Paint(HWND hwnd)
{
    RECT rc; GetClientRect(hwnd, &rc);
    int w = rc.right - rc.left;
    int h = rc.bottom - rc.top;

    HDC hdc = GetDC(hwnd);
    HDC mem = CreateCompatibleDC(hdc);
    HBITMAP bmp = CreateCompatibleBitmap(hdc, w, h);
    HBITMAP old = (HBITMAP)SelectObject(mem, bmp);

    Graphics g(mem);
    g.SetSmoothingMode(SmoothingModeAntiAlias);
    g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
    g.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);

    DrawTopGradientBG(g, w, h);

    UIContext ui;
    ui.hwnd = hwnd;
    ui.w = w;
    ui.h = h;

    BuildLayout(ui);

    DrawTitleBar(g, ui);
    DrawSidebar(g, ui);

    if (gPage == Page::Home) DrawHomePage(g, ui);
    else if (gPage == Page::News) DrawNewsPage(g, ui);
    else DrawSettingsPage(g, ui);

    for (auto& b : gButtons)
    {
        if (b.id == ID_BTN_HOME)     b.kind = (gPage==Page::Home) ? BtnKind::Primary : BtnKind::Secondary;
        if (b.id == ID_BTN_NEWS)     b.kind = (gPage==Page::News) ? BtnKind::Primary : BtnKind::Secondary;
        if (b.id == ID_BTN_SETTINGS) b.kind = (gPage==Page::Settings) ? BtnKind::Primary : BtnKind::Secondary;

        if (b.id == ID_BTN_CLOSE) b.kind = BtnKind::Danger;
        if (b.id == ID_BTN_MIN)   b.kind = BtnKind::Secondary;

        DrawButton(g, b);
    }

    for (auto& t : gTextBoxes) DrawTextBox(g, t);
    for (auto& t : gToggles) DrawToggle(g, t);
    for (auto& d : gDropdowns) DrawDropdown(g, d);

    DrawToast(g, ui);

    BitBlt(hdc, 0, 0, w, h, mem, 0, 0, SRCCOPY);

    SelectObject(mem, old);
    DeleteObject(bmp);
    DeleteDC(mem);
    ReleaseDC(hwnd, hdc);
}

// ============================================================
// Window proc
// ============================================================

static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM w, LPARAM l)
{
    static UIContext ui;
    static bool dragging = false;
    static POINT dragStart{};
    static RECT wndStart{};

    switch (msg)
    {
    case WM_CREATE:
        ui.hwnd = hwnd;
        SetTimer(hwnd, T_ANIM, 16, NULL);
        SetTimer(hwnd, T_NEWS, 6000, NULL);
        SetTimer(hwnd, T_CARET, 120, NULL);
        return 0;

    case WM_TIMER:
        if (w == T_NEWS && !gNewsHtml.empty())
        {
            gNewsIndex = (gNewsIndex + 1) % (int)gNewsHtml.size();
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (w == T_ANIM)
        {
            if (gSet.animations)
                InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (w == T_CARET)
        {
            bool any = false;
            for (auto& t : gTextBoxes) if (t.focused) { any = true; break; }
            if (any) InvalidateRect(hwnd, NULL, FALSE);
        }
        return 0;

    case WM_SIZE:
    {
        RECT rc; GetClientRect(hwnd, &rc);
        ui.w = rc.right - rc.left;
        ui.h = rc.bottom - rc.top;
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_MOUSEMOVE:
    {
        ui.mousePos.x = GET_X_LPARAM(l);
        ui.mousePos.y = GET_Y_LPARAM(l);
        UpdateHover(ui);

        if (dragging)
        {
            POINT cur; GetCursorPos(&cur);
            int dx = cur.x - dragStart.x;
            int dy = cur.y - dragStart.y;
            SetWindowPos(hwnd, NULL, wndStart.left + dx, wndStart.top + dy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        }

        if (!gSet.animations)
            InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_MOUSEWHEEL:
        if (gPage == Page::News)
        {
            int delta = GET_WHEEL_DELTA_WPARAM(w);
            float step = (delta > 0) ? -64.0f : 64.0f;
            gNewsScroll.scroll = ClampF(gNewsScroll.scroll + step, 0.0f, gNewsScroll.maxScroll);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        return 0;

    case WM_LBUTTONDOWN:
    {
        ui.mouseDown = true;
        SetCapture(hwnd);

        POINT p{ GET_X_LPARAM(l), GET_Y_LPARAM(l) };

        // link click on press? (we open on mouse up)
        // Dropdown open item click
        for (auto& d : gDropdowns)
        {
            int idx = -1;
            if (DropdownHitOpenItem(d, p, idx))
            {
                d.selected = idx;
                d.open = false;
                ApplyDropdownToSettings();
                InvalidateRect(hwnd, NULL, FALSE);
                ReleaseCapture();
                ui.mouseDown = false;
                return 0;
            }
        }

        if (Button* b = HitButton(p))
        {
            b->down = true;
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }

        if (Toggle* t = HitToggle(p))
        {
            t->value = !t->value;
            ApplyToggleToSettings();
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }

        if (Dropdown* d = HitDropdown(p))
        {
            for (auto& dd : gDropdowns) if (dd.id != d->id) dd.open = false;
            d->open = !d->open;
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }
        else
        {
            CloseAllDropdowns();
        }

        if (TextBox* t = HitTextBox(p))
        {
            ClearTextFocus();
            t->focused = true;
            t->caretOn = true;
            t->lastBlink = GetTickCount();
            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }
        else
        {
            ClearTextFocus();
        }

        // Titlebar drag region
        if (p.y <= 54 && p.x < ui.w - 120)
        {
            dragging = true;
            GetCursorPos(&dragStart);
            GetWindowRect(hwnd, &wndStart);
        }

        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_LBUTTONUP:
    {
        ui.mouseDown = false;
        ReleaseCapture();
        dragging = false;

        POINT p{ GET_X_LPARAM(l), GET_Y_LPARAM(l) };

        // If News page: check link hits
        if (gPage == Page::News)
        {
            for (const auto& lh : gLinkHits)
            {
                if (PtInRectF(p, lh.r))
                {
                    toast(L"Open link", lh.url, L"ok");
                    ShellOpenUrl(lh.url);
                    InvalidateRect(hwnd, NULL, FALSE);
                    return 0;
                }
            }
        }

        for (auto& b : gButtons)
        {
            bool wasDown = b.down;
            b.down = false;
            if (wasDown && PtInRectF(p, b.rect) && b.enabled)
            {
                HandleButtonClick(hwnd, b.id);
                break;
            }
        }

        bool clickedDropdown = false;
        for (auto& d : gDropdowns) if (PtInRectF(p, d.rect)) clickedDropdown = true;

        if (!clickedDropdown)
        {
            bool hitOpenList = false;
            for (auto& d : gDropdowns)
            {
                int idx=-1;
                if (DropdownHitOpenItem(d, p, idx)) hitOpenList = true;
            }
            if (!hitOpenList) CloseAllDropdowns();
        }

        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_CHAR:
    {
        wchar_t ch = (wchar_t)w;
        if (ch == 0) return 0;

        for (auto& t : gTextBoxes)
        {
            if (!t.focused) continue;

            if (ch == 8)
            {
                if (!t.value.empty() && t.caret > 0)
                {
                    t.value.erase(t.value.begin() + (t.caret - 1));
                    t.caret--;
                }
            }
            else if (ch == 13)
            {
                if (t.id == ID_TX_NICK)
                {
                    ApplyTextBoxToSettings();
                    toast(L"Nickname", L"Updated", L"ok");
                }
                t.focused = false;
            }
            else if (ch >= 32)
            {
                if ((int)t.value.size() < 180)
                {
                    t.value.insert(t.value.begin() + t.caret, ch);
                    t.caret++;
                }
            }

            InvalidateRect(hwnd, NULL, FALSE);
            return 0;
        }
        return 0;
    }

    case WM_KEYDOWN:
        if (w == VK_F11)
        {
            ToggleFullscreen(hwnd);
            return 0;
        }

        for (auto& t : gTextBoxes)
        {
            if (!t.focused) continue;
            if (w == VK_LEFT)  { t.caret = ClampI(t.caret - 1, 0, (int)t.value.size()); InvalidateRect(hwnd,NULL,FALSE); return 0; }
            if (w == VK_RIGHT) { t.caret = ClampI(t.caret + 1, 0, (int)t.value.size()); InvalidateRect(hwnd,NULL,FALSE); return 0; }
            if (w == VK_HOME)  { t.caret = 0; InvalidateRect(hwnd,NULL,FALSE); return 0; }
            if (w == VK_END)   { t.caret = (int)t.value.size(); InvalidateRect(hwnd,NULL,FALSE); return 0; }
        }
        return 0;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        BeginPaint(hwnd, &ps);
        Paint(hwnd);
        EndPaint(hwnd, &ps);
        return 0;
    }

    case WM_ERASEBKGND:
        return 1;

    case WM_DESTROY:
        KillTimer(hwnd, T_ANIM);
        KillTimer(hwnd, T_NEWS);
        KillTimer(hwnd, T_CARET);
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProcW(hwnd, msg, w, l);
    }
}

// ============================================================
// WinMain
// ============================================================

int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE, PWSTR, int)
{
    GdiplusStartupInput gdiplusStartupInput;
    if (GdiplusStartup(&gGdiToken, &gdiplusStartupInput, NULL) != Ok)
        return 0;

    LoadSettings();

    WNDCLASSW wc{};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInst;
    wc.lpszClassName = APP_CLASS;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    RegisterClassW(&wc);

    DWORD style = WS_POPUP;
    DWORD ex = WS_EX_APPWINDOW;

    HWND hwnd = CreateWindowExW(
        ex,
        APP_CLASS,
        APP_TITLE,
        style,
        120, 80,
        gWinW, gWinH,
        NULL, NULL,
        hInst,
        NULL
    );

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    if (gSet.startFullscreen)
        ToggleFullscreen(hwnd);

    if (gSet.autoLaunch && !gSet.gamePath.empty() && FileExists(gSet.gamePath))
    {
        toast(L"AutoLaunch", L"Enabled (demo). Press PLAY to confirm.", L"warn");
    }
    else
    {
        toast(L"Ready", L"News supports HTML-like markup and clickable links.", L"ok");
    }

    MSG msg{};
    while (GetMessageW(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    if (gBgImage) { delete gBgImage; gBgImage = nullptr; }
    GdiplusShutdown(gGdiToken);
    return 0;
}
