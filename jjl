#define UNICODE
#define _UNICODE
#include <windows.h>
#include <windowsx.h>
#include <stdint.h>

static const wchar_t* kClassName = L"SimpleLauncherCloneLike";

static HBRUSH g_bg = NULL;
static HFONT  g_fontTitle = NULL;
static HFONT  g_fontUI = NULL;
static HFONT  g_fontSmall = NULL;

static COLORREF RGBc(int r,int g,int b){ return RGB(r,g,b); }

struct Rect { int x,y,w,h; };
static RECT ToRECT(Rect r){ RECT rc{r.x, r.y, r.x+r.w, r.y+r.h}; return rc; }
static bool PtInRectR(Rect r, int px, int py){
    return px>=r.x && px<r.x+r.w && py>=r.y && py<r.y+r.h;
}

static void FillRectColor(HDC hdc, RECT rc, COLORREF c){
    HBRUSH b = CreateSolidBrush(c);
    FillRect(hdc, &rc, b);
    DeleteObject(b);
}

static void DrawTextSimple(HDC hdc, const wchar_t* s, RECT rc, COLORREF c, UINT fmt){
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, c);
    DrawTextW(hdc, s, -1, &rc, fmt);
}

static void DrawRoundedRect(HDC hdc, RECT rc, int radius, COLORREF fill, COLORREF border){
    HBRUSH b = CreateSolidBrush(fill);
    HPEN p = CreatePen(PS_SOLID, 1, border);
    HGDIOBJ ob = SelectObject(hdc, b);
    HGDIOBJ op = SelectObject(hdc, p);

    RoundRect(hdc, rc.left, rc.top, rc.right, rc.bottom, radius, radius);

    SelectObject(hdc, op);
    SelectObject(hdc, ob);
    DeleteObject(p);
    DeleteObject(b);
}

struct Button {
    Rect r;
    const wchar_t* text;
    bool hot;
    bool down;
};

static Button g_btnBuy { {0,0,160,44}, L"Купить", false, false };

static int g_hoverMenu = -1;
static int g_activeMenu = 0;

static const wchar_t* g_menuItems[] = {
    L"Главная",
    L"Сервера",
    L"Новости",
    L"Сообщества",
    L"Купить GTA V"
};
static const int g_menuCount = sizeof(g_menuItems)/sizeof(g_menuItems[0]);

static Rect SidebarRect(int w, int h){ (void)h; return {0,0,260,0}; }
static Rect ContentRect(int w, int h){ return {260,0,w-260,h}; }

static void Layout(int w, int h){
    // Buy button in header/banner area
    // Place it near top-right of content
    Rect content = ContentRect(w,h);
    g_btnBuy.r = { content.x + content.w - 180, 90, 160, 44 };
}

static void DrawSidebar(HDC hdc, int w, int h){
    Rect sb = SidebarRect(w,h);
    RECT rcSB{0,0,sb.w,h};
    FillRectColor(hdc, rcSB, RGBc(20,20,20));

    // Logo area
    RECT rcLogo{20, 18, sb.w-20, 70};
    SelectObject(hdc, g_fontTitle);
    DrawTextSimple(hdc, L"GTA5 RP", rcLogo, RGBc(240,240,240), DT_LEFT|DT_VCENTER|DT_SINGLELINE);

    // Menu
    int top = 90;
    int itemH = 48;
    for(int i=0;i<g_menuCount;i++){
        RECT rc{0, top + i*itemH, sb.w, top + (i+1)*itemH};
        bool active = (i==g_activeMenu);
        bool hover  = (i==g_hoverMenu);

        if(active){
            FillRectColor(hdc, rc, RGBc(255,125,0));
        } else if(hover){
            FillRectColor(hdc, rc, RGBc(35,35,35));
        }

        RECT rcText{20, rc.top, sb.w-10, rc.bottom};
        SelectObject(hdc, g_fontUI);
        DrawTextSimple(hdc, g_menuItems[i], rcText,
                       active ? RGBc(15,15,15) : RGBc(200,200,200),
                       DT_LEFT|DT_VCENTER|DT_SINGLELINE);
    }
}

static void DrawHeaderAndBanner(HDC hdc, int w, int h){
    Rect c = ContentRect(w,h);
    // Top bar
    RECT rcTop{c.x, 0, c.x+c.w, 56};
    FillRectColor(hdc, rcTop, RGBc(30,30,30));

    // Online indicator
    RECT rcOnline{c.x+20, 0, c.x+c.w-20, 56};
    SelectObject(hdc, g_fontSmall);
    DrawTextSimple(hdc, L"Сейчас играет: 44 620", rcOnline, RGBc(210,210,210),
                   DT_LEFT|DT_VCENTER|DT_SINGLELINE);

    // Banner
    RECT rcBanner{c.x+20, 70, c.x+c.w-20, 190};
    DrawRoundedRect(hdc, rcBanner, 10, RGBc(40,40,40), RGBc(60,60,60));

    // Banner text
    RECT rcTitle{rcBanner.left+20, rcBanner.top+18, rcBanner.right-220, rcBanner.top+70};
    SelectObject(hdc, g_fontTitle);
    DrawTextSimple(hdc, L"Еще нет GTA V?", rcTitle, RGBc(240,240,240), DT_LEFT|DT_TOP);

    RECT rcSub{rcBanner.left+20, rcBanner.top+70, rcBanner.right-220, rcBanner.bottom-20};
    SelectObject(hdc, g_fontUI);
    DrawTextSimple(hdc, L"Вы можете приобрести ключ для\nRockstar Games Launcher",
                   rcSub, RGBc(200,200,200), DT_LEFT|DT_TOP);

    // Buy button
    RECT rcBtn = ToRECT(g_btnBuy.r);
    COLORREF btnFill = g_btnBuy.down ? RGBc(220,105,0) : (g_btnBuy.hot ? RGBc(255,145,30) : RGBc(255,125,0));
    DrawRoundedRect(hdc, rcBtn, 8, btnFill, RGBc(255,125,0));
    RECT rcBtnText{rcBtn.left, rcBtn.top, rcBtn.right, rcBtn.bottom};
    SelectObject(hdc, g_fontUI);
    DrawTextSimple(hdc, g_btnBuy.text, rcBtnText, RGBc(20,20,20), DT_CENTER|DT_VCENTER|DT_SINGLELINE);
}

static void DrawCards(HDC hdc, int w, int h){
    Rect c = ContentRect(w,h);

    // Section title
    RECT rcSec{c.x+20, 210, c.x+c.w-20, 250};
    SelectObject(hdc, g_fontTitle);
    DrawTextSimple(hdc, L"РЕКОМЕНДУЕМ ДЛЯ НОВИЧКОВ", rcSec, RGBc(240,240,240), DT_LEFT|DT_VCENTER|DT_SINGLELINE);

    // Cards row
    int y = 260;
    int gap = 14;
    int cardW = (c.w - 40 - 2*gap)/3;
    int cardH = 120;

    const wchar_t* names[3] = { L"DEL PERRO", L"LA MESA", L"RAINBOW" };
    const wchar_t* nums [3] = { L"14", L"10", L"07" };

    for(int i=0;i<3;i++){
        RECT rc{c.x+20 + i*(cardW+gap), y, c.x+20 + i*(cardW+gap) + cardW, y+cardH};
        DrawRoundedRect(hdc, rc, 10, RGBc(45,45,45), RGBc(70,70,70));

        RECT rcNum{rc.left+16, rc.top+12, rc.right-16, rc.top+40};
        SelectObject(hdc, g_fontUI);
        DrawTextSimple(hdc, nums[i], rcNum, RGBc(220,220,220), DT_LEFT|DT_TOP);

        RECT rcName{rc.left+16, rc.top+40, rc.right-16, rc.bottom-16};
        SelectObject(hdc, g_fontTitle);
        DrawTextSimple(hdc, names[i], rcName, RGBc(245,245,245), DT_LEFT|DT_BOTTOM);
    }

    // Next section
    RECT rcSec2{c.x+20, y+cardH+20, c.x+c.w-20, y+cardH+60};
    SelectObject(hdc, g_fontTitle);
    DrawTextSimple(hdc, L"ИГРАЙ И СМОТРИ", rcSec2, RGBc(240,240,240), DT_LEFT|DT_VCENTER|DT_SINGLELINE);

    // Tabs
    int tabY = y+cardH+70;
    RECT rcTabAll{c.x+20, tabY, c.x+90, tabY+28};
    RECT rcTabStreams{c.x+95, tabY, c.x+175, tabY+28};
    RECT rcTabVideo{c.x+180, tabY, c.x+250, tabY+28};

    DrawRoundedRect(hdc, rcTabAll, 6, RGBc(255,125,0), RGBc(255,125,0));
    SelectObject(hdc, g_fontSmall);
    DrawTextSimple(hdc, L"Все", rcTabAll, RGBc(20,20,20), DT_CENTER|DT_VCENTER|DT_SINGLELINE);

    DrawRoundedRect(hdc, rcTabStreams, 6, RGBc(55,55,55), RGBc(80,80,80));
    DrawTextSimple(hdc, L"Стримы", rcTabStreams, RGBc(220,220,220), DT_CENTER|DT_VCENTER|DT_SINGLELINE);

    DrawRoundedRect(hdc, rcTabVideo, 6, RGBc(55,55,55), RGBc(80,80,80));
    DrawTextSimple(hdc, L"Видео", rcTabVideo, RGBc(220,220,220), DT_CENTER|DT_VCENTER|DT_SINGLELINE);

    // Thumbnails placeholders
    int thumbY = tabY + 40;
    int thumbH = 120;
    int thumbW = (c.w - 40 - 2*gap)/3;
    for(int i=0;i<3;i++){
        RECT rc{c.x+20 + i*(thumbW+gap), thumbY, c.x+20 + i*(thumbW+gap)+thumbW, thumbY+thumbH};
        DrawRoundedRect(hdc, rc, 10, RGBc(50,50,50), RGBc(70,70,70));
        RECT rcT{rc.left+10, rc.top+10, rc.right-10, rc.bottom-10};
        SelectObject(hdc, g_fontSmall);
        DrawTextSimple(hdc, L"Превью", rcT, RGBc(200,200,200), DT_LEFT|DT_TOP);
    }
}

static void Paint(HWND hwnd, HDC hdc){
    RECT rcClient; GetClientRect(hwnd, &rcClient);
    int w = rcClient.right - rcClient.left;
    int h = rcClient.bottom - rcClient.top;

    Layout(w,h);

    // Background
    FillRectColor(hdc, rcClient, RGBc(25,25,25));

    DrawSidebar(hdc, w, h);
    DrawHeaderAndBanner(hdc, w, h);
    DrawCards(hdc, w, h);
}

static void UpdateHover(HWND hwnd, int mx, int my){
    RECT rcClient; GetClientRect(hwnd, &rcClient);
    int w = rcClient.right, h = rcClient.bottom;

    // menu hover
    Rect sb = SidebarRect(w,h);
    int top = 90;
    int itemH = 48;
    int newHover = -1;
    if(mx>=0 && mx<sb.w && my>=top && my<top+g_menuCount*itemH){
        newHover = (my - top)/itemH;
        if(newHover<0 || newHover>=g_menuCount) newHover = -1;
    }
    if(newHover != g_hoverMenu){
        g_hoverMenu = newHover;
        InvalidateRect(hwnd, NULL, FALSE);
    }

    // buy hover
    bool hot = PtInRectR(g_btnBuy.r, mx, my);
    if(hot != g_btnBuy.hot){
        g_btnBuy.hot = hot;
        InvalidateRect(hwnd, NULL, FALSE);
    }
}

static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg){
    case WM_CREATE: {
        g_bg = CreateSolidBrush(RGBc(25,25,25));
        g_fontTitle = CreateFontW(24,0,0,0,FW_BOLD,FALSE,FALSE,FALSE,DEFAULT_CHARSET,OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY,DEFAULT_PITCH,L"Segoe UI");
        g_fontUI = CreateFontW(16,0,0,0,FW_NORMAL,FALSE,FALSE,FALSE,DEFAULT_CHARSET,OUT_DEFAULT_PRECIS,
                               CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY,DEFAULT_PITCH,L"Segoe UI");
        g_fontSmall = CreateFontW(13,0,0,0,FW_NORMAL,FALSE,FALSE,FALSE,DEFAULT_CHARSET,OUT_DEFAULT_PRECIS,
                                  CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY,DEFAULT_PITCH,L"Segoe UI");
        return 0;
    }
    case WM_DESTROY:
        if(g_bg) DeleteObject(g_bg);
        if(g_fontTitle) DeleteObject(g_fontTitle);
        if(g_fontUI) DeleteObject(g_fontUI);
        if(g_fontSmall) DeleteObject(g_fontSmall);
        PostQuitMessage(0);
        return 0;

    case WM_MOUSEMOVE: {
        int mx = GET_X_LPARAM(lParam);
        int my = GET_Y_LPARAM(lParam);
        UpdateHover(hwnd, mx, my);
        // Track mouse leave
        TRACKMOUSEEVENT tme{sizeof(tme), TME_LEAVE, hwnd, 0};
        TrackMouseEvent(&tme);
        return 0;
    }
    case WM_MOUSELEAVE:
        g_hoverMenu = -1;
        g_btnBuy.hot = false;
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;

    case WM_LBUTTONDOWN: {
        SetCapture(hwnd);
        int mx = GET_X_LPARAM(lParam);
        int my = GET_Y_LPARAM(lParam);

        RECT rcClient; GetClientRect(hwnd, &rcClient);
        int w = rcClient.right, h = rcClient.bottom;
        Rect sb = SidebarRect(w,h);

        // menu click
        int top = 90;
        int itemH = 48;
        if(mx>=0 && mx<sb.w && my>=top && my<top+g_menuCount*itemH){
            int idx = (my - top)/itemH;
            if(idx>=0 && idx<g_menuCount){
                g_activeMenu = idx;
                InvalidateRect(hwnd, NULL, FALSE);
            }
        }

        // buy click
        if(PtInRectR(g_btnBuy.r, mx, my)){
            g_btnBuy.down = true;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        return 0;
    }
    case WM_LBUTTONUP: {
        ReleaseCapture();
        int mx = GET_X_LPARAM(lParam);
        int my = GET_Y_LPARAM(lParam);
        bool wasDown = g_btnBuy.down;
        g_btnBuy.down = false;

        if(wasDown && PtInRectR(g_btnBuy.r, mx, my)){
            MessageBoxW(hwnd, L"Тут можно открыть страницу покупки/встроенный браузер.", L"Купить", MB_OK);
        }
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }

    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // Double-buffering
        RECT rc; GetClientRect(hwnd, &rc);
        int w = rc.right - rc.left;
        int h = rc.bottom - rc.top;
        HDC mem = CreateCompatibleDC(hdc);
        HBITMAP bmp = CreateCompatibleBitmap(hdc, w, h);
        HGDIOBJ oldBmp = SelectObject(mem, bmp);

        Paint(hwnd, mem);

        BitBlt(hdc, 0, 0, w, h, mem, 0, 0, SRCCOPY);

        SelectObject(mem, oldBmp);
        DeleteObject(bmp);
        DeleteDC(mem);

        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_ERASEBKGND:
        return 1;
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE, PWSTR, int nCmdShow){
    WNDCLASSEXW wc{0};
    wc.cbSize = sizeof(wc);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszClassName = kClassName;
    RegisterClassExW(&wc);

    HWND hwnd = CreateWindowExW(
        0, kClassName, L"Launcher (пример на чистом WinAPI)",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 1200, 720,
        NULL, NULL, hInst, NULL
    );

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    MSG msg;
    while(GetMessageW(&msg, NULL, 0, 0)){
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return 0;
}
