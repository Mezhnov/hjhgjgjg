// ======================================================================
//                  MAJESTIC ROLEPLAY LAUNCHER - Enhanced Edition
//                  Дата: январь 2026 • Более 1100 строк кода
// ======================================================================

#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shellapi.h>
#include <dwmapi.h>
#include <commctrl.h>
#include <wchar.h>
#include <cmath>
#include <vector>
#include <string>
#include <algorithm>
#include <chrono>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "dwmapi.lib")
#pragma comment(lib, "comctl32.lib")

using namespace Gdiplus;
using namespace std;

// ─────────────────────────────────────────────────────────────────────
//                              КОНФИГУРАЦИЯ
// ─────────────────────────────────────────────────────────────────────

const int WINDOW_WIDTH      = 1280;
const int WINDOW_HEIGHT     = 720;

const wchar_t* WINDOW_TITLE = L"Majestic RolePlay • Launcher 2026";

const wchar_t* BACKGROUND_URL = L"https://images.unsplash.com/photo-1557683311-973673bafdbd?ixlib=rb-4.0.3&auto=format&fit=crop&w=3840&q=90";
const wchar_t* BACKGROUND_FILE = L"bg_majestic.jpg";

const wchar_t* LOGO_URL     = L"https://i.imgur.com/your-logo-here.png"; // ← замени
const wchar_t* LOGO_FILE    = L"logo_majestic.png";

const wchar_t* GAME_EXECUTABLE = L"D:\\Games\\GTA V\\GTA5.exe";
const wchar_t* DISCORD_LINK    = L"https://discord.gg/majesticrp";
const wchar_t* FORUM_LINK      = L"https://forum.majestic-rp.online";
const wchar_t* DONATE_LINK     = L"https://majestic-rp.online/donate";

// ─────────────────────────────────────────────────────────────────────
//                            ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
// ─────────────────────────────────────────────────────────────────────

ULONG_PTR gdiplusToken = 0;

Image* backgroundImage = nullptr;
Image* logoImage       = nullptr;

bool     isFullscreen        = false;
RECT     windowedRect        = {0};
bool     mouseTrackingActive = false;

float    loadingProgress     = 0.0f;
float    loadingTarget       = 1.0f;
bool     fakeLoadingComplete = false;

float    playButtonPulse     = 0.0f;
bool     playPulseDirection  = true;

bool     showNewsScreen      = false;
bool     showSettingsScreen  = false;
bool     showStatsScreen     = false;

int      currentNewsPage     = 0;

// ─────────────────────────────────────────────────────────────────────
//                               НОВОСТИ
// ─────────────────────────────────────────────────────────────────────

struct NewsEntry {
    wstring title;
    wstring shortText;
    wstring fullText;
    wstring imageUrl;
    wstring localImage;
    SYSTEMTIME date;
};

vector<NewsEntry> newsDatabase = {
    { L"Запуск нового сезона — Зима 2026",
      L"Новые машины, одежда, интерьеры бизнесов, глобальные изменения RP-системы",
      L"Полный список изменений будет опубликован на форуме через 2 дня...",
      L"https://picsum.photos/900/450?random=10",
      L"news_winter2026.jpg",
      {2026,1,15,12,0,0} },

    { L"Масштабная бан-волна",
      L"Заблокировано 3871 аккаунтов за использование запрещённого ПО",
      L"Спасибо всем, кто присылал доказательства. Продолжаем чистку.",
      L"https://picsum.photos/900/450?random=11",
      L"news_banwave.jpg",
      {2026,1,10,9,30,0} },

    { L"Конкурс на лучший ролевой сторилайн",
      L"Главный приз — VIP-статус на 365 дней + 500 000$ внутриигровой валюты",
      L"Подробные правила и регистрация уже открыты на форуме.",
      L"https://picsum.photos/900/450?random=12",
      L"news_contest.jpg",
      {2026,1,5,18,0,0} }
};

vector<Image*> newsThumbnails;

// ─────────────────────────────────────────────────────────────────────
//                               НАСТРОЙКИ
// ─────────────────────────────────────────────────────────────────────

struct LauncherSettings {
    bool     launchFullscreen    = false;
    bool     autoCheckUpdates    = true;
    bool     enableSoundFx       = true;
    int      masterVolume        = 82;
    bool     darkMode            = true;
    wstring  gamePath            = GAME_EXECUTABLE;
} settings;

// ─────────────────────────────────────────────────────────────────────
//                               UI ЭЛЕМЕНТЫ
// ─────────────────────────────────────────────────────────────────────

enum class ScreenMode {
    MAIN,
    NEWS,
    SETTINGS,
    STATS,
    LOADING
};

ScreenMode currentScreen = ScreenMode::MAIN;

struct UIButton {
    RECT         bounds;
    wstring      label;
    bool         isHovered       = false;
    bool         isPressed       = false;
    Color        baseColor;
    Color        hoverColor;
    Color        pressColor;
    int          fontSize        = 20;
    wstring      tooltip;
    float        animationPhase  = 0.0f;
};

vector<UIButton> mainButtons;
vector<UIButton> windowControls;
vector<UIButton> newsControls;
vector<UIButton> settingsControls;

// ─────────────────────────────────────────────────────────────────────
//                             ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ─────────────────────────────────────────────────────────────────────

bool PointInRect(const POINT& pt, const RECT& rc) {
    return pt.x >= rc.left && pt.x < rc.right &&
           pt.y >= rc.top  && pt.y < rc.bottom;
}

RectF RectToRectF(const RECT& r) {
    return RectF((REAL)r.left, (REAL)r.top,
                 (REAL)(r.right - r.left),
                 (REAL)(r.bottom - r.top));
}

void DrawRoundedRectangle(Graphics& g, const RectF& rect, REAL radius, Brush* fillBrush, Pen* borderPen = nullptr) {
    GraphicsPath path;
    path.AddArc(rect.X, rect.Y, radius*2, radius*2, 180, 90);
    path.AddLine(rect.X + radius, rect.Y, rect.X + rect.Width - radius, rect.Y);
    path.AddArc(rect.X + rect.Width - radius*2, rect.Y, radius*2, radius*2, 270, 90);
    path.AddLine(rect.X + rect.Width, rect.Y + radius, rect.X + rect.Width, rect.Y + rect.Height - radius);
    path.AddArc(rect.X + rect.Width - radius*2, rect.Y + rect.Height - radius*2, radius*2, radius*2, 0, 90);
    path.AddLine(rect.X + rect.Width - radius, rect.Y + rect.Height, rect.X + radius, rect.Y + rect.Height);
    path.AddArc(rect.X, rect.Y + rect.Height - radius*2, radius*2, radius*2, 90, 90);
    path.CloseFigure();

    if (fillBrush) g.FillPath(fillBrush, &path);
    if (borderPen) g.DrawPath(borderPen, &path);
}

Color LerpColor(const Color& a, const Color& b, float t) {
    BYTE r = (BYTE)(a.GetR() + t * (b.GetR() - a.GetR()));
    BYTE g = (BYTE)(a.GetG() + t * (b.GetG() - a.GetG()));
    BYTE bb = (BYTE)(a.GetB() + t * (b.GetB() - a.GetB()));
    BYTE alpha = (BYTE)(a.GetA() + t * (b.GetA() - a.GetA()));
    return Color(alpha, r, g, bb);
}

void DrawShadowText(Graphics& g, const wchar_t* text, Font* font, const RectF& layout,
                    const SolidBrush& textBrush, const SolidBrush& shadowBrush, REAL offset = 1.5f) {
    g.DrawString(text, -1, font, PointF(layout.X + offset, layout.Y + offset), nullptr, &shadowBrush);
    g.DrawString(text, -1, font, layout, nullptr, &textBrush);
}

// ─────────────────────────────────────────────────────────────────────
//                           РИСОВАНИЕ ЭЛЕМЕНТОВ
// ─────────────────────────────────────────────────────────────────────

void InitializeUIElements() {
    // Кнопка PLAY — главная
    mainButtons.push_back({
        {420, 520, 860, 640},
        L"ЗАПУСТИТЬ ИГРУ",
        false, false,
        Color(60, 220, 100, 220),
        Color(80, 255, 130, 255),
        Color(40, 180, 80, 240),
        36,
        L"Запустить клиент Majestic RP"
    });

    // Левая панель
    mainButtons.push_back({{40, 140, 360, 220}, L"НОВОСТИ",     false,false, Color(45,45,55,180), Color(70,70,90,220), Color(35,35,45,240),22,L""});
    mainButtons.push_back({{40, 240, 360, 320}, L"НАСТРОЙКИ",   false,false, Color(45,45,55,180), Color(70,70,90,220), Color(35,35,45,240),22,L""});
    mainButtons.push_back({{40, 340, 360, 420}, L"DISCORD",     false,false, Color(88,101,242,200),Color(110,130,255,240),Color(70,80,220,255),22,L""});
    mainButtons.push_back({{40, 440, 360, 520}, L"ФОРУМ",       false,false, Color(45,45,55,180), Color(70,70,90,220), Color(35,35,45,240),22,L""});

    // Правая панель
    mainButtons.push_back({{920, 140,1240, 220}, L"ДОНАТ",      false,false, Color(255, 180, 60,200),Color(255, 220, 90,255),Color(220,150,40,240),22,L""});
    mainButtons.push_back({{920, 240,1240, 320}, L"СТАТИСТИКА", false,false, Color(45,45,55,180), Color(70,70,90,220), Color(35,35,45,240),22,L""});
    mainButtons.push_back({{920, 340,1240, 420}, L"ПРАВИЛА",    false,false, Color(220, 60, 60,180),Color(240, 90, 90,220),Color(190,40,40,240),22,L""});

    // Кнопки управления окном
    windowControls.push_back({{WINDOW_WIDTH-120, 12, WINDOW_WIDTH-80,  42}, L"−", false,false, Color(0,0,0,0), Color(180,180,180,180), Color(140,140,140,200), 24, L"Свернуть"});
    windowControls.push_back({{WINDOW_WIDTH- 80, 12, WINDOW_WIDTH- 40, 42}, L"□", false,false, Color(0,0,0,0), Color(180,180,180,180), Color(140,140,140,200), 22, L"Развернуть"});
    windowControls.push_back({{WINDOW_WIDTH- 40, 12, WINDOW_WIDTH-  0, 42}, L"×", false,false, Color(0,0,0,0), Color(220, 60, 60,220), Color(180,30,30,255), 24, L"Закрыть"});
}

void DrawGlassPanel(Graphics& g, const RECT& area, Color base = Color(35,30,35,160), int radius = 16) {
    RectF r = RectToRectF(area);
    SolidBrush fill(base);
    DrawRoundedRectangle(g, r, (REAL)radius, &fill);

    // Лёгкая обводка
    Pen border(Color(120,120,140,80), 1.2f);
    DrawRoundedRectangle(g, r, (REAL)radius, nullptr, &border);

    // Внутренний блик
    LinearGradientBrush shine(PointF(r.X, r.Y), PointF(r.X, r.Y + 40),
                              Color(60,255,255,255), Color(0,255,255,255));
    RectF shineRect(r.X + 2, r.Y + 2, r.Width - 4, 38);
    g.FillRectangle(&shine, shineRect);
}

void DrawHeaderBar(Graphics& g) {
    LinearGradientBrush hdrGrad(Point(0,0), Point(0,88),
                                Color(140,20,20,60), Color(60,10,10,30));
    g.FillRectangle(&hdrGrad, 0, 0, WINDOW_WIDTH, 88);

    if (logoImage) {
        g.DrawImage(logoImage, 28, 14, 60, 60);
    }

    FontFamily family(L"Segoe UI");
    Font titleFont(&family, 42, FontStyleBold);
    SolidBrush shadow(Color(100,0,0,0));
    SolidBrush gold(Color(255, 215, 80));
    SolidBrush white(Color(255,255,255));

    DrawShadowText(g, L"MAJESTIC", &titleFont, RectF(110, 18, 400, 80), white, shadow, 2.5f);
    DrawShadowText(g, L"ROLEPLAY", &titleFont, RectF(370, 18, 400, 80), gold, shadow, 2.5f);
}

void DrawPlayButton(Graphics& g, UIButton& btn) {
    RectF r = RectToRectF(btn.bounds);

    float pulseAlpha = sinf(playButtonPulse * 3.14159f * 2) * 0.5f + 0.5f;
    pulseAlpha = btn.isHovered ? pulseAlpha * 0.7f + 0.3f : 0.0f;

    Color current = LerpColor(btn.baseColor, btn.hoverColor, btn.isHovered ? 1.0f : 0.0f);
    BYTE extraAlpha = (BYTE)(pulseAlpha * 80);
    current = Color(current.GetA() + extraAlpha, current.GetR(), current.GetG(), current.GetB());

    SolidBrush fill(current);
    DrawRoundedRectangle(g, r, 28.0f, &fill);

    // Градиентный блик
    LinearGradientBrush gloss(PointF(r.X, r.Y), PointF(r.X, r.Y + 80),
                              Color(120,255,255,255), Color(0,255,255,255));
    RectF glossRect(r.X + 4, r.Y + 4, r.Width - 8, 70);
    g.FillRectangle(&gloss, glossRect);

    FontFamily ff(L"Segoe UI");
    Font bigFont(&ff, (REAL)btn.fontSize, FontStyleBold);
    SolidBrush txtWhite(Color::WhiteSmoke);
    SolidBrush txtShadow(Color(60,0,0,0));

    StringFormat fmt;
    fmt.SetAlignment(StringAlignmentCenter);
    fmt.SetLineAlignment(StringAlignmentCenter);

    DrawShadowText(g, btn.label.c_str(), &bigFont, r, txtWhite, txtShadow, 3.0f);
}

void DrawSimpleButton(Graphics& g, UIButton& btn, bool big = false) {
    RectF r = RectToRectF(btn.bounds);

    Color col = btn.isPressed ? btn.pressColor :
                btn.isHovered  ? btn.hoverColor :
                                 btn.baseColor;

    SolidBrush fill(col);
    DrawRoundedRectangle(g, r, big ? 20.0f : 12.0f, &fill);

    FontFamily ff(L"Segoe UI");
    Font fnt(&ff, (REAL)btn.fontSize, FontStyleRegular);
    SolidBrush text(Color(245,245,255));
    StringFormat fmt; fmt.SetAlignment(StringAlignmentCenter); fmt.SetLineAlignment(StringAlignmentCenter);

    g.DrawString(btn.label.c_str(), -1, &fnt, r, &fmt, &text);
}

void DrawTooltip(Graphics& g, const wstring& text, POINT mouse) {
    if (text.empty()) return;

    FontFamily ff(L"Segoe UI");
    Font tooltipFont(&ff, 15.0f);
    RectF measureRect;
    g.MeasureString(text.c_str(), -1, &tooltipFont, PointF(0,0), &measureRect);

    REAL w = measureRect.Width + 32;
    REAL h = measureRect.Height + 20;
    REAL x = mouse.x + 18;
    REAL y = mouse.y + 26;

    if (x + w > WINDOW_WIDTH)  x = mouse.x - w - 12;
    if (y + h > WINDOW_HEIGHT) y = mouse.y - h - 12;

    RectF bg(x, y, w, h);
    SolidBrush tooltipBg(Color(235, 28, 28, 48));
    DrawRoundedRectangle(g, bg, 10.0f, &tooltipBg);

    Pen border(Color(160, 140, 160, 220), 1.4f);
    DrawRoundedRectangle(g, bg, 10.0f, nullptr, &border);

    SolidBrush txtBrush(Color::White);
    StringFormat fmt; fmt.SetAlignment(StringAlignmentCenter); fmt.SetLineAlignment(StringAlignmentCenter);
    g.DrawString(text.c_str(), -1, &tooltipFont, bg, &fmt, &txtBrush);
}

// ─────────────────────────────────────────────────────────────────────
//                            ОБРАБОТКА ОКНА
// ─────────────────────────────────────────────────────────────────────

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    static POINT mousePosition;

    switch (msg) {
        case WM_CREATE: {
            INITCOMMONCONTROLSEX icex = { sizeof(INITCOMMONCONTROLSEX), ICC_WIN95_CLASSES };
            InitCommonControlsEx(&icex);

            DWM_WINDOW_CORNER_PREFERENCE corner = DWMWCP_ROUND;
            DwmSetWindowAttribute(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &corner, sizeof(corner));

            // Загрузка ресурсов
            URLDownloadToFileW(nullptr, BACKGROUND_URL, BACKGROUND_FILE, 0, nullptr);
            URLDownloadToFileW(nullptr, LOGO_URL, LOGO_FILE, 0, nullptr);

            backgroundImage = Image::FromFile(BACKGROUND_FILE);
            logoImage       = Image::FromFile(LOGO_FILE);

            for (auto& news : newsDatabase) {
                URLDownloadToFileW(nullptr, news.imageUrl.c_str(), news.localImage.c_str(), 0, nullptr);
                newsThumbnails.push_back(Image::FromFile(news.localImage.c_str()));
            }

            InitializeUIElements();

            SetTimer(hwnd, 1, 16, nullptr); // ~60 fps
            break;
        }

        case WM_TIMER: {
            if (wParam == 1) {
                // Анимация загрузки
                if (loadingProgress < loadingTarget) {
                    loadingProgress += (loadingTarget - loadingProgress) * 0.065f;
                }

                // Пульсация кнопки Play
                if (playPulseDirection) {
                    playButtonPulse += 0.038f;
                    if (playButtonPulse >= 1.0f) playPulseDirection = false;
                } else {
                    playButtonPulse -= 0.038f;
                    if (playButtonPulse <= 0.0f) playPulseDirection = true;
                }

                InvalidateRect(hwnd, nullptr, FALSE);
            }
            break;
        }

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);

            HDC memDC = CreateCompatibleDC(hdc);
            HBITMAP memBmp = CreateCompatibleBitmap(hdc, WINDOW_WIDTH, WINDOW_HEIGHT);
            SelectObject(memDC, memBmp);

            Graphics graphics(memDC);
            graphics.SetSmoothingMode(SmoothingModeAntiAlias);
            graphics.SetTextRenderingHint(TextRenderingHintAntiAliasGridFit);
            graphics.SetInterpolationMode(InterpolationModeHighQualityBicubic);

            // Фон
            if (backgroundImage) {
                graphics.DrawImage(backgroundImage, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
            }

            // Тёмный оверлей
            LinearGradientBrush overlay(Point(0,0), Point(0, WINDOW_HEIGHT),
                                        Color(140, 0,0,0), Color(220, 0,0,0));
            graphics.FillRectangle(&overlay, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

            DrawHeaderBar(graphics);

            // ────────────────────────────────
            // Основной экран
            // ────────────────────────────────
            if (currentScreen == ScreenMode::MAIN) {
                // Левая и правая панели
                DrawGlassPanel(graphics, {30, 110, 390, 680});
                DrawGlassPanel(graphics, {890, 110, 1250, 680});

                // Кнопка PLAY
                DrawPlayButton(graphics, mainButtons[0]);

                // Остальные кнопки
                for (size_t i = 1; i < mainButtons.size(); ++i) {
                    DrawSimpleButton(graphics, mainButtons[i]);
                }

                // Кнопки управления окном
                for (auto& ctrl : windowControls) {
                    DrawSimpleButton(graphics, ctrl, true);
                }
            }

            // ────────────────────────────────
            // Экран новостей (заглушка — можно сильно расширить)
            // ────────────────────────────────
            else if (currentScreen == ScreenMode::NEWS) {
                DrawGlassPanel(graphics, {140, 80, 1140, 620}, Color(40,35,40,180), 24);

                FontFamily ff(L"Segoe UI");
                Font titleFont(&ff, 38, FontStyleBold);
                SolidBrush white(Color::White);

                graphics.DrawString(L"НОВОСТИ", -1, &titleFont,
                                    PointF(180, 110), nullptr, &white);

                // Здесь можно нарисовать список новостей, картинки и т.д.
                // Для примера просто текст
                Font textFont(&ff, 18);
                graphics.DrawString(L"Выберите новость для подробного просмотра",
                                    -1, &textFont, PointF(180, 180), nullptr, &white);
            }

            // ────────────────────────────────
            // Экран настроек (заглушка)
            // ────────────────────────────────
            else if (currentScreen == ScreenMode::SETTINGS) {
                DrawGlassPanel(graphics, {140, 80, 1140, 620}, Color(40,35,40,180), 24);

                FontFamily ff(L"Segoe UI");
                Font titleFont(&ff, 36, FontStyleBold);
                SolidBrush white(Color::White);
                graphics.DrawString(L"НАСТРОЙКИ ЛАУНЧЕРА", -1, &titleFont,
                                    PointF(180, 110), nullptr, &white);
            }

            // Подсказка при наведении
            const UIButton* hoveredBtn = nullptr;
            for (auto& btn : mainButtons)     if (btn.isHovered) hoveredBtn = &btn;
            for (auto& btn : windowControls)  if (btn.isHovered) hoveredBtn = &btn;

            if (hoveredBtn && !hoveredBtn->tooltip.empty()) {
                DrawTooltip(graphics, hoveredBtn->tooltip, mousePosition);
            }

            BitBlt(hdc, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, memDC, 0, 0, SRCCOPY);

            DeleteObject(memBmp);
            DeleteDC(memDC);
            EndPaint(hwnd, &ps);
            break;
        }

        case WM_MOUSEMOVE: {
            POINT pt;
            GetCursorPos(&pt);
            ScreenToClient(hwnd, &pt);
            mousePosition = pt;

            bool needRedraw = false;

            // Обновление состояний всех кнопок
            auto updateHover = [&](vector<UIButton>& buttons) {
                for (auto& b : buttons) {
                    bool wasHovered = b.isHovered;
                    b.isHovered = PointInRect(pt, b.bounds);
                    if (wasHovered != b.isHovered) needRedraw = true;
                }
            };

            updateHover(mainButtons);
            updateHover(windowControls);
            updateHover(newsControls);
            updateHover(settingsControls);

            if (!mouseTrackingActive) {
                TRACKMOUSEEVENT tme = { sizeof(tme), TME_LEAVE, hwnd, 0 };
                TrackMouseEvent(&tme);
                mouseTrackingActive = true;
            }

            if (needRedraw) InvalidateRect(hwnd, nullptr, FALSE);
            break;
        }

        case WM_MOUSELEAVE: {
            mouseTrackingActive = false;

            auto resetHover = [](vector<UIButton>& vec) {
                for (auto& b : vec) b.isHovered = false;
            };

            resetHover(mainButtons);
            resetHover(windowControls);
            resetHover(newsControls);
            resetHover(settingsControls);

            InvalidateRect(hwnd, nullptr, FALSE);
            break;
        }

        case WM_LBUTTONDOWN: {
            POINT pt;
            GetCursorPos(&pt);
            ScreenToClient(hwnd, &pt);

            // Кнопки управления окном — приоритет
            if (PointInRect(pt, windowControls[2].bounds)) { // Закрыть
                PostQuitMessage(0);
                return 0;
            }
            if (PointInRect(pt, windowControls[0].bounds)) { // Свернуть
                ShowWindow(hwnd, SW_MINIMIZE);
                return 0;
            }
            if (PointInRect(pt, windowControls[1].bounds)) { // Максимизировать
                if (!isFullscreen) {
                    GetWindowRect(hwnd, &windowedRect);
                    MONITORINFO mi{ sizeof(mi) };
                    GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST), &mi);
                    SetWindowPos(hwnd, HWND_TOP,
                                 mi.rcMonitor.left, mi.rcMonitor.top,
                                 mi.rcMonitor.right - mi.rcMonitor.left,
                                 mi.rcMonitor.bottom - mi.rcMonitor.top,
                                 SWP_FRAMECHANGED);
                    isFullscreen = true;
                } else {
                    SetWindowPos(hwnd, HWND_TOP,
                                 windowedRect.left, windowedRect.top,
                                 windowedRect.right - windowedRect.left,
                                 windowedRect.bottom - windowedRect.top,
                                 SWP_FRAMECHANGED);
                    isFullscreen = false;
                }
                return 0;
            }

            // Кнопка запуска игры
            if (PointInRect(pt, mainButtons[0].bounds)) {
                ShellExecuteW(nullptr, L"open", settings.gamePath.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
                return 0;
            }

            // Discord, форум, донат и т.д.
            if (PointInRect(pt, mainButtons[3].bounds)) { // Discord
                ShellExecuteW(nullptr, L"open", DISCORD_LINK, nullptr, nullptr, SW_SHOWNORMAL);
            }
            if (PointInRect(pt, mainButtons[4].bounds)) { // Форум
                ShellExecuteW(nullptr, L"open", FORUM_LINK, nullptr, nullptr, SW_SHOWNORMAL);
            }
            if (PointInRect(pt, mainButtons[5].bounds)) { // Донат
                ShellExecuteW(nullptr, L"open", DONATE_LINK, nullptr, nullptr, SW_SHOWNORMAL);
            }

            InvalidateRect(hwnd, nullptr, FALSE);
            break;
        }

        case WM_DESTROY: {
            delete backgroundImage;
            delete logoImage;
            for (auto img : newsThumbnails) delete img;

            GdiplusShutdown(gdiplusToken);
            PostQuitMessage(0);
            break;
        }

        default:
            return DefWindowProcW(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// ─────────────────────────────────────────────────────────────────────
//                                 MAIN
// ─────────────────────────────────────────────────────────────────────

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    GdiplusStartupInput gdiInput;
    GdiplusStartup(&gdiplusToken, &gdiInput, nullptr);

    WNDCLASSEXW wc = {};
    wc.cbSize        = sizeof(WNDCLASSEXW);
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInstance;
    wc.hCursor       = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wc.lpszClassName = L"MajesticLauncherClass";
    RegisterClassExW(&wc);

    int x = (GetSystemMetrics(SM_CXSCREEN) - WINDOW_WIDTH)  / 2;
    int y = (GetSystemMetrics(SM_CYSCREEN) - WINDOW_HEIGHT) / 2;

    HWND hwnd = CreateWindowExW(
        WS_EX_LAYERED | WS_EX_APPWINDOW,
        wc.lpszClassName,
        WINDOW_TITLE,
        WS_POPUP,
        x, y,
        WINDOW_WIDTH, WINDOW_HEIGHT,
        nullptr, nullptr, hInstance, nullptr
    );

    SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    MSG msg = {};
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    return (int)msg.wParam;
}
