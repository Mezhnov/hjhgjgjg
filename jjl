// main.cpp
// Dear ImGui + SDL2 + OpenGL3 UI replica (single file UI logic)
// Build requires linking SDL2 and compiling ImGui sources + backends.

#include <SDL.h>
#include <SDL_opengl.h>

#include <string>
#include <vector>
#include <algorithm>

#include "imgui.h"
#include "imgui_impl_sdl2.h"
#include "imgui_impl_opengl3.h"

// --------------------------- Data ---------------------------

struct Card {
    int id{};
    std::string title;
    std::string when;
    std::string remind;
    ImU32 dot;
};

static std::vector<Card> g_cards = {
    {1, "Забронировать ресторан", "Сегодня, 12:00", "За час",  IM_COL32(108, 92, 231, 255)},
    {2, "Разобраться с ремонтом", "Сегодня, 16:00", "За 3 ч",  IM_COL32( 96,165,250, 255)},
    {3, "Купить подарок жене",    "Сегодня, 21:00", "За 15 мин",IM_COL32(245,158, 11, 255)},
};

static int g_selected_card = 1;

static std::vector<std::string> g_user_msgs;

// --------------------------- Helpers ---------------------------

static float clampf(float v, float a, float b){ return v < a ? a : (v > b ? b : v); }

static void AddShadowRect(ImDrawList* dl, ImVec2 p0, ImVec2 p1, float rounding, ImU32 col, float spread=10.0f)
{
    // Simple fake shadow: draw multiple expanded rects with fading alpha
    const int steps = 10;
    for(int i=0;i<steps;i++){
        float t = (float)i/(steps-1);
        float a = (1.0f - t);
        float expand = t * spread;
        ImU32 c = (col & 0x00FFFFFF) | (ImU32)( (int)(a * ((col>>24)&0xFF)) << 24 );
        dl->AddRectFilled(ImVec2(p0.x-expand, p0.y-expand),
                          ImVec2(p1.x+expand, p1.y+expand),
                          c, rounding+expand);
    }
}

static void DrawGradientRect(ImDrawList* dl, ImVec2 p0, ImVec2 p1, ImU32 cTL, ImU32 cTR, ImU32 cBR, ImU32 cBL, float rounding=0.0f)
{
    dl->AddRectFilledMultiColor(p0, p1, cTL, cTR, cBR, cBL);
    if(rounding > 0.0f){
        // clip with rounded rect by drawing a rounded rect mask-ish:
        // easiest: draw rounded rect over with same colors isn't possible.
        // We'll accept square corners for gradients; rounding used where solid fills.
        (void)rounding;
    }
}

static void PushUIStyle()
{
    ImGuiStyle& s = ImGui::GetStyle();
    s.WindowRounding = 22.0f;
    s.ChildRounding  = 18.0f;
    s.FrameRounding  = 14.0f;
    s.PopupRounding  = 14.0f;
    s.ScrollbarRounding = 999.0f;
    s.GrabRounding = 999.0f;
    s.WindowBorderSize = 0.0f;
    s.FrameBorderSize  = 1.0f;
    s.ItemSpacing = ImVec2(10, 10);
    s.WindowPadding = ImVec2(0, 0);
    s.FramePadding = ImVec2(10, 8);
    s.ScrollbarSize = 12.0f;

    ImVec4* c = s.Colors;
    c[ImGuiCol_Text] = ImVec4(0.12f,0.14f,0.19f,1.00f);
    c[ImGuiCol_WindowBg] = ImVec4(0,0,0,0);
    c[ImGuiCol_ChildBg]  = ImVec4(1,1,1,1);
    c[ImGuiCol_Border]   = ImVec4(0.90f,0.91f,0.95f,1.00f);
    c[ImGuiCol_FrameBg]  = ImVec4(0.95f,0.96f,0.98f,1.00f);
    c[ImGuiCol_FrameBgHovered] = ImVec4(0.94f,0.95f,0.98f,1.00f);
    c[ImGuiCol_FrameBgActive]  = ImVec4(0.93f,0.94f,0.97f,1.00f);
    c[ImGuiCol_Button]   = ImVec4(0.95f,0.96f,0.98f,1.00f);
    c[ImGuiCol_ButtonHovered] = ImVec4(0.94f,0.95f,0.98f,1.00f);
    c[ImGuiCol_ButtonActive]  = ImVec4(0.92f,0.93f,0.97f,1.00f);
    c[ImGuiCol_Header] = ImVec4(0.95f,0.96f,0.98f,1.00f);
    c[ImGuiCol_HeaderHovered] = ImVec4(0.94f,0.95f,0.98f,1.00f);
    c[ImGuiCol_HeaderActive]  = ImVec4(0.92f,0.93f,0.97f,1.00f);
    c[ImGuiCol_ScrollbarBg]   = ImVec4(0,0,0,0);
    c[ImGuiCol_ScrollbarGrab] = ImVec4(0.62f,0.65f,0.72f,0.35f);
    c[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.62f,0.65f,0.72f,0.45f);
    c[ImGuiCol_ScrollbarGrabActive]  = ImVec4(0.62f,0.65f,0.72f,0.55f);
}

static void DrawDecorBlocks(ImDrawList* dl, ImVec2 screen, float t)
{
    auto block = [&](ImVec2 pos, ImVec2 size, ImU32 top, ImU32 bot){
        // gradient rect
        DrawGradientRect(dl, pos, ImVec2(pos.x+size.x, pos.y+size.y),
                         top, top, bot, bot);
        dl->AddRect(pos, ImVec2(pos.x+size.x, pos.y+size.y),
                    IM_COL32(255,255,255,40), 14.0f, 0, 1.0f);
        // inner light shapes
        dl->AddRectFilled(ImVec2(pos.x+size.x-86, pos.y+14),
                          ImVec2(pos.x+size.x-16, pos.y+54),
                          IM_COL32(255,255,255,120), 10.0f);
        dl->AddRectFilled(ImVec2(pos.x+18, pos.y+size.y-46),
                          ImVec2(pos.x+64, pos.y+size.y-16),
                          IM_COL32(255,255,255,80), 10.0f);
    };

    float wob = 4.0f * sinf(t*0.7f);
    block(ImVec2(-60, -40+wob), ImVec2(180,120),
          IM_COL32(124,58,237,230), IM_COL32(108,92,231,60));
    block(ImVec2(screen.x-150, -30-wob), ImVec2(210,130),
          IM_COL32(124,58,237,230), IM_COL32(108,92,231,60));
    block(ImVec2(-70, screen.y-80+wob), ImVec2(220,140),
          IM_COL32(96,165,250,230), IM_COL32(108,92,231,60));
    block(ImVec2(screen.x-140, screen.y-80-wob), ImVec2(200,130),
          IM_COL32(139,92,246,230), IM_COL32(96,165,250,50));
}

static bool CardWidget(const Card& c, bool selected, float width)
{
    ImGui::PushID(c.id);

    ImDrawList* dl = ImGui::GetWindowDrawList();
    ImVec2 p0 = ImGui::GetCursorScreenPos();
    ImVec2 size(width, 66);

    // shadow
    AddShadowRect(dl, p0, ImVec2(p0.x+size.x, p0.y+size.y), 14.0f, IM_COL32(25,28,43,20), 10.0f);

    // bg
    dl->AddRectFilled(p0, ImVec2(p0.x+size.x, p0.y+size.y), IM_COL32(255,255,255,255), 14.0f);
    dl->AddRect(p0, ImVec2(p0.x+size.x, p0.y+size.y), IM_COL32(231,233,242,230), 14.0f, 0, 1.0f);

    // clickable overlay
    ImGui::InvisibleButton("card", size);
    bool clicked = ImGui::IsItemClicked();

    // content layout
    ImVec2 pad(14, 12);
    ImVec2 textPos(p0.x+pad.x, p0.y+pad.y);

    dl->AddText(textPos, IM_COL32(31,36,48,255), c.title.c_str());
    dl->AddText(ImVec2(textPos.x, textPos.y+22), IM_COL32(123,129,148,255), c.when.c_str());
    dl->AddText(ImVec2(textPos.x+150, textPos.y+22), IM_COL32(123,129,148,255), c.remind.c_str());

    // pill behind date
    ImVec2 pill0(textPos.x-2, textPos.y+18);
    ImVec2 pill1(textPos.x+132, textPos.y+40);
    dl->AddRectFilled(pill0, pill1, IM_COL32(243,244,250,255), 999.0f);
    dl->AddRect(pill0, pill1, IM_COL32(231,233,242,230), 999.0f);

    // dot
    dl->AddCircleFilled(ImVec2(pill0.x+12, pill0.y+11), 3.0f, c.dot);
    dl->AddCircle(ImVec2(pill0.x+12, pill0.y+11), 6.0f, (c.dot & 0x00FFFFFF) | (ImU32)(30<<24), 0, 3.0f);

    // radio right
    ImVec2 rc(p0.x+size.x-24, p0.y+size.y*0.5f);
    dl->AddCircle(rc, 8.0f, selected ? IM_COL32(108,92,231,255) : IM_COL32(160,166,184,230), 0, 2.0f);
    if(selected){
        dl->AddCircleFilled(rc, 4.0f, IM_COL32(108,92,231,255));
    } else {
        dl->AddCircleFilled(rc, 7.0f, IM_COL32(255,255,255,255));
    }

    ImGui::Dummy(ImVec2(0, 10));
    ImGui::PopID();
    return clicked;
}

// --------------------------- Main UI ---------------------------

static void RenderUI(ImVec2 screen, float time_sec)
{
    ImDrawList* bg = ImGui::GetBackgroundDrawList();

    // Background gradients (approx)
    bg->AddRectFilled(ImVec2(0,0), screen, IM_COL32(239,238,254,255));
    // subtle overlay
    bg->AddRectFilled(ImVec2(0,0), screen, IM_COL32(233,231,246,140));

    DrawDecorBlocks(bg, screen, time_sec);

    // Center "window"
    ImVec2 winSize(std::min(1120.0f, screen.x*0.92f), std::min(610.0f, screen.y*0.86f));
    ImVec2 winPos((screen.x-winSize.x)*0.5f, (screen.y-winSize.y)*0.5f);

    // outer glass
    AddShadowRect(bg, winPos, ImVec2(winPos.x+winSize.x, winPos.y+winSize.y), 26.0f, IM_COL32(25,28,43,30), 26.0f);
    bg->AddRectFilled(winPos, ImVec2(winPos.x+winSize.x, winPos.y+winSize.y), IM_COL32(255,255,255,190), 26.0f);
    bg->AddRect(winPos, ImVec2(winPos.x+winSize.x, winPos.y+winSize.y), IM_COL32(255,255,255,120), 26.0f, 0, 1.0f);

    // inner panel
    ImVec2 innerPos(winPos.x+10, winPos.y+10);
    ImVec2 innerSize(winSize.x-20, winSize.y-20);

    ImGui::SetNextWindowPos(innerPos);
    ImGui::SetNextWindowSize(innerSize);
    ImGui::Begin("root", nullptr,
                 ImGuiWindowFlags_NoDecoration|
                 ImGuiWindowFlags_NoMove|
                 ImGuiWindowFlags_NoSavedSettings|
                 ImGuiWindowFlags_NoBringToFrontOnFocus);

    // Layout: sidebar + main
    float sidebarW = (screen.x < 720.0f) ? 0.0f : 260.0f;

    if(sidebarW > 0.0f){
        ImGui::BeginChild("sidebar", ImVec2(sidebarW, 0), true);

        // brand
        {
            ImGui::Dummy(ImVec2(0, 6));
            ImGui::BeginGroup();
            ImGui::TextUnformatted("Алиса AI");
            ImGui::TextColored(ImVec4(0.48f,0.51f,0.58f,1.0f), "ассистент");
            ImGui::EndGroup();
            ImGui::Separator();
        }

        // nav
        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 12.0f);
        if(ImGui::Selectable("Новый чат", false, 0, ImVec2(0, 34))) {}
        ImGui::Selectable("Мои планы   3", false, 0, ImVec2(0, 34));
        ImGui::PopStyleVar();

        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.63f,0.65f,0.72f,1.0f), "Сегодня");
        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 12.0f);
        ImGui::Selectable("Планы на сегодня", true, 0, ImVec2(0, 34));
        ImGui::PopStyleVar();

        ImGui::Dummy(ImVec2(0, 0));
        ImGui::SetCursorPosY(ImGui::GetWindowHeight() - 70);
        ImGui::Separator();
        ImGui::TextUnformatted("Иванов Е.");
        ImGui::TextColored(ImVec4(0.42f,0.36f,0.91f,1.0f), "Открыть профиль");

        ImGui::EndChild();
        ImGui::SameLine();
    }

    // Main
    ImGui::BeginChild("main", ImVec2(0,0), true);

    // top bar
    {
        ImGui::BeginChild("top", ImVec2(0,58), false);
        ImGui::SetCursorPosY(18);
        ImGui::SetCursorPosX(ImGui::GetWindowWidth() - 330);
        ImGui::PushStyleColor(ImGuiCol_FrameBg, IM_COL32(243,244,250,255));
        ImGui::PushStyleColor(ImGuiCol_Border,  IM_COL32(231,233,242,230));
        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 999.0f);
        ImGui::SetNextItemWidth(320);
        ImGui::InputText("##title", (char*)"Какие у меня планы на сегодня?", 1,
                         ImGuiInputTextFlags_ReadOnly);
        ImGui::PopStyleVar();
        ImGui::PopStyleColor(2);
        ImGui::EndChild();
        ImGui::Separator();
    }

    // chat area
    static float chatScrollToBottom = 1.0f;

    ImGui::BeginChild("chat", ImVec2(0, -84), false, ImGuiWindowFlags_AlwaysUseWindowPadding);

    ImGui::TextWrapped("Сегодня нужно забронировать ресторан для встречи с родителями, разобраться с ремонтом и купить подарок жене.");
    ImGui::Dummy(ImVec2(0, 6));

    float cardsW = std::min(520.0f, ImGui::GetContentRegionAvail().x);
    for(const auto& c : g_cards){
        bool sel = (g_selected_card == c.id);
        if(CardWidget(c, sel, cardsW)) g_selected_card = c.id;
    }

    // actions row (icons simplified as buttons)
    ImGui::Dummy(ImVec2(0, 4));
    ImGui::BeginGroup();
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 10.0f);
    ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(0,0,0,0));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, IM_COL32(244,245,251,255));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, IM_COL32(241,242,248,255));
    ImGui::Button("Like", ImVec2(54,26)); ImGui::SameLine();
    ImGui::Button("Dislike", ImVec2(70,26)); ImGui::SameLine();
    ImGui::Button("Copy", ImVec2(54,26)); ImGui::SameLine();
    ImGui::Button("Share", ImVec2(60,26));
    ImGui::PopStyleColor(3);
    ImGui::PopStyleVar();
    ImGui::EndGroup();

    // user messages
    ImGui::Dummy(ImVec2(0, 10));
    for(const auto& m : g_user_msgs){
        // right aligned bubble
        float bw = std::min(520.0f, ImGui::GetContentRegionAvail().x);
        float x = ImGui::GetCursorPosX() + (ImGui::GetContentRegionAvail().x - bw);
        ImGui::SetCursorPosX(x);

        ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(245,246,251,255));
        ImGui::PushStyleColor(ImGuiCol_Border,  IM_COL32(231,233,242,230));
        ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 16.0f);
        ImGui::BeginChild(ImGui::GetID(m.c_str()), ImVec2(bw, 0), true);
        ImGui::TextWrapped("%s", m.c_str());
        ImGui::EndChild();
        ImGui::PopStyleVar();
        ImGui::PopStyleColor(2);

        ImGui::Dummy(ImVec2(0, 10));
    }

    if(chatScrollToBottom > 0.5f){
        ImGui::SetScrollHereY(1.0f);
        chatScrollToBottom = 0.0f;
    }

    ImGui::EndChild();

    // composer
    ImGui::Separator();
    ImGui::BeginChild("composer", ImVec2(0, 84), false);

    static std::string input;
    static bool focusText = false;

    ImGui::SetCursorPos(ImVec2(18, 16));
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 16.0f);
    ImGui::PushStyleColor(ImGuiCol_FrameBg, IM_COL32(243,244,250,255));
    ImGui::PushStyleColor(ImGuiCol_Border,  IM_COL32(231,233,242,240));

    ImGui::BeginChild("composer_box", ImVec2(ImGui::GetWindowWidth()-36, 52), true);

    // plus
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 12.0f);
    ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(255,255,255,255));
    ImGui::PushStyleColor(ImGuiCol_Border, IM_COL32(231,233,242,240));
    if(ImGui::Button("+", ImVec2(34,34))){
        if(!input.empty()) input += "\n";
        input += "Напомни мне...";
        focusText = true;
    }
    ImGui::PopStyleColor(2);
    ImGui::PopStyleVar();
    ImGui::SameLine();

    // multiline input
    ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x - 44);
    ImGuiInputTextFlags flags = ImGuiInputTextFlags_EnterReturnsTrue;
    if(ImGui::InputTextMultiline("##ta", &input, ImVec2(-44, 34), flags)){
        // Enter pressed (without needing Shift logic here); we'll send if not empty
        // Note: ImGui doesn't provide Shift+Enter default; simplest: allow newline by button or Ctrl+Enter.
    }
    if(focusText){
        ImGui::SetKeyboardFocusHere(-1);
        focusText = false;
    }

    ImGui::SameLine();

    // send
    bool canSend = !input.empty() && std::any_of(input.begin(), input.end(), [](char ch){ return !isspace((unsigned char)ch); });
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 12.0f);
    if(!canSend) ImGui::BeginDisabled();
    ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(108,92,231,255));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, IM_COL32(124,58,237,255));
    if(ImGui::Button(">", ImVec2(34,34))){
        std::string trimmed = input;
        // trim
        while(!trimmed.empty() && isspace((unsigned char)trimmed.back())) trimmed.pop_back();
        size_t i=0; while(i<trimmed.size() && isspace((unsigned char)trimmed[i])) i++;
        trimmed = trimmed.substr(i);

        if(!trimmed.empty()){
            g_user_msgs.push_back(trimmed);
            input.clear();
            chatScrollToBottom = 1.0f;
            focusText = true;
        }
    }
    ImGui::PopStyleColor(2);
    if(!canSend) ImGui::EndDisabled();
    ImGui::PopStyleVar();

    ImGui::EndChild(); // composer_box
    ImGui::PopStyleColor(2);
    ImGui::PopStyleVar();

    ImGui::EndChild(); // composer

    ImGui::EndChild(); // main
    ImGui::End(); // root
}

// --------------------------- Entry ---------------------------

int main(int, char**)
{
    if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0)
        return 1;

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
#if __APPLE__
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
#else
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
#endif
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

    SDL_Window* window = SDL_CreateWindow("UI Replica (C++/ImGui)",
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1200, 720,
        SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);

    SDL_GLContext gl_context = SDL_GL_CreateContext(window);
    SDL_GL_MakeCurrent(window, gl_context);
    SDL_GL_SetSwapInterval(1);

    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

    PushUIStyle();

    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);
    ImGui_ImplOpenGL3_Init("#version 130");

    bool done = false;
    Uint64 start = SDL_GetPerformanceCounter();

    while(!done){
        SDL_Event event;
        while(SDL_PollEvent(&event)){
            ImGui_ImplSDL2_ProcessEvent(&event);
            if(event.type == SDL_QUIT) done = true;
            if(event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE
               && event.window.windowID == SDL_GetWindowID(window)) done = true;
        }

        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame();
        ImGui::NewFrame();

        int w,h;
        SDL_GetWindowSize(window, &w, &h);

        Uint64 now = SDL_GetPerformanceCounter();
        float t = (float)((double)(now - start) / (double)SDL_GetPerformanceFrequency());

        RenderUI(ImVec2((float)w,(float)h), t);

        ImGui::Render();
        glViewport(0,0,w,h);
        glClearColor(0,0,0,1);
        glClear(GL_COLOR_BUFFER_BIT);

        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        SDL_GL_SwapWindow(window);
    }

    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplSDL2_Shutdown();
    ImGui::DestroyContext();

    SDL_GL_DeleteContext(gl_context);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
