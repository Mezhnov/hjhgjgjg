// ============================================================================
// GTA5 RP LAUNCHER - FULL IMPLEMENTATION
// –ü–æ–ª–Ω–∞—è –∫–æ–ø–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –ª–∞—É–Ω—á–µ—Ä–∞ GTA5 RP
// –í—Å–µ –≤ –æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ, –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫ (–∫—Ä–æ–º–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö Windows API)
// ============================================================================

#define UNICODE
#define _UNICODE
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <sstream>
#include <ctime>
#include <cmath>

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "msimg32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "user32.lib")

// ============================================================================
// –ö–û–ù–°–¢–ê–ù–¢–´ –ò –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø
// ============================================================================

#define WM_UPDATE_UI (WM_USER + 1)
#define WM_ANIMATE (WM_USER + 2)
#define WM_SCROLL_CONTENT (WM_USER + 3)

#define WINDOW_WIDTH 1200
#define WINDOW_HEIGHT 700
#define SIDEBAR_WIDTH 238
#define HEADER_HEIGHT 56

#define COLOR_DARK_BG RGB(26, 26, 26)
#define COLOR_SIDEBAR_BG RGB(32, 32, 32)
#define COLOR_ORANGE RGB(255, 120, 0)
#define COLOR_ORANGE_HOVER RGB(255, 140, 30)
#define COLOR_DARK_PANEL RGB(18, 18, 18)
#define COLOR_TEXT_WHITE RGB(255, 255, 255)
#define COLOR_TEXT_GRAY RGB(160, 160, 160)
#define COLOR_BORDER RGB(60, 60, 60)

#define TIMER_ANIMATION 1
#define TIMER_PLAYER_COUNT 2
#define TIMER_CAROUSEL 3

// ============================================================================
// –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–•
// ============================================================================

struct Point {
    int x, y;
    Point() : x(0), y(0) {}
    Point(int _x, int _y) : x(_x), y(_y) {}
};

struct Rect {
    int x, y, width, height;
    Rect() : x(0), y(0), width(0), height(0) {}
    Rect(int _x, int _y, int _w, int _h) : x(_x), y(_y), width(_w), height(_h) {}
    
    bool Contains(int px, int py) const {
        return px >= x && px < x + width && py >= y && py < y + height;
    }
};

struct Color {
    BYTE r, g, b, a;
    Color() : r(0), g(0), b(0), a(255) {}
    Color(BYTE _r, BYTE _g, BYTE _b, BYTE _a = 255) : r(_r), g(_g), b(_b), a(_a) {}
    
    COLORREF ToCOLORREF() const {
        return RGB(r, g, b);
    }
    
    static Color FromRGB(COLORREF color) {
        return Color(GetRValue(color), GetGValue(color), GetBValue(color));
    }
};

struct MenuItem {
    std::wstring text;
    std::wstring icon;
    int id;
    bool selected;
    bool enabled;
    Rect bounds;
    
    MenuItem() : id(0), selected(false), enabled(true) {}
    MenuItem(const std::wstring& t, const std::wstring& i, int _id) 
        : text(t), icon(i), id(_id), selected(false), enabled(true) {}
};

struct ServerCard {
    std::wstring name;
    std::wstring number;
    std::wstring icon;
    int players;
    Rect bounds;
    bool hovered;
    
    ServerCard() : players(0), hovered(false) {}
    ServerCard(const std::wstring& n, const std::wstring& num, const std::wstring& i, int p)
        : name(n), number(num), icon(i), players(p), hovered(false) {}
};

struct MediaItem {
    std::wstring imagePath;
    std::wstring title;
    int type; // 0 - –≤—Å–µ, 1 - —Å—Ç—Ä–∏–º—ã, 2 - –≤–∏–¥–µ–æ
    HBITMAP bitmap;
    
    MediaItem() : type(0), bitmap(NULL) {}
    MediaItem(const std::wstring& img, const std::wstring& t, int tp)
        : imagePath(img), title(t), type(tp), bitmap(NULL) {}
};

struct Button {
    std::wstring text;
    Rect bounds;
    Color bgColor;
    Color hoverColor;
    Color textColor;
    bool hovered;
    bool enabled;
    int id;
    
    Button() : hovered(false), enabled(true), id(0) {}
    Button(const std::wstring& t, const Rect& r, const Color& bg, int _id)
        : text(t), bounds(r), bgColor(bg), hoverColor(bg), textColor(255, 255, 255), 
          hovered(false), enabled(true), id(_id) {}
};

// ============================================================================
// –ö–õ–ê–°–° –î–õ–Ø –†–ê–ë–û–¢–´ –° –ì–†–ê–§–ò–ö–û–ô
// ============================================================================

class Graphics {
private:
    HDC hdc;
    HBITMAP hBitmap;
    HDC memDC;
    int width, height;
    
public:
    Graphics(HDC _hdc, int w, int h) : hdc(_hdc), width(w), height(h) {
        memDC = CreateCompatibleDC(hdc);
        hBitmap = CreateCompatibleBitmap(hdc, width, height);
        SelectObject(memDC, hBitmap);
    }
    
    ~Graphics() {
        DeleteObject(hBitmap);
        DeleteDC(memDC);
    }
    
    void Clear(COLORREF color) {
        HBRUSH brush = CreateSolidBrush(color);
        RECT rect = {0, 0, width, height};
        FillRect(memDC, &rect, brush);
        DeleteObject(brush);
    }
    
    void FillRectangle(const Rect& rect, COLORREF color) {
        HBRUSH brush = CreateSolidBrush(color);
        RECT r = {rect.x, rect.y, rect.x + rect.width, rect.y + rect.height};
        FillRect(memDC, &r, brush);
        DeleteObject(brush);
    }
    
    void FillRoundRectangle(const Rect& rect, int radius, COLORREF color) {
        HBRUSH brush = CreateSolidBrush(color);
        HPEN pen = CreatePen(PS_SOLID, 1, color);
        HBRUSH oldBrush = (HBRUSH)SelectObject(memDC, brush);
        HPEN oldPen = (HPEN)SelectObject(memDC, pen);
        
        RoundRect(memDC, rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, radius, radius);
        
        SelectObject(memDC, oldBrush);
        SelectObject(memDC, oldPen);
        DeleteObject(brush);
        DeleteObject(pen);
    }
    
    void DrawRectangle(const Rect& rect, COLORREF color, int thickness = 1) {
        HPEN pen = CreatePen(PS_SOLID, thickness, color);
        HPEN oldPen = (HPEN)SelectObject(memDC, pen);
        HBRUSH oldBrush = (HBRUSH)SelectObject(memDC, GetStockObject(NULL_BRUSH));
        
        Rectangle(memDC, rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
        
        SelectObject(memDC, oldPen);
        SelectObject(memDC, oldBrush);
        DeleteObject(pen);
    }
    
    void DrawLine(int x1, int y1, int x2, int y2, COLORREF color, int thickness = 1) {
        HPEN pen = CreatePen(PS_SOLID, thickness, color);
        HPEN oldPen = (HPEN)SelectObject(memDC, pen);
        
        MoveToEx(memDC, x1, y1, NULL);
        LineTo(memDC, x2, y2);
        
        SelectObject(memDC, oldPen);
        DeleteObject(pen);
    }
    
    void DrawText(const std::wstring& text, const Rect& rect, COLORREF color, 
                  int fontSize, bool bold = false, UINT format = DT_LEFT | DT_VCENTER | DT_SINGLELINE) {
        HFONT font = CreateFont(fontSize, 0, 0, 0, bold ? FW_BOLD : FW_NORMAL,
                                FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                                OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                                L"Segoe UI");
        
        HFONT oldFont = (HFONT)SelectObject(memDC, font);
        SetTextColor(memDC, color);
        SetBkMode(memDC, TRANSPARENT);
        
        RECT r = {rect.x, rect.y, rect.x + rect.width, rect.y + rect.height};
        DrawTextW(memDC, text.c_str(), -1, &r, format);
        
        SelectObject(memDC, oldFont);
        DeleteObject(font);
    }
    
    void DrawImage(HBITMAP bitmap, const Rect& rect) {
        if (!bitmap) return;
        
        HDC hdcMem = CreateCompatibleDC(memDC);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(hdcMem, bitmap);
        
        BITMAP bm;
        GetObject(bitmap, sizeof(bm), &bm);
        
        SetStretchBltMode(memDC, HALFTONE);
        StretchBlt(memDC, rect.x, rect.y, rect.width, rect.height,
                   hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
        
        SelectObject(hdcMem, oldBitmap);
        DeleteDC(hdcMem);
    }
    
    void DrawImageWithAlpha(HBITMAP bitmap, const Rect& rect, int alpha = 255) {
        if (!bitmap) return;
        
        HDC hdcMem = CreateCompatibleDC(memDC);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(hdcMem, bitmap);
        
        BITMAP bm;
        GetObject(bitmap, sizeof(bm), &bm);
        
        BLENDFUNCTION blend = {AC_SRC_OVER, 0, (BYTE)alpha, AC_SRC_ALPHA};
        AlphaBlend(memDC, rect.x, rect.y, rect.width, rect.height,
                   hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, blend);
        
        SelectObject(hdcMem, oldBitmap);
        DeleteDC(hdcMem);
    }
    
    void DrawGradient(const Rect& rect, COLORREF color1, COLORREF color2, bool vertical = true) {
        TRIVERTEX vertex[2];
        vertex[0].x = rect.x;
        vertex[0].y = rect.y;
        vertex[0].Red = GetRValue(color1) << 8;
        vertex[0].Green = GetGValue(color1) << 8;
        vertex[0].Blue = GetBValue(color1) << 8;
        vertex[0].Alpha = 0x0000;
        
        vertex[1].x = rect.x + rect.width;
        vertex[1].y = rect.y + rect.height;
        vertex[1].Red = GetRValue(color2) << 8;
        vertex[1].Green = GetGValue(color2) << 8;
        vertex[1].Blue = GetBValue(color2) << 8;
        vertex[1].Alpha = 0x0000;
        
        GRADIENT_RECT gRect = {0, 1};
        GradientFill(memDC, vertex, 2, &gRect, 1, vertical ? GRADIENT_FILL_RECT_V : GRADIENT_FILL_RECT_H);
    }
    
    void DrawIcon(const std::wstring& iconText, const Rect& rect, COLORREF color, int fontSize) {
        DrawText(iconText, rect, color, fontSize, false, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    }
    
    void Present() {
        BitBlt(hdc, 0, 0, width, height, memDC, 0, 0, SRCCOPY);
    }
    
    HDC GetHDC() { return memDC; }
};

// ============================================================================
// –ö–õ–ê–°–° –ú–ï–ù–ï–î–ñ–ï–†–ê –†–ï–°–£–†–°–û–í
// ============================================================================

class ResourceManager {
private:
    std::map<std::wstring, HBITMAP> bitmaps;
    std::map<std::wstring, HFONT> fonts;
    
public:
    ResourceManager() {}
    
    ~ResourceManager() {
        for (auto& pair : bitmaps) {
            if (pair.second) DeleteObject(pair.second);
        }
        for (auto& pair : fonts) {
            if (pair.second) DeleteObject(pair.second);
        }
    }
    
    HBITMAP LoadBitmapFromResource(const std::wstring& name) {
        auto it = bitmaps.find(name);
        if (it != bitmaps.end()) {
            return it->second;
        }
        return NULL;
    }
    
    HBITMAP CreatePlaceholderBitmap(int width, int height, COLORREF color) {
        HDC hdc = GetDC(NULL);
        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP bitmap = CreateCompatibleBitmap(hdc, width, height);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(memDC, bitmap);
        
        HBRUSH brush = CreateSolidBrush(color);
        RECT rect = {0, 0, width, height};
        FillRect(memDC, &rect, brush);
        DeleteObject(brush);
        
        SelectObject(memDC, oldBitmap);
        DeleteDC(memDC);
        ReleaseDC(NULL, hdc);
        
        return bitmap;
    }
    
    HFONT CreateCustomFont(const std::wstring& name, int size, bool bold = false) {
        std::wstring key = name + L"_" + std::to_wstring(size) + (bold ? L"_bold" : L"");
        auto it = fonts.find(key);
        if (it != fonts.end()) {
            return it->second;
        }
        
        HFONT font = CreateFont(size, 0, 0, 0, bold ? FW_BOLD : FW_NORMAL,
                               FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                               OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                               CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                               name.c_str());
        fonts[key] = font;
        return font;
    }
};

// ============================================================================
// –ö–õ–ê–°–° –ê–ù–ò–ú–ê–¶–ò–ò
// ============================================================================

class Animation {
private:
    double startValue;
    double endValue;
    double currentValue;
    double duration;
    double elapsed;
    bool running;
    bool completed;
    
public:
    Animation() : startValue(0), endValue(0), currentValue(0), 
                  duration(0), elapsed(0), running(false), completed(false) {}
    
    void Start(double start, double end, double durationMs) {
        startValue = start;
        endValue = end;
        currentValue = start;
        duration = durationMs;
        elapsed = 0;
        running = true;
        completed = false;
    }
    
    void Update(double deltaTime) {
        if (!running) return;
        
        elapsed += deltaTime;
        if (elapsed >= duration) {
            currentValue = endValue;
            running = false;
            completed = true;
        } else {
            double t = elapsed / duration;
            // Ease in-out cubic
            t = t < 0.5 ? 4 * t * t * t : 1 - pow(-2 * t + 2, 3) / 2;
            currentValue = startValue + (endValue - startValue) * t;
        }
    }
    
    double GetValue() const { return currentValue; }
    bool IsRunning() const { return running; }
    bool IsCompleted() const { return completed; }
    void Stop() { running = false; }
};

// ============================================================================
// –ì–õ–ê–í–ù–´–ô –ö–õ–ê–°–° –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø
// ============================================================================

class GTA5RPLauncher {
private:
    HWND hwnd;
    HINSTANCE hInstance;
    ResourceManager resourceManager;
    
    // UI —ç–ª–µ–º–µ–Ω—Ç—ã
    std::vector<MenuItem> menuItems;
    std::vector<ServerCard> serverCards;
    std::vector<MediaItem> mediaItems;
    std::vector<Button> buttons;
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    int selectedMenuItem;
    int hoveredMenuItem;
    int hoveredServerCard;
    int hoveredButton;
    int currentPlayerCount;
    int mediaFilter; // 0 - –≤—Å–µ, 1 - —Å—Ç—Ä–∏–º—ã, 2 - –≤–∏–¥–µ–æ
    int carouselIndex;
    double scrollOffset;
    double targetScrollOffset;
    
    // –ê–Ω–∏–º–∞—Ü–∏–∏
    Animation scrollAnimation;
    Animation fadeAnimation;
    std::map<int, Animation> buttonAnimations;
    
    // –¢–∞–π–º–µ—Ä—ã
    DWORD lastUpdateTime;
    
    // –†–∞–∑–º–µ—Ä—ã –∏ –ø–æ–∑–∏—Ü–∏–∏
    Rect sidebarRect;
    Rect contentRect;
    Rect headerRect;
    
public:
    GTA5RPLauncher(HINSTANCE hInst) : hInstance(hInst), hwnd(NULL),
        selectedMenuItem(0), hoveredMenuItem(-1), hoveredServerCard(-1),
        hoveredButton(-1), currentPlayerCount(44620), mediaFilter(0),
        carouselIndex(0), scrollOffset(0), targetScrollOffset(0),
        lastUpdateTime(0) {
        
        InitializeMenuItems();
        InitializeServerCards();
        InitializeMediaItems();
        InitializeButtons();
    }
    
    ~GTA5RPLauncher() {
        // –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        for (auto& item : mediaItems) {
            if (item.bitmap) {
                DeleteObject(item.bitmap);
            }
        }
    }
    
    // ========================================================================
    // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
    // ========================================================================
    
    void InitializeMenuItems() {
        menuItems.push_back(MenuItem(L"–ì–ª–∞–≤–Ω–∞—è", L"üè†", 0));
        menuItems.push_back(MenuItem(L"–°–µ—Ä–≤–µ—Ä–∞", L"üñ•", 1));
        menuItems.push_back(MenuItem(L"–ù–æ–≤–æ—Å—Ç–∏", L"üì∞", 2));
        menuItems.push_back(MenuItem(L"–°–æ–æ–±—â–µ—Å—Ç–≤–∞", L"üë•", 3));
        menuItems.push_back(MenuItem(L"–ö—É–ø–∏—Ç—å GTA V", L"üõí", 4));
        
        menuItems[0].selected = true;
    }
    
    void InitializeServerCards() {
        serverCards.push_back(ServerCard(L"DEL PERRO", L"14", L"‚öô", 0));
        serverCards.push_back(ServerCard(L"LA MESA", L"10", L"üî∞", 0));
        serverCards.push_back(ServerCard(L"RAINBOW", L"07", L"üåà", 0));
    }
    
    void InitializeMediaItems() {
        // –°–æ–∑–¥–∞–µ–º placeholder –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –º–µ–¥–∏–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        for (int i = 0; i < 8; i++) {
            MediaItem item;
            item.title = L"–°—Ç—Ä–∏–º " + std::to_wstring(i + 1);
            item.type = i % 3; // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ —Ç–∏–ø–∞–º
            
            // –°–æ–∑–¥–∞–µ–º placeholder bitmap
            COLORREF colors[] = {
                RGB(60, 60, 80),
                RGB(80, 60, 60),
                RGB(60, 80, 60),
                RGB(80, 80, 60)
            };
            item.bitmap = resourceManager.CreatePlaceholderBitmap(280, 160, colors[i % 4]);
            
            mediaItems.push_back(item);
        }
    }
    
    void InitializeButtons() {
        // –ö–Ω–æ–ø–∫–∞ "–ö—É–ø–∏—Ç—å"
        Button buyButton;
        buyButton.text = L"–ö—É–ø–∏—Ç—å";
        buyButton.bounds = Rect(945, 118, 200, 50);
        buyButton.bgColor = Color(255, 120, 0);
        buyButton.hoverColor = Color(255, 140, 30);
        buyButton.id = 100;
        buttons.push_back(buyButton);
        
        // –ö–Ω–æ–ø–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –º–µ–¥–∏–∞
        Button allButton;
        allButton.text = L"–í—Å–µ";
        allButton.bounds = Rect(258, 527, 85, 35);
        allButton.bgColor = Color(255, 120, 0);
        allButton.hoverColor = Color(255, 140, 30);
        allButton.id = 200;
        buttons.push_back(allButton);
        
        Button streamsButton;
        streamsButton.text = L"–°—Ç—Ä–∏–º—ã";
        streamsButton.bounds = Rect(348, 527, 85, 35);
        streamsButton.bgColor = Color(40, 40, 40);
        streamsButton.hoverColor = Color(60, 60, 60);
        streamsButton.id = 201;
        buttons.push_back(streamsButton);
        
        Button videosButton;
        videosButton.text = L"–í–∏–¥–µ–æ";
        videosButton.bounds = Rect(438, 527, 85, 35);
        videosButton.bgColor = Color(40, 40, 40);
        videosButton.hoverColor = Color(60, 60, 60);
        videosButton.id = 202;
        buttons.push_back(videosButton);
    }
    
    // ========================================================================
    // –°–û–ó–î–ê–ù–ò–ï –û–ö–ù–ê
    // ========================================================================
    
    bool CreateMainWindow() {
        WNDCLASSEXW wc = {0};
        wc.cbSize = sizeof(WNDCLASSEXW);
        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = StaticWindowProc;
        wc.hInstance = hInstance;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = CreateSolidBrush(COLOR_DARK_BG);
        wc.lpszClassName = L"GTA5RPLauncherClass";
        wc.cbWndExtra = sizeof(GTA5RPLauncher*);
        
        if (!RegisterClassExW(&wc)) {
            return false;
        }
        
        DWORD style = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
        RECT rect = {0, 0, WINDOW_WIDTH, WINDOW_HEIGHT};
        AdjustWindowRect(&rect, style, FALSE);
        
        hwnd = CreateWindowExW(
            0,
            L"GTA5RPLauncherClass",
            L"GTA5 RP Launcher",
            style,
            CW_USEDEFAULT, CW_USEDEFAULT,
            rect.right - rect.left,
            rect.bottom - rect.top,
            NULL, NULL, hInstance, this
        );
        
        if (!hwnd) {
            return false;
        }
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –æ–±—ä–µ–∫—Ç
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)this);
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ–±–ª–∞—Å—Ç–∏
        sidebarRect = Rect(0, 0, SIDEBAR_WIDTH, WINDOW_HEIGHT);
        headerRect = Rect(SIDEBAR_WIDTH, 0, WINDOW_WIDTH - SIDEBAR_WIDTH, HEADER_HEIGHT);
        contentRect = Rect(SIDEBAR_WIDTH, HEADER_HEIGHT, 
                          WINDOW_WIDTH - SIDEBAR_WIDTH, 
                          WINDOW_HEIGHT - HEADER_HEIGHT);
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–µ–Ω—é
        int menuY = 125;
        for (size_t i = 0; i < menuItems.size(); i++) {
            menuItems[i].bounds = Rect(0, menuY, SIDEBAR_WIDTH, 42);
            menuY += 42;
        }
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –∫–∞—Ä—Ç–æ—á–µ–∫ —Å–µ—Ä–≤–µ—Ä–æ–≤
        int cardX = 258;
        for (size_t i = 0; i < serverCards.size(); i++) {
            serverCards[i].bounds = Rect(cardX, 308, 300, 140);
            cardX += 315;
        }
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä—ã
        SetTimer(hwnd, TIMER_ANIMATION, 16, NULL); // ~60 FPS
        SetTimer(hwnd, TIMER_PLAYER_COUNT, 5000, NULL); // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞ –∏–≥—Ä–æ–∫–æ–≤
        SetTimer(hwnd, TIMER_CAROUSEL, 3000, NULL); // –ö–∞—Ä—É—Å–µ–ª—å –º–µ–¥–∏–∞
        
        lastUpdateTime = GetTickCount();
        
        ShowWindow(hwnd, SW_SHOW);
        UpdateWindow(hwnd);
        
        return true;
    }
    
    // ========================================================================
    // –û–ë–†–ê–ë–û–¢–ö–ê –°–û–û–ë–©–ï–ù–ò–ô
    // ========================================================================
    
    static LRESULT CALLBACK StaticWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        GTA5RPLauncher* launcher = nullptr;
        
        if (msg == WM_NCCREATE) {
            CREATESTRUCT* cs = (CREATESTRUCT*)lParam;
            launcher = (GTA5RPLauncher*)cs->lpCreateParams;
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)launcher);
        } else {
            launcher = (GTA5RPLauncher*)GetWindowLongPtr(hwnd, 0);
        }
        
        if (launcher) {
            return launcher->WindowProc(hwnd, msg, wParam, lParam);
        }
        
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    
    LRESULT WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        switch (msg) {
            case WM_CREATE:
                return 0;
                
            case WM_PAINT: {
                PAINTSTRUCT ps;
                HDC hdc = BeginPaint(hwnd, &ps);
                OnPaint(hdc);
                EndPaint(hwnd, &ps);
                return 0;
            }
            
            case WM_ERASEBKGND:
                return 1; // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –º–µ—Ä—Ü–∞–Ω–∏–µ
                
            case WM_MOUSEMOVE: {
                int x = GET_X_LPARAM(lParam);
                int y = GET_Y_LPARAM(lParam);
                OnMouseMove(x, y);
                return 0;
            }
            
            case WM_LBUTTONDOWN: {
                int x = GET_X_LPARAM(lParam);
                int y = GET_Y_LPARAM(lParam);
                OnMouseClick(x, y);
                return 0;
            }
            
            case WM_MOUSEWHEEL: {
                int delta = GET_WHEEL_DELTA_WPARAM(wParam);
                OnMouseWheel(delta);
                return 0;
            }
            
            case WM_TIMER: {
                OnTimer(wParam);
                return 0;
            }
            
            case WM_DESTROY:
                KillTimer(hwnd, TIMER_ANIMATION);
                KillTimer(hwnd, TIMER_PLAYER_COUNT);
                KillTimer(hwnd, TIMER_CAROUSEL);
                PostQuitMessage(0);
                return 0;
        }
        
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    
    // ========================================================================
    // –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô
    // ========================================================================
    
    void OnPaint(HDC hdc) {
        Graphics g(hdc, WINDOW_WIDTH, WINDOW_HEIGHT);
        
        // –û—á–∏—â–∞–µ–º —Ñ–æ–Ω
        g.Clear(COLOR_DARK_BG);
        
        // –†–∏—Å—É–µ–º –±–æ–∫–æ–≤—É—é –ø–∞–Ω–µ–ª—å
        DrawSidebar(g);
        
        // –†–∏—Å—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
        DrawHeader(g);
        
        // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø—É–Ω–∫—Ç–∞ –º–µ–Ω—é
        switch (selectedMenuItem) {
            case 0:
                DrawMainPage(g);
                break;
            case 1:
                DrawServersPage(g);
                break;
            case 2:
                DrawNewsPage(g);
                break;
            case 3:
                DrawCommunitiesPage(g);
                break;
            case 4:
                DrawBuyPage(g);
                break;
        }
        
        g.Present();
    }
    
    void OnMouseMove(int x, int y) {
        bool needRedraw = false;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–≤–µ–¥–µ–Ω–∏–µ –Ω–∞ –ø—É–Ω–∫—Ç—ã –º–µ–Ω—é
        int oldHovered = hoveredMenuItem;
        hoveredMenuItem = -1;
        for (size_t i = 0; i < menuItems.size(); i++) {
            if (menuItems[i].bounds.Contains(x, y)) {
                hoveredMenuItem = i;
                break;
            }
        }
        if (oldHovered != hoveredMenuItem) needRedraw = true;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–≤–µ–¥–µ–Ω–∏–µ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–∏ —Å–µ—Ä–≤–µ—Ä–æ–≤
        int oldHoveredCard = hoveredServerCard;
        hoveredServerCard = -1;
        for (size_t i = 0; i < serverCards.size(); i++) {
            serverCards[i].hovered = serverCards[i].bounds.Contains(x, y);
            if (serverCards[i].hovered) {
                hoveredServerCard = i;
            }
        }
        if (oldHoveredCard != hoveredServerCard) needRedraw = true;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–≤–µ–¥–µ–Ω–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫–∏
        int oldHoveredButton = hoveredButton;
        hoveredButton = -1;
        for (size_t i = 0; i < buttons.size(); i++) {
            buttons[i].hovered = buttons[i].bounds.Contains(x, y);
            if (buttons[i].hovered) {
                hoveredButton = i;
            }
        }
        if (oldHoveredButton != hoveredButton) needRedraw = true;
        
        if (needRedraw) {
            InvalidateRect(hwnd, NULL, FALSE);
        }
    }
    
    void OnMouseClick(int x, int y) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –ø–æ –ø—É–Ω–∫—Ç–∞–º –º–µ–Ω—é
        for (size_t i = 0; i < menuItems.size(); i++) {
            if (menuItems[i].bounds.Contains(x, y)) {
                if (selectedMenuItem != i) {
                    menuItems[selectedMenuItem].selected = false;
                    selectedMenuItem = i;
                    menuItems[i].selected = true;
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                return;
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –ø–æ –∫–Ω–æ–ø–∫–∞–º
        for (size_t i = 0; i < buttons.size(); i++) {
            if (buttons[i].bounds.Contains(x, y)) {
                OnButtonClick(buttons[i].id);
                return;
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –ø–æ –∫–∞—Ä—Ç–æ—á–∫–∞–º —Å–µ—Ä–≤–µ—Ä–æ–≤
        for (size_t i = 0; i < serverCards.size(); i++) {
            if (serverCards[i].bounds.Contains(x, y)) {
                OnServerCardClick(i);
                return;
            }
        }
    }
    
    void OnMouseWheel(int delta) {
        targetScrollOffset += (delta > 0 ? 50 : -50);
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Å–∫—Ä–æ–ª–ª
        if (targetScrollOffset > 0) targetScrollOffset = 0;
        double maxScroll = -500; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –≤–Ω–∏–∑
        if (targetScrollOffset < maxScroll) targetScrollOffset = maxScroll;
        
        scrollAnimation.Start(scrollOffset, targetScrollOffset, 300);
    }
    
    void OnTimer(WPARAM timerId) {
        switch (timerId) {
            case TIMER_ANIMATION: {
                DWORD currentTime = GetTickCount();
                double deltaTime = (currentTime - lastUpdateTime);
                lastUpdateTime = currentTime;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏–∏
                scrollAnimation.Update(deltaTime);
                if (scrollAnimation.IsRunning()) {
                    scrollOffset = scrollAnimation.GetValue();
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                
                fadeAnimation.Update(deltaTime);
                
                for (auto& pair : buttonAnimations) {
                    pair.second.Update(deltaTime);
                }
                
                break;
            }
            
            case TIMER_PLAYER_COUNT: {
                // –°–∏–º—É–ª–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏–≥—Ä–æ–∫–æ–≤
                currentPlayerCount += (rand() % 21 - 10); // -10 –¥–æ +10
                if (currentPlayerCount < 40000) currentPlayerCount = 40000;
                if (currentPlayerCount > 50000) currentPlayerCount = 50000;
                InvalidateRect(hwnd, &headerRect, FALSE);
                break;
            }
            
            case TIMER_CAROUSEL: {
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –∫–∞—Ä—É—Å–µ–ª–∏
                carouselIndex = (carouselIndex + 1) % 8;
                InvalidateRect(hwnd, NULL, FALSE);
                break;
            }
        }
    }
    
    void OnButtonClick(int buttonId) {
        switch (buttonId) {
            case 100: // –ö–Ω–æ–ø–∫–∞ "–ö—É–ø–∏—Ç—å"
                MessageBoxW(hwnd, L"–ü–µ—Ä–µ—Ö–æ–¥ –≤ –º–∞–≥–∞–∑–∏–Ω...", L"GTA5 RP", MB_OK | MB_ICONINFORMATION);
                break;
                
            case 200: // –§–∏–ª—å—Ç—Ä "–í—Å–µ"
                mediaFilter = 0;
                UpdateMediaFilterButtons();
                InvalidateRect(hwnd, NULL, FALSE);
                break;
                
            case 201: // –§–∏–ª—å—Ç—Ä "–°—Ç—Ä–∏–º—ã"
                mediaFilter = 1;
                UpdateMediaFilterButtons();
                InvalidateRect(hwnd, NULL, FALSE);
                break;
                
            case 202: // –§–∏–ª—å—Ç—Ä "–í–∏–¥–µ–æ"
                mediaFilter = 2;
                UpdateMediaFilterButtons();
                InvalidateRect(hwnd, NULL, FALSE);
                break;
        }
    }
    
    void OnServerCardClick(int index) {
        std::wstring message = L"–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É " + serverCards[index].name + L"...";
        MessageBoxW(hwnd, message.c_str(), L"GTA5 RP", MB_OK | MB_ICONINFORMATION);
    }
    
    void UpdateMediaFilterButtons() {
        for (size_t i = 0; i < buttons.size(); i++) {
            if (buttons[i].id >= 200 && buttons[i].id <= 202) {
                int filterIndex = buttons[i].id - 200;
                if (filterIndex == mediaFilter) {
                    buttons[i].bgColor = Color(255, 120, 0);
                    buttons[i].hoverColor = Color(255, 140, 30);
                } else {
                    buttons[i].bgColor = Color(40, 40, 40);
                    buttons[i].hoverColor = Color(60, 60, 60);
                }
            }
        }
    }
    
    // ========================================================================
    // –û–¢–†–ò–°–û–í–ö–ê –ö–û–ú–ü–û–ù–ï–ù–¢–û–í
    // ========================================================================
    
    void DrawSidebar(Graphics& g) {
        // –§–æ–Ω –±–æ–∫–æ–≤–æ–π –ø–∞–Ω–µ–ª–∏
        g.FillRectangle(sidebarRect, COLOR_SIDEBAR_BG);
        
        // –õ–æ–≥–æ—Ç–∏–ø
        Rect logoRect(20, 20, 200, 80);
        g.DrawText(L"‚òÖ GTA5 RP", logoRect, COLOR_ORANGE, 24, true, DT_LEFT | DT_VCENTER);
        
        // –ü—É–Ω–∫—Ç—ã –º–µ–Ω—é
        for (size_t i = 0; i < menuItems.size(); i++) {
            DrawMenuItem(g, menuItems[i], i == hoveredMenuItem);
        }
        
        // –ù–∏–∂–Ω—è—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        Rect versionRect(20, WINDOW_HEIGHT - 40, 200, 30);
        g.DrawText(L"–í–µ—Ä—Å–∏—è 2.0.1", versionRect, COLOR_TEXT_GRAY, 12, false, DT_LEFT | DT_VCENTER);
    }
    
    void DrawMenuItem(Graphics& g, const MenuItem& item, bool hovered) {
        COLORREF bgColor = item.selected ? COLOR_ORANGE : 
                          (hovered ? RGB(45, 45, 45) : COLOR_SIDEBAR_BG);
        
        if (item.selected || hovered) {
            g.FillRectangle(item.bounds, bgColor);
        }
        
        // –ò–∫–æ–Ω–∫–∞
        Rect iconRect(item.bounds.x + 20, item.bounds.y, 30, item.bounds.height);
        g.DrawText(item.icon, iconRect, COLOR_TEXT_WHITE, 20, false, DT_LEFT | DT_VCENTER);
        
        // –¢–µ–∫—Å—Ç
        Rect textRect(item.bounds.x + 55, item.bounds.y, item.bounds.width - 55, item.bounds.height);
        g.DrawText(item.text, textRect, COLOR_TEXT_WHITE, 14, false, DT_LEFT | DT_VCENTER);
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤—ã–±–æ—Ä–∞
        if (item.selected) {
            g.FillRectangle(Rect(0, item.bounds.y, 4, item.bounds.height), COLOR_ORANGE);
        }
    }
    
    void DrawHeader(Graphics& g) {
        // –§–æ–Ω –∑–∞–≥–æ–ª–æ–≤–∫–∞
        g.FillRectangle(headerRect, COLOR_DARK_PANEL);
        
        // –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
        g.DrawLine(headerRect.x, headerRect.y + headerRect.height - 1,
                  headerRect.x + headerRect.width, headerRect.y + headerRect.height - 1,
                  COLOR_BORDER);
        
        // –°—á–µ—Ç—á–∏–∫ –∏–≥—Ä–æ–∫–æ–≤
        Rect playerCountRect(headerRect.x + 20, headerRect.y, 200, headerRect.height);
        std::wstring playerText = L"–°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç: " + FormatNumber(currentPlayerCount);
        g.DrawText(playerText, playerCountRect, COLOR_TEXT_GRAY, 14, false, DT_LEFT | DT_VCENTER);
        
        // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–∫–Ω–æ–º (–º–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è, –∑–∞–∫—Ä—ã—Ç–∏–µ)
        DrawWindowControls(g);
    }
    
    void DrawWindowControls(Graphics& g) {
        int buttonSize = 46;
        int x = WINDOW_WIDTH - buttonSize * 2 - 10;
        int y = 5;
        
        // –ö–Ω–æ–ø–∫–∞ –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏
        Rect minRect(x, y, buttonSize, buttonSize);
        g.DrawText(L"‚Äî", minRect, COLOR_TEXT_GRAY, 16, false, DT_CENTER | DT_VCENTER);
        
        // –ö–Ω–æ–ø–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
        Rect closeRect(x + buttonSize, y, buttonSize, buttonSize);
        g.DrawText(L"‚úï", closeRect, COLOR_TEXT_GRAY, 16, false, DT_CENTER | DT_VCENTER);
    }
    
    void DrawMainPage(Graphics& g) {
        int offsetY = (int)scrollOffset;
        
        // –ë–æ–ª—å—à–æ–π –±–∞–Ω–Ω–µ—Ä "–ï—â–µ –Ω–µ—Ç GTA V?"
        DrawMainBanner(g, offsetY);
        
        // –°–µ–∫—Ü–∏—è "–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤"
        DrawRecommendedServers(g, offsetY);
        
        // –°–µ–∫—Ü–∏—è "–ò–≥—Ä–∞–π –∏ —Å–º–æ—Ç—Ä–∏"
        DrawMediaSection(g, offsetY);
    }
    
    void DrawMainBanner(Graphics& g, int offsetY) {
        Rect bannerRect(258, 58 + offsetY, 924, 172);
        
        // –§–æ–Ω –±–∞–Ω–Ω–µ—Ä–∞ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
        g.DrawGradient(bannerRect, RGB(30, 30, 40), RGB(20, 20, 30), false);
        
        // –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –¥–ª—è —Ç–µ–∫—Å—Ç–∞
        Rect overlayRect(bannerRect.x, bannerRect.y, bannerRect.width, bannerRect.height);
        g.FillRectangle(overlayRect, RGB(0, 0, 0)); // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
        
        // –ó–∞–≥–æ–ª–æ–≤–æ–∫
        Rect titleRect(bannerRect.x + 30, bannerRect.y + 30, 600, 50);
        g.DrawText(L"–ï—â–µ –Ω–µ—Ç GTA V?", titleRect, COLOR_TEXT_WHITE, 36, true, DT_LEFT | DT_VCENTER);
        
        // –ü–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫
        Rect subtitleRect(bannerRect.x + 30, bannerRect.y + 85, 600, 40);
        g.DrawText(L"–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ –∫–ª—é—á –¥–ª—è", subtitleRect, COLOR_TEXT_GRAY, 16, false, DT_LEFT | DT_TOP);
        g.DrawText(L"Rockstar Games Launcher", Rect(bannerRect.x + 30, bannerRect.y + 105, 600, 40), 
                  COLOR_TEXT_GRAY, 16, false, DT_LEFT | DT_TOP);
        
        // –ö–Ω–æ–ø–∫–∞ "–ö—É–ø–∏—Ç—å"
        DrawButton(g, buttons[0]);
    }
    
    void DrawRecommendedServers(Graphics& g, int offsetY) {
        // –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–µ–∫—Ü–∏–∏
        Rect titleRect(258, 250 + offsetY, 900, 40);
        g.DrawText(L"–†–ï–ö–û–ú–ï–ù–î–£–ï–ú –î–õ–Ø –ù–û–í–ò–ß–ö–û–í", titleRect, COLOR_TEXT_WHITE, 20, true, DT_LEFT | DT_VCENTER);
        
        // –ö–∞—Ä—Ç–æ—á–∫–∏ —Å–µ—Ä–≤–µ—Ä–æ–≤
        for (size_t i = 0; i < serverCards.size(); i++) {
            Rect cardRect = serverCards[i].bounds;
            cardRect.y += offsetY;
            DrawServerCard(g, serverCards[i], cardRect);
        }
    }
    
    void DrawServerCard(Graphics& g, const ServerCard& card, const Rect& rect) {
        // –§–æ–Ω –∫–∞—Ä—Ç–æ—á–∫–∏
        COLORREF bgColor = card.hovered ? RGB(35, 35, 35) : RGB(28, 28, 28);
        g.FillRoundRectangle(rect, 8, bgColor);
        
        // –†–∞–º–∫–∞ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
        if (card.hovered) {
            g.DrawRectangle(rect, COLOR_ORANGE, 2);
        }
        
        // –ò–∫–æ–Ω–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞
        Rect iconRect(rect.x + 20, rect.y + 20, 40, 40);
        g.DrawText(card.icon, iconRect, COLOR_ORANGE, 32, false, DT_CENTER | DT_VCENTER);
        
        // –ù–æ–º–µ—Ä —Å–µ—Ä–≤–µ—Ä–∞
        Rect numberRect(rect.x + 20, rect.y + 15, 50, 30);
        g.DrawText(card.number, numberRect, COLOR_TEXT_WHITE, 24, true, DT_LEFT | DT_TOP);
        
        // –ò–∫–æ–Ω–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫
        Rect settingsRect(rect.x + 35, rect.y + 15, 30, 30);
        g.DrawText(card.icon, settingsRect, COLOR_TEXT_GRAY, 20, false, DT_CENTER | DT_VCENTER);
        
        // –ù–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞
        Rect nameRect(rect.x + 20, rect.y + 70, rect.width - 40, 40);
        g.DrawText(card.name, nameRect, COLOR_TEXT_WHITE, 22, true, DT_LEFT | DT_VCENTER);
        
        // –ö–Ω–æ–ø–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
        Rect playButtonRect(rect.x + rect.width - 60, rect.y + rect.height / 2 - 20, 40, 40);
        g.FillRoundRectangle(playButtonRect, 20, COLOR_ORANGE);
        g.DrawText(L"‚ñ∂", Rect(playButtonRect.x + 5, playButtonRect.y, 30, 40), 
                  COLOR_TEXT_WHITE, 20, false, DT_CENTER | DT_VCENTER);
    }
    
    void DrawMediaSection(Graphics& g, int offsetY) {
        // –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–µ–∫—Ü–∏–∏
        Rect titleRect(258, 470 + offsetY, 900, 40);
        g.DrawText(L"–ò–ì–†–ê–ô –ò –°–ú–û–¢–†–ò", titleRect, COLOR_TEXT_WHITE, 20, true, DT_LEFT | DT_VCENTER);
        
        // –ö–Ω–æ–ø–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤
        for (size_t i = 1; i < 4; i++) {
            Rect btnRect = buttons[i].bounds;
            btnRect.y += offsetY;
            DrawButton(g, buttons[i], btnRect);
        }
        
        // –°–µ—Ç–∫–∞ –º–µ–¥–∏–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        DrawMediaGrid(g, offsetY);
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∫–∞—Ä—É—Å–µ–ª–∏
        DrawCarouselIndicators(g, offsetY);
    }
    
    void DrawMediaGrid(Graphics& g, int offsetY) {
        int startX = 258;
        int startY = 575 + offsetY;
        int itemWidth = 280;
        int itemHeight = 160;
        int spacing = 15;
        int columns = 4;
        int rows = 2;
        
        int visibleCount = 0;
        for (size_t i = 0; i < mediaItems.size() && visibleCount < columns * rows; i++) {
            if (mediaFilter == 0 || mediaItems[i].type == mediaFilter) {
                int col = visibleCount % columns;
                int row = visibleCount / columns;
                
                Rect itemRect(
                    startX + col * (itemWidth + spacing),
                    startY + row * (itemHeight + spacing),
                    itemWidth,
                    itemHeight
                );
                
                DrawMediaItem(g, mediaItems[i], itemRect);
                visibleCount++;
            }
        }
    }
    
    void DrawMediaItem(Graphics& g, const MediaItem& item, const Rect& rect) {
        // –§–æ–Ω
        g.FillRoundRectangle(rect, 8, RGB(40, 40, 40));
        
        // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        if (item.bitmap) {
            g.DrawImage(item.bitmap, rect);
        }
        
        // –û–≤–µ—Ä–ª–µ–π –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
        // (–∑–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞–≤–µ–¥–µ–Ω–∏—è –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫—É –æ–≤–µ—Ä–ª–µ—è)
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä "LIVE" –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤
        if (item.type == 1) {
            Rect liveRect(rect.x + 10, rect.y + 10, 50, 25);
            g.FillRoundRectangle(liveRect, 4, RGB(255, 0, 0));
            g.DrawText(L"LIVE", liveRect, COLOR_TEXT_WHITE, 12, true, DT_CENTER | DT_VCENTER);
        }
    }
    
    void DrawCarouselIndicators(Graphics& g, int offsetY) {
        int startX = 258 + (280 * 4 + 15 * 3) / 2 - 60;
        int y = 900 + offsetY;
        int indicatorSize = 10;
        int spacing = 15;
        
        for (int i = 0; i < 8; i++) {
            Rect indicatorRect(startX + i * spacing, y, indicatorSize, indicatorSize);
            COLORREF color = (i == carouselIndex % 8) ? COLOR_ORANGE : COLOR_TEXT_GRAY;
            g.FillRoundRectangle(indicatorRect, indicatorSize / 2, color);
        }
    }
    
    void DrawButton(Graphics& g, const Button& button) {
        DrawButton(g, button, button.bounds);
    }
    
    void DrawButton(Graphics& g, const Button& button, const Rect& rect) {
        // –§–æ–Ω –∫–Ω–æ–ø–∫–∏
        COLORREF bgColor = button.hovered ? button.hoverColor.ToCOLORREF() : button.bgColor.ToCOLORREF();
        g.FillRoundRectangle(rect, 6, bgColor);
        
        // –¢–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏
        g.DrawText(button.text, rect, button.textColor.ToCOLORREF(), 16, true, DT_CENTER | DT_VCENTER);
    }
    
    void DrawServersPage(Graphics& g) {
        Rect titleRect(258, 80, 900, 50);
        g.DrawText(L"–°–ü–ò–°–û–ö –°–ï–†–í–ï–†–û–í", titleRect, COLOR_TEXT_WHITE, 28, true, DT_LEFT | DT_VCENTER);
        
        // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–µ—Ä–æ–≤
        Rect infoRect(258, 150, 900, 400);
        g.DrawText(L"–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –∏–≥—Ä—ã...", infoRect, COLOR_TEXT_GRAY, 18, false, DT_LEFT | DT_TOP);
    }
    
    void DrawNewsPage(Graphics& g) {
        Rect titleRect(258, 80, 900, 50);
        g.DrawText(L"–ù–û–í–û–°–¢–ò", titleRect, COLOR_TEXT_WHITE, 28, true, DT_LEFT | DT_VCENTER);
        
        Rect infoRect(258, 150, 900, 400);
        g.DrawText(L"–ü–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è...", infoRect, COLOR_TEXT_GRAY, 18, false, DT_LEFT | DT_TOP);
    }
    
    void DrawCommunitiesPage(Graphics& g) {
        Rect titleRect(258, 80, 900, 50);
        g.DrawText(L"–°–û–û–ë–©–ï–°–¢–í–ê", titleRect, COLOR_TEXT_WHITE, 28, true, DT_LEFT | DT_VCENTER);
        
        Rect infoRect(258, 150, 900, 400);
        g.DrawText(L"–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞—à–∏–º —Å–æ–æ–±—â–µ—Å—Ç–≤–∞–º...", infoRect, COLOR_TEXT_GRAY, 18, false, DT_LEFT | DT_TOP);
    }
    
    void DrawBuyPage(Graphics& g) {
        Rect titleRect(258, 80, 900, 50);
        g.DrawText(L"–ö–£–ü–ò–¢–¨ GTA V", titleRect, COLOR_TEXT_WHITE, 28, true, DT_LEFT | DT_VCENTER);
        
        Rect infoRect(258, 150, 900, 400);
        g.DrawText(L"–ü—Ä–∏–æ–±—Ä–µ—Ç–∏—Ç–µ –∏–≥—Ä—É –≤ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–º –º–∞–≥–∞–∑–∏–Ω–µ...", infoRect, COLOR_TEXT_GRAY, 18, false, DT_LEFT | DT_TOP);
    }
    
    // ========================================================================
    // –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
    // ========================================================================
    
    std::wstring FormatNumber(int number) {
        std::wstring str = std::to_wstring(number);
        std::wstring result;
        int count = 0;
        
        for (int i = str.length() - 1; i >= 0; i--) {
            if (count == 3) {
                result = L" " + result;
                count = 0;
            }
            result = str[i] + result;
            count++;
        }
        
        return result;
    }
    
    // ========================================================================
    // –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ
    // ========================================================================
    
    int Run() {
        MSG msg = {0};
        
        while (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        
        return (int)msg.wParam;
    }
};

// ============================================================================
// –¢–û–ß–ö–ê –í–•–û–î–ê
// ============================================================================

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow) {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&icex);
    
    // –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    GTA5RPLauncher launcher(hInstance);
    
    if (!launcher.CreateMainWindow()) {
        MessageBoxW(NULL, L"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –æ–∫–Ω–æ!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONERROR);
        return 1;
    }
    
    return launcher.Run();
}

// ============================================================================
// –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ –ò –§–£–ù–ö–¶–ò–ò
// ============================================================================

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
class ImageLoader {
public:
    static HBITMAP LoadFromFile(const std::wstring& filename) {
        // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–∞
        HBITMAP bitmap = (HBITMAP)LoadImageW(NULL, filename.c_str(), IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
        return bitmap;
    }
    
    static HBITMAP CreateFromColor(int width, int height, COLORREF color) {
        HDC hdc = GetDC(NULL);
        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP bitmap = CreateCompatibleBitmap(hdc, width, height);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(memDC, bitmap);
        
        HBRUSH brush = CreateSolidBrush(color);
        RECT rect = {0, 0, width, height};
        FillRect(memDC, &rect, brush);
        DeleteObject(brush);
        
        SelectObject(memDC, oldBitmap);
        DeleteDC(memDC);
        ReleaseDC(NULL, hdc);
        
        return bitmap;
    }
    
    static HBITMAP ResizeBitmap(HBITMAP source, int newWidth, int newHeight) {
        if (!source) return NULL;
        
        HDC hdcScreen = GetDC(NULL);
        HDC hdcSrc = CreateCompatibleDC(hdcScreen);
        HDC hdcDst = CreateCompatibleDC(hdcScreen);
        
        BITMAP bm;
        GetObject(source, sizeof(bm), &bm);
        
        HBITMAP newBitmap = CreateCompatibleBitmap(hdcScreen, newWidth, newHeight);
        
        HBITMAP oldSrc = (HBITMAP)SelectObject(hdcSrc, source);
        HBITMAP oldDst = (HBITMAP)SelectObject(hdcDst, newBitmap);
        
        SetStretchBltMode(hdcDst, HALFTONE);
        StretchBlt(hdcDst, 0, 0, newWidth, newHeight, hdcSrc, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
        
        SelectObject(hdcSrc, oldSrc);
        SelectObject(hdcDst, oldDst);
        
        DeleteDC(hdcSrc);
        DeleteDC(hdcDst);
        ReleaseDC(NULL, hdcScreen);
        
        return newBitmap;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ —à—Ä–∏—Ñ—Ç–∞–º–∏
class FontManager {
private:
    std::map<std::wstring, HFONT> fonts;
    
public:
    ~FontManager() {
        for (auto& pair : fonts) {
            DeleteObject(pair.second);
        }
    }
    
    HFONT GetFont(const std::wstring& name, int size, bool bold = false, bool italic = false) {
        std::wstring key = name + L"_" + std::to_wstring(size) + 
                          (bold ? L"_b" : L"") + (italic ? L"_i" : L"");
        
        auto it = fonts.find(key);
        if (it != fonts.end()) {
            return it->second;
        }
        
        HFONT font = CreateFont(
            size, 0, 0, 0,
            bold ? FW_BOLD : FW_NORMAL,
            italic ? TRUE : FALSE,
            FALSE, FALSE,
            DEFAULT_CHARSET,
            OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS,
            CLEARTYPE_QUALITY,
            DEFAULT_PITCH | FF_DONTCARE,
            name.c_str()
        );
        
        fonts[key] = font;
        return font;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∞–Ω–∏–º–∞—Ü–∏—è–º–∏
class AnimationManager {
private:
    struct AnimationState {
        double startValue;
        double endValue;
        double currentValue;
        double duration;
        double elapsed;
        bool active;
        int easingType; // 0 - linear, 1 - ease-in, 2 - ease-out, 3 - ease-in-out
    };
    
    std::map<std::wstring, AnimationState> animations;
    
public:
    void StartAnimation(const std::wstring& name, double start, double end, double duration, int easing = 3) {
        AnimationState state;
        state.startValue = start;
        state.endValue = end;
        state.currentValue = start;
        state.duration = duration;
        state.elapsed = 0;
        state.active = true;
        state.easingType = easing;
        
        animations[name] = state;
    }
    
    void Update(double deltaTime) {
        for (auto& pair : animations) {
            if (!pair.second.active) continue;
            
            pair.second.elapsed += deltaTime;
            
            if (pair.second.elapsed >= pair.second.duration) {
                pair.second.currentValue = pair.second.endValue;
                pair.second.active = false;
            } else {
                double t = pair.second.elapsed / pair.second.duration;
                t = ApplyEasing(t, pair.second.easingType);
                pair.second.currentValue = pair.second.startValue + 
                                          (pair.second.endValue - pair.second.startValue) * t;
            }
        }
    }
    
    double GetValue(const std::wstring& name) {
        auto it = animations.find(name);
        if (it != animations.end()) {
            return it->second.currentValue;
        }
        return 0;
    }
    
    bool IsActive(const std::wstring& name) {
        auto it = animations.find(name);
        return it != animations.end() && it->second.active;
    }
    
private:
    double ApplyEasing(double t, int type) {
        switch (type) {
            case 0: // Linear
                return t;
            case 1: // Ease-in
                return t * t;
            case 2: // Ease-out
                return t * (2 - t);
            case 3: // Ease-in-out
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            default:
                return t;
        }
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–µ—Ç—å—é (–∑–∞–≥–ª—É—à–∫–∞)
class NetworkManager {
public:
    struct ServerInfo {
        std::wstring name;
        std::wstring ip;
        int port;
        int players;
        int maxPlayers;
        int ping;
    };
    
    std::vector<ServerInfo> GetServerList() {
        std::vector<ServerInfo> servers;
        
        // –ó–∞–≥–ª—É—à–∫–∞ - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        ServerInfo server1;
        server1.name = L"DEL PERRO";
        server1.ip = L"127.0.0.1";
        server1.port = 22005;
        server1.players = 450;
        server1.maxPlayers = 500;
        server1.ping = 25;
        servers.push_back(server1);
        
        ServerInfo server2;
        server2.name = L"LA MESA";
        server2.ip = L"127.0.0.1";
        server2.port = 22006;
        server2.players = 380;
        server2.maxPlayers = 500;
        server2.ping = 30;
        servers.push_back(server2);
        
        return servers;
    }
    
    bool ConnectToServer(const std::wstring& ip, int port) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –∏–º–∏—Ç–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        Sleep(1000);
        return true;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
class SettingsManager {
private:
    std::map<std::wstring, std::wstring> settings;
    std::wstring configFile;
    
public:
    SettingsManager() : configFile(L"config.ini") {
        LoadSettings();
    }
    
    void LoadSettings() {
        // –ó–∞–≥–ª—É—à–∫–∞ - –∑–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏–∑ —Ñ–∞–π–ª–∞
        settings[L"language"] = L"ru";
        settings[L"theme"] = L"dark";
        settings[L"autoUpdate"] = L"true";
    }
    
    void SaveSettings() {
        // –ó–∞–≥–ª—É—à–∫–∞ - —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤ —Ñ–∞–π–ª
    }
    
    std::wstring GetSetting(const std::wstring& key, const std::wstring& defaultValue = L"") {
        auto it = settings.find(key);
        if (it != settings.end()) {
            return it->second;
        }
        return defaultValue;
    }
    
    void SetSetting(const std::wstring& key, const std::wstring& value) {
        settings[key] = value;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
class Logger {
private:
    std::wstring logFile;
    
public:
    Logger() : logFile(L"launcher.log") {}
    
    void Log(const std::wstring& message) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –∑–∞–ø–∏—Å—å –≤ –ª–æ–≥
        OutputDebugStringW((message + L"\n").c_str());
    }
    
    void LogError(const std::wstring& error) {
        Log(L"ERROR: " + error);
    }
    
    void LogWarning(const std::wstring& warning) {
        Log(L"WARNING: " + warning);
    }
    
    void LogInfo(const std::wstring& info) {
        Log(L"INFO: " + info);
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏
class UpdateManager {
public:
    struct VersionInfo {
        int major;
        int minor;
        int patch;
        std::wstring description;
        std::wstring downloadUrl;
    };
    
    VersionInfo GetCurrentVersion() {
        VersionInfo version;
        version.major = 2;
        version.minor = 0;
        version.patch = 1;
        version.description = L"–¢–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è";
        return version;
    }
    
    VersionInfo CheckForUpdates() {
        // –ó–∞–≥–ª—É—à–∫–∞ - –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
        VersionInfo version;
        version.major = 2;
        version.minor = 0;
        version.patch = 2;
        version.description = L"–ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞";
        version.downloadUrl = L"https://example.com/update.exe";
        return version;
    }
    
    bool DownloadUpdate(const std::wstring& url) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –∑–∞–≥—Ä—É–∑–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        return true;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏
class NotificationManager {
public:
    enum NotificationType {
        INFO,
        WARNING,
        ERROR,
        SUCCESS
    };
    
    void ShowNotification(const std::wstring& title, const std::wstring& message, NotificationType type) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –ø–æ–∫–∞–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        UINT icon = MB_ICONINFORMATION;
        switch (type) {
            case WARNING: icon = MB_ICONWARNING; break;
            case ERROR: icon = MB_ICONERROR; break;
            case SUCCESS: icon = MB_ICONINFORMATION; break;
        }
        
        MessageBoxW(NULL, message.c_str(), title.c_str(), MB_OK | icon);
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
class StatisticsManager {
public:
    struct PlayerStats {
        int totalPlayTime; // –≤ –º–∏–Ω—É—Ç–∞—Ö
        int sessionsCount;
        std::wstring favoriteServer;
        int achievementsCount;
    };
    
    PlayerStats GetPlayerStats() {
        PlayerStats stats;
        stats.totalPlayTime = 12450;
        stats.sessionsCount = 156;
        stats.favoriteServer = L"DEL PERRO";
        stats.achievementsCount = 42;
        return stats;
    }
    
    void UpdateStats(const PlayerStats& stats) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥—Ä—É–∑—å—è–º–∏
class FriendsManager {
public:
    struct Friend {
        std::wstring name;
        std::wstring status; // online, offline, in-game
        std::wstring currentServer;
    };
    
    std::vector<Friend> GetFriendsList() {
        std::vector<Friend> friends;
        
        Friend friend1;
        friend1.name = L"Player1";
        friend1.status = L"online";
        friend1.currentServer = L"DEL PERRO";
        friends.push_back(friend1);
        
        Friend friend2;
        friend2.name = L"Player2";
        friend2.status = L"in-game";
        friend2.currentServer = L"LA MESA";
        friends.push_back(friend2);
        
        return friends;
    }
    
    void InviteFriend(const std::wstring& friendName, const std::wstring& serverName) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥—Ä—É–≥–∞
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è–º–∏
class AchievementsManager {
public:
    struct Achievement {
        std::wstring id;
        std::wstring name;
        std::wstring description;
        bool unlocked;
        int progress;
        int maxProgress;
    };
    
    std::vector<Achievement> GetAchievements() {
        std::vector<Achievement> achievements;
        
        Achievement ach1;
        ach1.id = L"first_login";
        ach1.name = L"–ü–µ—Ä–≤—ã–π –≤—Ö–æ–¥";
        ach1.description = L"–í–æ–π–¥–∏—Ç–µ –≤ –∏–≥—Ä—É –ø–µ—Ä–≤—ã–π —Ä–∞–∑";
        ach1.unlocked = true;
        ach1.progress = 1;
        ach1.maxProgress = 1;
        achievements.push_back(ach1);
        
        Achievement ach2;
        ach2.id = L"play_100_hours";
        ach2.name = L"–í–µ—Ç–µ—Ä–∞–Ω";
        ach2.description = L"–ò–≥—Ä–∞–π—Ç–µ 100 —á–∞—Å–æ–≤";
        ach2.unlocked = false;
        ach2.progress = 45;
        ach2.maxProgress = 100;
        achievements.push_back(ach2);
        
        return achievements;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –º–∞–≥–∞–∑–∏–Ω–æ–º
class StoreManager {
public:
    struct StoreItem {
        std::wstring id;
        std::wstring name;
        std::wstring description;
        double price;
        std::wstring currency;
        std::wstring imageUrl;
    };
    
    std::vector<StoreItem> GetStoreItems() {
        std::vector<StoreItem> items;
        
        StoreItem item1;
        item1.id = L"gta5_key";
        item1.name = L"GTA V";
        item1.description = L"–ö–ª—é—á –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∏–≥—Ä—ã";
        item1.price = 1999.00;
        item1.currency = L"RUB";
        items.push_back(item1);
        
        StoreItem item2;
        item2.id = L"premium_pass";
        item2.name = L"Premium Pass";
        item2.description = L"–ü—Ä–µ–º–∏—É–º –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –º–µ—Å—è—Ü";
        item2.price = 299.00;
        item2.currency = L"RUB";
        items.push_back(item2);
        
        return items;
    }
    
    bool PurchaseItem(const std::wstring& itemId) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –ø–æ–∫—É–ø–∫–∞ –ø—Ä–µ–¥–º–µ—Ç–∞
        return true;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –º–æ–¥–∞–º–∏
class ModManager {
public:
    struct Mod {
        std::wstring id;
        std::wstring name;
        std::wstring version;
        std::wstring author;
        bool enabled;
        bool installed;
    };
    
    std::vector<Mod> GetInstalledMods() {
        std::vector<Mod> mods;
        
        Mod mod1;
        mod1.id = L"graphics_mod";
        mod1.name = L"Graphics Enhancement";
        mod1.version = L"1.5.0";
        mod1.author = L"ModAuthor1";
        mod1.enabled = true;
        mod1.installed = true;
        mods.push_back(mod1);
        
        return mods;
    }
    
    bool InstallMod(const std::wstring& modId) {
        // –ó–∞–≥–ª—É—à–∫–∞ - —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–¥–∞
        return true;
    }
    
    bool EnableMod(const std::wstring& modId, bool enable) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –º–æ–¥–∞
        return true;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —á–∞—Ç–æ–º
class ChatManager {
public:
    struct Message {
        std::wstring sender;
        std::wstring text;
        SYSTEMTIME timestamp;
        bool isSystem;
    };
    
    std::vector<Message> GetMessages() {
        std::vector<Message> messages;
        
        Message msg1;
        msg1.sender = L"System";
        msg1.text = L"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!";
        GetLocalTime(&msg1.timestamp);
        msg1.isSystem = true;
        messages.push_back(msg1);
        
        return messages;
    }
    
    void SendMessage(const std::wstring& text) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≥–æ–ª–æ—Å–æ–≤—ã–º —á–∞—Ç–æ–º
class VoiceChatManager {
public:
    bool IsEnabled() {
        return false;
    }
    
    void Enable(bool enable) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —á–∞—Ç–∞
    }
    
    void SetVolume(int volume) {
        // –ó–∞–≥–ª—É—à–∫–∞ - —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥—Ä–æ–º–∫–æ—Å—Ç–∏
    }
    
    int GetVolume() {
        return 50;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–æ—Ñ–∏–ª–µ–º –∏–≥—Ä–æ–∫–∞
class ProfileManager {
public:
    struct Profile {
        std::wstring username;
        std::wstring email;
        std::wstring avatarUrl;
        int level;
        int experience;
        std::wstring rank;
    };
    
    Profile GetProfile() {
        Profile profile;
        profile.username = L"Player123";
        profile.email = L"player@example.com";
        profile.level = 25;
        profile.experience = 15000;
        profile.rank = L"Veteran";
        return profile;
    }
    
    void UpdateProfile(const Profile& profile) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–æ–≤–æ—Å—Ç—è–º–∏
class NewsManager {
public:
    struct NewsItem {
        std::wstring id;
        std::wstring title;
        std::wstring content;
        std::wstring imageUrl;
        SYSTEMTIME publishDate;
        std::wstring category;
    };
    
    std::vector<NewsItem> GetNews() {
        std::vector<NewsItem> news;
        
        NewsItem item1;
        item1.id = L"news1";
        item1.title = L"–ù–æ–≤–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ!";
        item1.content = L"–í—ã—à–ª–æ –Ω–æ–≤–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º —É–ª—É—á—à–µ–Ω–∏–π...";
        GetLocalTime(&item1.publishDate);
        item1.category = L"–û–±–Ω–æ–≤–ª–µ–Ω–∏—è";
        news.push_back(item1);
        
        NewsItem item2;
        item2.id = L"news2";
        item2.title = L"–ù–æ–≤—ã–π —Å–µ—Ä–≤–µ—Ä";
        item2.content = L"–û—Ç–∫—Ä—ã–ª—Å—è –Ω–æ–≤—ã–π –∏–≥—Ä–æ–≤–æ–π —Å–µ—Ä–≤–µ—Ä...";
        GetLocalTime(&item2.publishDate);
        item2.category = L"–°–µ—Ä–≤–µ—Ä—ã";
        news.push_back(item2);
        
        return news;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–æ–±—ã—Ç–∏—è–º–∏
class EventManager {
public:
    struct Event {
        std::wstring id;
        std::wstring name;
        std::wstring description;
        SYSTEMTIME startTime;
        SYSTEMTIME endTime;
        std::wstring server;
        int participants;
    };
    
    std::vector<Event> GetUpcomingEvents() {
        std::vector<Event> events;
        
        Event event1;
        event1.id = L"event1";
        event1.name = L"–ì–æ–Ω–∫–∏";
        event1.description = L"–ë–æ–ª—å—à–∏–µ –≥–æ–Ω–∫–∏ –Ω–∞ DEL PERRO";
        GetLocalTime(&event1.startTime);
        event1.server = L"DEL PERRO";
        event1.participants = 45;
        events.push_back(event1);
        
        return events;
    }
    
    void JoinEvent(const std::wstring& eventId) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —Å–æ–±—ã—Ç–∏—é
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä–µ–π—Ç–∏–Ω–≥–æ–º
class RankingManager {
public:
    struct RankingEntry {
        int position;
        std::wstring playerName;
        int score;
        std::wstring server;
    };
    
    std::vector<RankingEntry> GetTopPlayers(int count = 10) {
        std::vector<RankingEntry> ranking;
        
        for (int i = 0; i < count; i++) {
            RankingEntry entry;
            entry.position = i + 1;
            entry.playerName = L"Player" + std::to_wstring(i + 1);
            entry.score = 10000 - i * 500;
            entry.server = L"DEL PERRO";
            ranking.push_back(entry);
        }
        
        return ranking;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –æ—Ç—á–µ—Ç–∞–º–∏
class ReportManager {
public:
    enum ReportType {
        BUG,
        PLAYER,
        SERVER,
        OTHER
    };
    
    struct Report {
        std::wstring id;
        ReportType type;
        std::wstring description;
        SYSTEMTIME submitTime;
        std::wstring status;
    };
    
    bool SubmitReport(ReportType type, const std::wstring& description) {
        // –ó–∞–≥–ª—É—à–∫–∞ - –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç—á–µ—Ç–∞
        return true;
    }
    
    std::vector<Report> GetMyReports() {
        std::vector<Report> reports;
        return reports;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å FAQ
class FAQManager {
public:
    struct FAQItem {
        std::wstring question;
        std::wstring answer;
        std::wstring category;
    };
    
    std::vector<FAQItem> GetFAQ() {
        std::vector<FAQItem> faq;
        
        FAQItem item1;
        item1.question = L"–ö–∞–∫ –Ω–∞—á–∞—Ç—å –∏–≥—Ä–∞—Ç—å?";
        item1.answer = L"–î–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã –≤—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä –∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...";
        item1.category = L"–ù–∞—á–∞–ª–æ –∏–≥—Ä—ã";
        faq.push_back(item1);
        
        FAQItem item2;
        item2.question = L"–ö–∞–∫ –∫—É–ø–∏—Ç—å GTA V?";
        item2.answer = L"–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª '–ö—É–ø–∏—Ç—å GTA V' –∏ —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º...";
        item2.category = L"–ü–æ–∫—É–ø–∫–∞";
        faq.push_back(item2);
        
        return faq;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π
class SupportManager {
public:
    struct Ticket {
        std::wstring id;
        std::wstring subject;
        std::wstring description;
        SYSTEMTIME createTime;
        std::wstring status;
        std::vector<std::wstring> messages;
    };
    
    bool CreateTicket(const std::wstring& subject, const std::wstring& description) {
        // –ó–∞–≥–ª—É—à–∫–∞ - —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∏–∫–µ—Ç–∞
        return true;
    }
    
    std::vector<Ticket> GetMyTickets() {
        std::vector<Ticket> tickets;
        return tickets;
    }
};

// ============================================================================
// –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –£–¢–ò–õ–ò–¢–´
// ============================================================================

namespace Utils {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—Ç—Ä–æ–∫
    std::wstring StringToWString(const std::string& str) {
        int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);
        std::wstring wstr(size, 0);
        MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &wstr[0], size);
        return wstr;
    }
    
    std::string WStringToString(const std::wstring& wstr) {
        int size = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, NULL, 0, NULL, NULL);
        std::string str(size, 0);
        WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &str[0], size, NULL, NULL);
        return str;
    }
    
    // –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏
    bool FileExists(const std::wstring& path) {
        DWORD attrib = GetFileAttributesW(path.c_str());
        return (attrib != INVALID_FILE_ATTRIBUTES && !(attrib & FILE_ATTRIBUTE_DIRECTORY));
    }
    
    bool DirectoryExists(const std::wstring& path) {
        DWORD attrib = GetFileAttributesW(path.c_str());
        return (attrib != INVALID_FILE_ATTRIBUTES && (attrib & FILE_ATTRIBUTE_DIRECTORY));
    }
    
    bool CreateDirectoryRecursive(const std::wstring& path) {
        return CreateDirectoryW(path.c_str(), NULL) || GetLastError() == ERROR_ALREADY_EXISTS;
    }
    
    // –†–∞–±–æ—Ç–∞ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
    std::wstring FormatTime(const SYSTEMTIME& time) {
        wchar_t buffer[100];
        swprintf_s(buffer, L"%02d:%02d:%02d %02d.%02d.%04d", 
                  time.wHour, time.wMinute, time.wSecond,
                  time.wDay, time.wMonth, time.wYear);
        return buffer;
    }
    
    std::wstring FormatDuration(int seconds) {
        int hours = seconds / 3600;
        int minutes = (seconds % 3600) / 60;
        int secs = seconds % 60;
        
        wchar_t buffer[50];
        if (hours > 0) {
            swprintf_s(buffer, L"%d:%02d:%02d", hours, minutes, secs);
        } else {
            swprintf_s(buffer, L"%d:%02d", minutes, secs);
        }
        return buffer;
    }
    
    // –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏
    double Lerp(double a, double b, double t) {
        return a + (b - a) * t;
    }
    
    double Clamp(double value, double min, double max) {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    }
    
    int Random(int min, int max) {
        return min + rand() % (max - min + 1);
    }
    
    // –†–∞–±–æ—Ç–∞ —Å —Ü–≤–µ—Ç–∞–º–∏
    COLORREF BlendColors(COLORREF color1, COLORREF color2, double t) {
        int r1 = GetRValue(color1);
        int g1 = GetGValue(color1);
        int b1 = GetBValue(color1);
        
        int r2 = GetRValue(color2);
        int g2 = GetGValue(color2);
        int b2 = GetBValue(color2);
        
        int r = (int)Lerp(r1, r2, t);
        int g = (int)Lerp(g1, g2, t);
        int b = (int)Lerp(b1, b2, t);
        
        return RGB(r, g, b);
    }
    
    COLORREF DarkenColor(COLORREF color, double factor) {
        int r = (int)(GetRValue(color) * factor);
        int g = (int)(GetGValue(color) * factor);
        int b = (int)(GetBValue(color) * factor);
        return RGB(r, g, b);
    }
    
    COLORREF LightenColor(COLORREF color, double factor) {
        int r = GetRValue(color) + (int)((255 - GetRValue(color)) * factor);
        int g = GetGValue(color) + (int)((255 - GetGValue(color)) * factor);
        int b = GetBValue(color) + (int)((255 - GetBValue(color)) * factor);
        return RGB(r, g, b);
    }
}

// ============================================================================
// –ö–û–ù–ï–¶ –§–ê–ô–õ–ê
// –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫: 10000+
// ============================================================================
