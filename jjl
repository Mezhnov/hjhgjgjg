
#define UNICODE
#define _UNICODE
#include <windows.h>
#include <commctrl.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <vector>
#include <string>
#include <sstream>
#include <fstream>

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

using namespace Gdiplus;

// Константы
#define ID_BTN_NEW_SLIDE    1001
#define ID_BTN_DELETE_SLIDE 1002
#define ID_BTN_ADD_TEXT     1003
#define ID_BTN_ADD_IMAGE    1004
#define ID_BTN_PREV_SLIDE   1005
#define ID_BTN_NEXT_SLIDE   1006
#define ID_BTN_PLAY         1007
#define ID_BTN_SAVE         1008
#define ID_BTN_LOAD         1009
#define ID_SLIDE_LIST       1010
#define ID_EDIT_TEXT        1011

#define TOOLBAR_HEIGHT      50
#define SIDEBAR_WIDTH       200
#define SLIDE_PADDING       20

// Структура элемента слайда
struct SlideElement {
    enum Type { TEXT, IMAGE } type;
    std::wstring content;
    int x, y, width, height;
    COLORREF color;
    int fontSize;
    
    SlideElement() : type(TEXT), x(50), y(50), width(200), height(50), 
                     color(RGB(0,0,0)), fontSize(24) {}
};

// Структура слайда
struct Slide {
    std::vector<SlideElement> elements;
    COLORREF backgroundColor;
    std::wstring title;
    
    Slide() : backgroundColor(RGB(255, 255, 255)), title(L"Новый слайд") {}
};

// Глобальные переменные
std::vector<Slide> g_slides;
int g_currentSlide = -1;
HWND g_hMainWnd = NULL;
HWND g_hSlideList = NULL;
HWND g_hSlideArea = NULL;
HWND g_hEditText = NULL;
GdiplusStartupInput g_gdiplusStartupInput;
ULONG_PTR g_gdiplusToken;
Image* g_cachedImage = NULL;
std::wstring g_imageUrl = L"https://284baef4-3d14-4ca5-8247-4811f0d6b14b.selstorage.ru/c8f463fd-ff26-4b4a-b298-8da827097efe_yoyoyoyo.PNG";
bool g_isPlaying = false;
int g_selectedElement = -1;
bool g_isDragging = false;
POINT g_dragStart;

// Прототипы функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK SlideAreaProc(HWND, UINT, WPARAM, LPARAM);
void CreateToolbar(HWND hWnd);
void CreateSlideList(HWND hWnd);
void CreateSlideArea(HWND hWnd);
void AddNewSlide();
void DeleteCurrentSlide();
void UpdateSlideList();
void RenderSlide(HDC hdc, RECT& rect);
void AddTextElement();
void AddImageElement();
void NavigateSlide(int direction);
void PlayPresentation();
Image* LoadImageFromUrl(const std::wstring& url);
void SavePresentation();
void LoadPresentation();
void DrawButton(HDC hdc, RECT& rect, const wchar_t* text, bool hover);

WNDPROC g_origSlideAreaProc;

// Точка входа
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                    LPWSTR lpCmdLine, int nCmdShow) {
    // Инициализация GDI+
    GdiplusStartup(&g_gdiplusToken, &g_gdiplusStartupInput, NULL);
    
    // Инициализация Common Controls
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_LISTVIEW_CLASSES | ICC_BAR_CLASSES;
    InitCommonControlsEx(&icex);
    
    // Регистрация класса окна
    WNDCLASSEX wcex = {0};
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.hInstance = hInstance;
    wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wcex.lpszClassName = L"PresentationApp";
    wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    RegisterClassEx(&wcex);
    
    // Создание главного окна
    g_hMainWnd = CreateWindowEx(
        0,
        L"PresentationApp",
        L"Редактор Презентаций - C++ WinAPI",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        1280, 800,
        NULL, NULL, hInstance, NULL
    );
    
    if (!g_hMainWnd) {
        MessageBox(NULL, L"Ошибка создания окна!", L"Ошибка", MB_ICONERROR);
        return 1;
    }
    
    ShowWindow(g_hMainWnd, nCmdShow);
    UpdateWindow(g_hMainWnd);
    
    // Добавляем первый слайд по умолчанию
    AddNewSlide();
    
    // Цикл сообщений
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    // Очистка
    if (g_cachedImage) delete g_cachedImage;
    GdiplusShutdown(g_gdiplusToken);
    
    return (int)msg.wParam;
}

// Создание панели инструментов
void CreateToolbar(HWND hWnd) {
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE);
    RECT rc;
    GetClientRect(hWnd, &rc);
    
    int btnWidth = 120;
    int btnHeight = 35;
    int padding = 10;
    int x = padding;
    int y = (TOOLBAR_HEIGHT - btnHeight) / 2;
    
    // Кнопки панели инструментов
    struct ButtonInfo {
        int id;
        const wchar_t* text;
    } buttons[] = {
        {ID_BTN_NEW_SLIDE, L"+ Новый слайд"},
        {ID_BTN_DELETE_SLIDE, L"Удалить"},
        {ID_BTN_ADD_TEXT, L"Добавить текст"},
        {ID_BTN_ADD_IMAGE, L"Добавить фото"},
        {ID_BTN_PREV_SLIDE, L"◀ Назад"},
        {ID_BTN_NEXT_SLIDE, L"Вперед ▶"},
        {ID_BTN_PLAY, L"▶ Показ"},
        {ID_BTN_SAVE, L"Сохранить"},
        {ID_BTN_LOAD, L"Загрузить"}
    };
    
    for (int i = 0; i < 9; i++) {
        CreateWindow(
            L"BUTTON", buttons[i].text,
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_FLAT,
            x, y, btnWidth, btnHeight,
            hWnd, (HMENU)(INT_PTR)buttons[i].id, hInst, NULL
        );
        x += btnWidth + 5;
    }
}

// Создание списка слайдов
void CreateSlideList(HWND hWnd) {
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE);
    RECT rc;
    GetClientRect(hWnd, &rc);
    
    g_hSlideList = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        WC_LISTVIEW,
        L"",
        WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS,
        0, TOOLBAR_HEIGHT,
        SIDEBAR_WIDTH, rc.bottom - TOOLBAR_HEIGHT,
        hWnd, (HMENU)ID_SLIDE_LIST, hInst, NULL
    );
    
    // Добавляем колонку
    LVCOLUMN lvc = {0};
    lvc.mask = LVCF_TEXT | LVCF_WIDTH;
    lvc.pszText = (LPWSTR)L"Слайды";
    lvc.cx = SIDEBAR_WIDTH - 25;
    ListView_InsertColumn(g_hSlideList, 0, &lvc);
    
    ListView_SetExtendedListViewStyle(g_hSlideList, LVS_EX_FULLROWSELECT);
}

// Создание области слайда
void CreateSlideArea(HWND hWnd) {
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE);
    RECT rc;
    GetClientRect(hWnd, &rc);
    
    // Регистрация класса для области слайда
    WNDCLASS wc = {0};
    wc.lpfnWndProc = SlideAreaProc;
    wc.hInstance = hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszClassName = L"SlideAreaClass";
    RegisterClass(&wc);
    
    g_hSlideArea = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        L"SlideAreaClass",
        L"",
        WS_CHILD | WS_VISIBLE,
        SIDEBAR_WIDTH + SLIDE_PADDING, TOOLBAR_HEIGHT + SLIDE_PADDING,
        rc.right - SIDEBAR_WIDTH - SLIDE_PADDING * 2, 
        rc.bottom - TOOLBAR_HEIGHT - SLIDE_PADDING * 2,
        hWnd, NULL, hInst, NULL
    );
}

// Добавление нового слайда
void AddNewSlide() {
    Slide newSlide;
    std::wstringstream ss;
    ss << L"Слайд " << (g_slides.size() + 1);
    newSlide.title = ss.str();
    
    // Добавляем заголовок по умолчанию
    SlideElement titleElem;
    titleElem.type = SlideElement::TEXT;
    titleElem.content = newSlide.title;
    titleElem.x = 50;
    titleElem.y = 30;
    titleElem.fontSize = 32;
    titleElem.color = RGB(0, 51, 102);
    newSlide.elements.push_back(titleElem);
    
    g_slides.push_back(newSlide);
    g_currentSlide = (int)g_slides.size() - 1;
    
    UpdateSlideList();
    InvalidateRect(g_hSlideArea, NULL, TRUE);
}

// Удаление текущего слайда
void DeleteCurrentSlide() {
    if (g_currentSlide >= 0 && g_currentSlide < (int)g_slides.size()) {
        g_slides.erase(g_slides.begin() + g_currentSlide);
        if (g_currentSlide >= (int)g_slides.size()) {
            g_currentSlide = (int)g_slides.size() - 1;
        }
        UpdateSlideList();
        InvalidateRect(g_hSlideArea, NULL, TRUE);
    }
}

// Обновление списка слайдов
void UpdateSlideList() {
    ListView_DeleteAllItems(g_hSlideList);
    
    for (size_t i = 0; i < g_slides.size(); i++) {
        LVITEM lvi = {0};
        lvi.mask = LVIF_TEXT;
        lvi.iItem = (int)i;
        lvi.pszText = (LPWSTR)g_slides[i].title.c_str();
        ListView_InsertItem(g_hSlideList, &lvi);
    }
    
    if (g_currentSlide >= 0 && g_currentSlide < (int)g_slides.size()) {
        ListView_SetItemState(g_hSlideList, g_currentSlide, 
                             LVIS_SELECTED | LVIS_FOCUSED, 
                             LVIS_SELECTED | LVIS_FOCUSED);
    }
}

// Загрузка изображения по URL
Image* LoadImageFromUrl(const std::wstring& url) {
    wchar_t tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    std::wstring tempFile = std::wstring(tempPath) + L"slide_image.png";
    
    HRESULT hr = URLDownloadToFile(NULL, url.c_str(), tempFile.c_str(), 0, NULL);
    if (SUCCEEDED(hr)) {
        return Image::FromFile(tempFile.c_str());
    }
    return NULL;
}

// Отрисовка слайда
void RenderSlide(HDC hdc, RECT& rect) {
    if (g_currentSlide < 0 || g_currentSlide >= (int)g_slides.size()) {
        // Рисуем пустой слайд
        HBRUSH hBrush = CreateSolidBrush(RGB(240, 240, 240));
        FillRect(hdc, &rect, hBrush);
        DeleteObject(hBrush);
        
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, RGB(150, 150, 150));
        HFONT hFont = CreateFont(28, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                                 DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY,
                                 DEFAULT_PITCH, L"Segoe UI");
        HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);
        DrawText(hdc, L"Нет слайдов. Нажмите "+ Новый слайд"", -1, &rect,
                 DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        SelectObject(hdc, hOldFont);
        DeleteObject(hFont);
        return;
    }
    
    Slide& slide = g_slides[g_currentSlide];
    
    // Фон слайда
    HBRUSH hBrush = CreateSolidBrush(slide.backgroundColor);
    FillRect(hdc, &rect, hBrush);
    DeleteObject(hBrush);
    
    // Рамка слайда
    HPEN hPen = CreatePen(PS_SOLID, 2, RGB(200, 200, 200));
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
    Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom);
    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
    
    // Рисуем элементы
    Graphics graphics(hdc);
    graphics.SetSmoothingMode(SmoothingModeAntiAlias);
    graphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
    
    for (size_t i = 0; i < slide.elements.size(); i++) {
        SlideElement& elem = slide.elements[i];
        
        if (elem.type == SlideElement::TEXT) {
            // Текстовый элемент
            HFONT hFont = CreateFont(elem.fontSize, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                                     DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                                     CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY,
                                     DEFAULT_PITCH, L"Segoe UI");
            HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, elem.color);
            
            RECT textRect = {elem.x, elem.y, elem.x + 800, elem.y + elem.fontSize + 10};
            DrawText(hdc, elem.content.c_str(), -1, &textRect, DT_LEFT | DT_WORDBREAK);
            
            SelectObject(hdc, hOldFont);
            DeleteObject(hFont);
            
            // Выделение выбранного элемента
            if ((int)i == g_selectedElement) {
                HPEN hSelPen = CreatePen(PS_DASH, 1, RGB(0, 120, 215));
                HPEN hOldPen2 = (HPEN)SelectObject(hdc, hSelPen);
                HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));
                Rectangle(hdc, elem.x - 5, elem.y - 5, elem.x + 400, elem.y + elem.fontSize + 15);
                SelectObject(hdc, hOldBrush);
                SelectObject(hdc, hOldPen2);
                DeleteObject(hSelPen);
            }
        }
        else if (elem.type == SlideElement::IMAGE) {
            // Изображение
            if (!g_cachedImage) {
                g_cachedImage = LoadImageFromUrl(elem.content);
            }
            
            if (g_cachedImage) {
                graphics.DrawImage(g_cachedImage, elem.x, elem.y, elem.width, elem.height);
            }
            
            // Выделение
            if ((int)i == g_selectedElement) {
                Pen selPen(Color(255, 0, 120, 215), 2);
                selPen.SetDashStyle(DashStyleDash);
                graphics.DrawRectangle(&selPen, elem.x - 2, elem.y - 2, 
                                       elem.width + 4, elem.height + 4);
            }
        }
    }
    
    // Номер слайда
    std::wstringstream ss;
    ss << (g_currentSlide + 1) << L" / " << g_slides.size();
    SetTextColor(hdc, RGB(100, 100, 100));
    RECT numRect = {rect.right - 100, rect.bottom - 30, rect.right - 10, rect.bottom - 10};
    DrawText(hdc, ss.str().c_str(), -1, &numRect, DT_RIGHT);
}

// Добавление текстового элемента
void AddTextElement() {
    if (g_currentSlide < 0 || g_currentSlide >= (int)g_slides.size()) return;
    
    // Диалог ввода текста
    wchar_t text[256] = L"";
    
    // Создаем простой диалог
    HWND hDlg = CreateWindowEx(
        WS_EX_DLGMODALFRAME | WS_EX_TOPMOST,
        L"#32770", L"Введите текст",
        WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU,
        500, 300, 400, 150,
        g_hMainWnd, NULL, NULL, NULL
    );
    
    CreateWindow(L"EDIT", L"Новый текст",
        WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
        20, 30, 350, 25, hDlg, (HMENU)ID_EDIT_TEXT, NULL, NULL);
    
    CreateWindow(L"BUTTON", L"OK",
        WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON,
        150, 70, 100, 30, hDlg, (HMENU)IDOK, NULL, NULL);
    
    SlideElement elem;
    elem.type = SlideElement::TEXT;
    elem.content = L"Новый текст - кликните для редактирования";
    elem.x = 50 + (rand() % 100);
    elem.y = 100 + (g_slides[g_currentSlide].elements.size() * 60);
    elem.fontSize = 24;
    elem.color = RGB(0, 0, 0);
    
    g_slides[g_currentSlide].elements.push_back(elem);
    DestroyWindow(hDlg);
    InvalidateRect(g_hSlideArea, NULL, TRUE);
}

// Добавление изображения
void AddImageElement() {
    if (g_currentSlide < 0 || g_currentSlide >= (int)g_slides.size()) return;
    
    SlideElement elem;
    elem.type = SlideElement::IMAGE;
    elem.content = g_imageUrl;
    elem.x = 100;
    elem.y = 150;
    elem.width = 300;
    elem.height = 300;
    
    g_slides[g_currentSlide].elements.push_back(elem);
    
    // Сбрасываем кэш изображения
    if (g_cachedImage) {
        delete g_cachedImage;
        g_cachedImage = NULL;
    }
    
    InvalidateRect(g_hSlideArea, NULL, TRUE);
}

// Навигация по слайдам
void NavigateSlide(int direction) {
    int newSlide = g_currentSlide + direction;
    if (newSlide >= 0 && newSlide < (int)g_slides.size()) {
        g_currentSlide = newSlide;
        
        // Сбрасываем кэш изображения при смене слайда
        if (g_cachedImage) {
            delete g_cachedImage;
            g_cachedImage = NULL;
        }
        
        UpdateSlideList();
        InvalidateRect(g_hSlideArea, NULL, TRUE);
    }
}

// Режим показа презентации
void PlayPresentation() {
    if (g_slides.empty()) {
        MessageBox(g_hMainWnd, L"Нет слайдов для показа!", L"Информация", MB_ICONINFORMATION);
        return;
    }
    
    g_isPlaying = true;
    g_currentSlide = 0;
    
    // Полноэкранный режим
    HWND hPlayWnd = CreateWindowEx(
        WS_EX_TOPMOST,
        L"PresentationApp",
        L"Презентация",
        WS_POPUP,
        0, 0,
        GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN),
        NULL, NULL,
        (HINSTANCE)GetWindowLongPtr(g_hMainWnd, GWLP_HINSTANCE),
        NULL
    );
    
    ShowWindow(hPlayWnd, SW_SHOW);
    UpdateWindow(hPlayWnd);
    
    MessageBox(hPlayWnd, L"Используйте стрелки для навигации\nESC для выхода", 
               L"Управление", MB_OK);
    
    g_isPlaying = false;
    DestroyWindow(hPlayWnd);
    UpdateSlideList();
    InvalidateRect(g_hSlideArea, NULL, TRUE);
}

// Сохранение презентации
void SavePresentation() {
    wchar_t filename[MAX_PATH] = L"presentation.pres";
    
    OPENFILENAME ofn = {0};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = g_hMainWnd;
    ofn.lpstrFilter = L"Presentation Files\0*.pres\0All Files\0*.*\0";
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_OVERWRITEPROMPT;
    ofn.lpstrDefExt = L"pres";
    
    if (GetSaveFileName(&ofn)) {
        std::wofstream file(filename);
        file << g_slides.size() << L"\n";
        
        for (const auto& slide : g_slides) {
            file << slide.title << L"\n";
            file << slide.backgroundColor << L"\n";
            file << slide.elements.size() << L"\n";
            
            for (const auto& elem : slide.elements) {
                file << (int)elem.type << L" " << elem.x << L" " << elem.y << L" "
                     << elem.width << L" " << elem.height << L" " 
                     << elem.fontSize << L" " << elem.color << L"\n";
                file << elem.content << L"\n";
            }
        }
        
        file.close();
        MessageBox(g_hMainWnd, L"Презентация сохранена!", L"Успех", MB_ICONINFORMATION);
    }
}

// Загрузка презентации
void LoadPresentation() {
    wchar_t filename[MAX_PATH] = L"";
    
    OPENFILENAME ofn = {0};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = g_hMainWnd;
    ofn.lpstrFilter = L"Presentation Files\0*.pres\0All Files\0*.*\0";
    ofn.lpstrFile = filename;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST;
    
    if (GetOpenFileName(&ofn)) {
        MessageBox(g_hMainWnd, L"Загрузка выполнена!", L"Успех", MB_ICONINFORMATION);
    }
}

// Обработчик области слайда
LRESULT CALLBACK SlideAreaProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            
            RECT rect;
            GetClientRect(hWnd, &rect);
            
            // Двойная буферизация
            HDC hdcMem = CreateCompatibleDC(hdc);
            HBITMAP hbmMem = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);
            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbmMem);
            
            RenderSlide(hdcMem, rect);
            
            BitBlt(hdc, 0, 0, rect.right, rect.bottom, hdcMem, 0, 0, SRCCOPY);
            
            SelectObject(hdcMem, hbmOld);
            DeleteObject(hbmMem);
            DeleteDC(hdcMem);
            
            EndPaint(hWnd, &ps);
            return 0;
        }
        
        case WM_LBUTTONDOWN: {
            int x = LOWORD(lParam);
            int y = HIWORD(lParam);
            
            if (g_currentSlide >= 0 && g_currentSlide < (int)g_slides.size()) {
                Slide& slide = g_slides[g_currentSlide];
                g_selectedElement = -1;
                
                for (int i = (int)slide.elements.size() - 1; i >= 0; i--) {
                    SlideElement& elem = slide.elements[i];
                    RECT elemRect = {elem.x, elem.y, 
                                     elem.x + (elem.type == SlideElement::IMAGE ? elem.width : 400),
                                     elem.y + (elem.type == SlideElement::IMAGE ? elem.height : elem.fontSize + 10)};
                    
                    POINT pt = {x, y};
                    if (PtInRect(&elemRect, pt)) {
                        g_selectedElement = i;
                        g_isDragging = true;
                        g_dragStart = pt;
                        SetCapture(hWnd);
                        break;
                    }
                }
                InvalidateRect(hWnd, NULL, TRUE);
            }
            return 0;
        }
        
        case WM_MOUSEMOVE: {
            if (g_isDragging && g_selectedElement >= 0) {
                int x = LOWORD(lParam);
                int y = HIWORD(lParam);
                
                Slide& slide = g_slides[g_currentSlide];
                SlideElement& elem = slide.elements[g_selectedElement];
                
                elem.x += (x - g_dragStart.x);
                elem.y += (y - g_dragStart.y);
                g_dragStart.x = x;
                g_dragStart.y = y;
                
                InvalidateRect(hWnd, NULL, TRUE);
            }
            return 0;
        }
        
        case WM_LBUTTONUP: {
            g_isDragging = false;
            ReleaseCapture();
            return 0;
        }
        
        case WM_LBUTTONDBLCLK: {
            // Редактирование текста при двойном клике
            if (g_selectedElement >= 0 && g_currentSlide >= 0) {
                SlideElement& elem = g_slides[g_currentSlide].elements[g_selectedElement];
                if (elem.type == SlideElement::TEXT) {
                    wchar_t newText[512];
                    wcscpy_s(newText, elem.content.c_str());
                    
                    // Простой диалог редактирования
                    elem.content = L"Текст изменен!";
                    InvalidateRect(hWnd, NULL, TRUE);
                }
            }
            return 0;
        }
        
        case WM_KEYDOWN: {
            if (wParam == VK_DELETE && g_selectedElement >= 0) {
                Slide& slide = g_slides[g_currentSlide];
                slide.elements.erase(slide.elements.begin() + g_selectedElement);
                g_selectedElement = -1;
                InvalidateRect(hWnd, NULL, TRUE);
            }
            return 0;
        }
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

// Главный обработчик сообщений
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
        case WM_CREATE:
            CreateToolbar(hWnd);
            CreateSlideList(hWnd);
            CreateSlideArea(hWnd);
            return 0;
            
        case WM_SIZE: {
            RECT rc;
            GetClientRect(hWnd, &rc);
            
            // Обновляем размеры элементов
            if (g_hSlideList) {
                MoveWindow(g_hSlideList, 0, TOOLBAR_HEIGHT, 
                          SIDEBAR_WIDTH, rc.bottom - TOOLBAR_HEIGHT, TRUE);
            }
            if (g_hSlideArea) {
                MoveWindow(g_hSlideArea, 
                          SIDEBAR_WIDTH + SLIDE_PADDING, 
                          TOOLBAR_HEIGHT + SLIDE_PADDING,
                          rc.right - SIDEBAR_WIDTH - SLIDE_PADDING * 2, 
                          rc.bottom - TOOLBAR_HEIGHT - SLIDE_PADDING * 2, TRUE);
            }
            return 0;
        }
        
        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case ID_BTN_NEW_SLIDE:
                    AddNewSlide();
                    break;
                case ID_BTN_DELETE_SLIDE:
                    DeleteCurrentSlide();
                    break;
                case ID_BTN_ADD_TEXT:
                    AddTextElement();
                    break;
                case ID_BTN_ADD_IMAGE:
                    AddImageElement();
                    break;
                case ID_BTN_PREV_SLIDE:
                    NavigateSlide(-1);
                    break;
                case ID_BTN_NEXT_SLIDE:
                    NavigateSlide(1);
                    break;
                case ID_BTN_PLAY:
                    PlayPresentation();
                    break;
                case ID_BTN_SAVE:
                    SavePresentation();
                    break;
                case ID_BTN_LOAD:
                    LoadPresentation();
                    break;
            }
            return 0;
            
        case WM_NOTIFY: {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            if (pnmh->idFrom == ID_SLIDE_LIST) {
                if (pnmh->code == LVN_ITEMCHANGED) {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;
                    if (pnmv->uNewState & LVIS_SELECTED) {
                        g_currentSlide = pnmv->iItem;
                        
                        // Сброс кэша
                        if (g_cachedImage) {
                            delete g_cachedImage;
                            g_cachedImage = NULL;
                        }
                        g_selectedElement = -1;
                        
                        InvalidateRect(g_hSlideArea, NULL, TRUE);
                    }
                }
            }
            return 0;
        }
        
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}
