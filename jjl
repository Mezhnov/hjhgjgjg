// main.cpp - Enhanced Telegram-like UI with improved quality and features
// Build (MSVC): cl /EHsc /DUNICODE /D_UNICODE main.cpp user32.lib gdi32.lib gdiplus.lib msimg32.lib
// Build (MinGW): g++ -municode -O2 main.cpp -lgdi32 -luser32 -lgdiplus -lmsimg32 -o telegram_enhanced.exe

#define UNICODE
#define _UNICODE
#include <windows.h>
#include <windowsx.h>
#include <gdiplus.h>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "msimg32.lib")

using namespace Gdiplus;

static const wchar_t* kClassName = L"TelegramEnhancedWindowClass";

static HINSTANCE g_hInst = nullptr;
static HWND g_hwnd = nullptr;
static ULONG_PTR g_gdiplusToken = 0;

enum class Screen {
    Welcome = 0,
    Phone = 1,
    Code = 2
};
static Screen g_screen = Screen::Welcome;

// Animation state
struct AnimState {
    float progress = 0.0f;
    bool active = false;
    DWORD startTime = 0;
    int duration = 300;
};

static AnimState g_screenAnim;
static AnimState g_buttonAnim;

// ---------------- Color Palette ----------------
namespace Colors {
    const Color TelegramBlue(255, 64, 160, 220);
    const Color TelegramBlueHover(255, 56, 167, 225);
    const Color TelegramBluePressed(255, 48, 150, 210);
    const Color White(255, 255, 255, 255);
    const Color Background(255, 245, 245, 245);
    const Color TextPrimary(255, 0, 0, 0);
    const Color TextSecondary(255, 120, 120, 120);
    const Color TextTertiary(255, 160, 160, 160);
    const Color LinkBlue(255, 0, 140, 220);
    const Color LinkBlueHover(255, 0, 120, 200);
    const Color InputBorder(255, 210, 210, 210);
    const Color InputBorderActive(255, 64, 160, 220);
    const Color Shadow(60, 0, 0, 0);
    const Color ShadowLight(30, 0, 0, 0);
    const Color GreenOnline(255, 76, 217, 100);
    const Color RedError(255, 237, 73, 86);
}

// ---------------- Utilities ----------------
static int ClampI(int v, int lo, int hi) { return (v < lo) ? lo : (v > hi) ? hi : v; }
static float ClampF(float v, float lo, float hi) { return (v < lo) ? lo : (v > hi) ? hi : v; }
static float Lerp(float a, float b, float t) { return a + (b - a) * t; }

static float EaseOutCubic(float t) {
    float f = t - 1.0f;
    return f * f * f + 1.0f;
}

static float EaseInOutCubic(float t) {
    if (t < 0.5f) return 4.0f * t * t * t;
    float f = 2.0f * t - 2.0f;
    return 0.5f * f * f * f + 1.0f;
}

static Color BlendColor(const Color& a, const Color& b, float t) {
    return Color(
        (BYTE)Lerp(a.GetA(), b.GetA(), t),
        (BYTE)Lerp(a.GetR(), b.GetR(), t),
        (BYTE)Lerp(a.GetG(), b.GetG(), t),
        (BYTE)Lerp(a.GetB(), b.GetB(), t)
    );
}

static void StartAnimation(AnimState& anim, int duration = 300) {
    anim.active = true;
    anim.startTime = GetTickCount();
    anim.duration = duration;
    anim.progress = 0.0f;
}

static bool UpdateAnimation(AnimState& anim) {
    if (!anim.active) return false;
    
    DWORD now = GetTickCount();
    DWORD elapsed = now - anim.startTime;
    
    if (elapsed >= (DWORD)anim.duration) {
        anim.progress = 1.0f;
        anim.active = false;
        return false;
    }
    
    anim.progress = (float)elapsed / (float)anim.duration;
    return true;
}

// ---------------- GDI+ Drawing Helpers ----------------
static void DrawRoundRect(Graphics* g, const RectF& rect, float radius, const Color& color, float penWidth = 1.0f) {
    GraphicsPath path;
    path.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 0, 90);
    path.AddArc(rect.X, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 90, 90);
    path.CloseFigure();
    
    Pen pen(color, penWidth);
    g->DrawPath(&pen, &path);
}

static void FillRoundRect(Graphics* g, const RectF& rect, float radius, const Color& color) {
    GraphicsPath path;
    path.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 0, 90);
    path.AddArc(rect.X, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 90, 90);
    path.CloseFigure();
    
    SolidBrush brush(color);
    g->FillPath(&brush, &path);
}

static void DrawShadow(Graphics* g, const RectF& rect, float radius, float shadowSize = 4.0f) {
    GraphicsPath path;
    path.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 0, 90);
    path.AddArc(rect.X, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 90, 90);
    path.CloseFigure();
    
    PathGradientBrush brush(&path);
    Color colors[] = { Colors::Shadow, Color(0, 0, 0, 0) };
    REAL positions[] = { 0.0f, 1.0f };
    brush.SetInterpolationColors(colors, positions, 2);
    
    RectF shadowRect = rect;
    shadowRect.Inflate(shadowSize, shadowSize);
    g->FillRectangle(&brush, shadowRect);
}

static void DrawTextCentered(Graphics* g, const std::wstring& text, const RectF& rect, 
                             Font* font, const Color& color) {
    StringFormat format;
    format.SetAlignment(StringAlignmentCenter);
    format.SetLineAlignment(StringAlignmentCenter);
    
    SolidBrush brush(color);
    g->DrawString(text.c_str(), -1, font, rect, &format, &brush);
}

static void DrawTextLeft(Graphics* g, const std::wstring& text, const RectF& rect, 
                        Font* font, const Color& color) {
    StringFormat format;
    format.SetAlignment(StringAlignmentNear);
    format.SetLineAlignment(StringAlignmentNear);
    
    SolidBrush brush(color);
    g->DrawString(text.c_str(), -1, font, rect, &format, &brush);
}

static void DrawPaperPlane(Graphics* g, float x, float y, float size, const Color& color) {
    // Enhanced paper plane icon
    GraphicsPath path;
    
    // Main triangle
    PointF pts[] = {
        PointF(x - size * 0.4f, y - size * 0.6f),
        PointF(x + size * 0.8f, y),
        PointF(x - size * 0.4f, y + size * 0.6f),
        PointF(x - size * 0.1f, y)
    };
    
    path.AddPolygon(pts, 4);
    
    // Add inner detail
    path.StartFigure();
    PointF innerPts[] = {
        PointF(x - size * 0.1f, y),
        PointF(x + size * 0.3f, y + size * 0.15f),
        PointF(x + size * 0.3f, y - size * 0.15f)
    };
    path.AddPolygon(innerPts, 3);
    
    SolidBrush brush(color);
    g->FillPath(&brush, &path);
    
    // Add highlight
    Pen pen(Color(100, 255, 255, 255), 2.0f);
    g->DrawLine(&pen, x - size * 0.3f, y - size * 0.4f, x + size * 0.5f, y - size * 0.1f);
}

static void DrawBackArrow(Graphics* g, float x, float y, float size, const Color& color) {
    Pen pen(color, 2.5f);
    pen.SetLineCap(LineCapRound, LineCapRound, DashCapRound);
    
    PointF pts[] = {
        PointF(x + size, y),
        PointF(x, y + size),
        PointF(x + size, y + size * 2)
    };
    
    g->DrawLines(&pen, pts, 3);
}

static void DrawChevronDown(Graphics* g, float x, float y, float size, const Color& color) {
    Pen pen(color, 2.0f);
    pen.SetLineCap(LineCapRound, LineCapRound, DashCapRound);
    
    PointF pts[] = {
        PointF(x - size, y - size * 0.5f),
        PointF(x, y + size * 0.5f),
        PointF(x + size, y - size * 0.5f)
    };
    
    g->DrawLines(&pen, pts, 3);
}

static void DrawRussianFlag(Graphics* g, float x, float y, float w, float h) {
    // Russian flag: white, blue, red horizontal stripes
    SolidBrush whiteBrush(Color(255, 255, 255, 255));
    SolidBrush blueBrush(Color(255, 0, 57, 166));
    SolidBrush redBrush(Color(255, 213, 43, 30));
    
    float stripe = h / 3.0f;
    
    g->FillRectangle(&whiteBrush, x, y, w, stripe);
    g->FillRectangle(&blueBrush, x, y + stripe, w, stripe);
    g->FillRectangle(&redBrush, x, y + stripe * 2, w, stripe);
    
    // Border
    Pen borderPen(Color(100, 0, 0, 0), 1.0f);
    g->DrawRectangle(&borderPen, x, y, w, h);
}

static void DrawQRIcon(Graphics* g, float x, float y, float size, const Color& color) {
    // Simple QR code icon representation
    SolidBrush brush(color);
    float cellSize = size / 5.0f;
    
    // Draw some squares to represent QR pattern
    int pattern[5][5] = {
        {1, 1, 1, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 1, 1, 1, 0},
        {0, 0, 1, 1, 1},
        {1, 0, 0, 1, 1}
    };
    
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            if (pattern[i][j]) {
                g->FillRectangle(&brush, 
                    x + j * cellSize, 
                    y + i * cellSize, 
                    cellSize * 0.9f, 
                    cellSize * 0.9f);
            }
        }
    }
}

// ---------------- UI Elements ----------------
struct Button {
    RectF rc;
    std::wstring text;
    bool hot = false;
    bool down = false;
    bool enabled = true;
    AnimState hoverAnim;
    
    Color GetColor() const {
        float t = EaseOutCubic(hoverAnim.progress);
        if (down) return Colors::TelegramBluePressed;
        if (hot) return BlendColor(Colors::TelegramBlue, Colors::TelegramBlueHover, t);
        return Colors::TelegramBlue;
    }
};

struct Link {
    RectF rc;
    std::wstring text;
    bool hot = false;
    AnimState hoverAnim;
    
    Color GetColor() const {
        float t = EaseOutCubic(hoverAnim.progress);
        if (hot) return BlendColor(Colors::LinkBlue, Colors::LinkBlueHover, t);
        return Colors::LinkBlue;
    }
};

struct InputField {
    RectF rc;
    std::wstring text;
    std::wstring placeholder;
    bool focused = false;
    AnimState focusAnim;
    int cursorPos = 0;
    
    Color GetBorderColor() const {
        float t = EaseOutCubic(focusAnim.progress);
        if (focused) return BlendColor(Colors::InputBorder, Colors::InputBorderActive, t);
        return Colors::InputBorder;
    }
};

// UI State
static Button g_btnStart;
static Button g_btnContinue;
static Button g_btnVerify;
static Link g_linkRu;
static Link g_linkContinueEn;
static Link g_linkQr;
static Link g_linkSettings;
static Link g_linkResend;
static InputField g_countryField;
static InputField g_phoneField;
static InputField g_codeField;

static std::wstring g_phoneDigits;
static std::wstring g_codeDigits;

// Fonts
static Font* g_fontTitle = nullptr;
static Font* g_fontHeader = nullptr;
static Font* g_fontBody = nullptr;
static Font* g_fontSmall = nullptr;
static Font* g_fontButton = nullptr;
static Font* g_fontLink = nullptr;
static Font* g_fontCode = nullptr;

static void CreateFonts() {
    FontFamily fontFamily(L"Segoe UI");
    
    g_fontTitle = new Font(&fontFamily, 28, FontStyleBold, UnitPixel);
    g_fontHeader = new Font(&fontFamily, 20, FontStyleBold, UnitPixel);
    g_fontBody = new Font(&fontFamily, 15, FontStyleRegular, UnitPixel);
    g_fontSmall = new Font(&fontFamily, 13, FontStyleRegular, UnitPixel);
    g_fontButton = new Font(&fontFamily, 15, FontStyleBold, UnitPixel);
    g_fontLink = new Font(&fontFamily, 13, FontStyleRegular, UnitPixel);
    g_fontCode = new Font(&fontFamily, 24, FontStyleBold, UnitPixel);
}

static void DestroyFonts() {
    delete g_fontTitle;
    delete g_fontHeader;
    delete g_fontBody;
    delete g_fontSmall;
    delete g_fontButton;
    delete g_fontLink;
    delete g_fontCode;
}

static bool PtInRectF(const RectF& rc, POINT pt) {
    return pt.x >= rc.X && pt.x < rc.X + rc.Width && 
           pt.y >= rc.Y && pt.y < rc.Y + rc.Height;
}

static void LayoutUI(int w, int h) {
    float contentW = min(680.0f, (float)(w - 80));
    float cx = w / 2.0f;
    float left = cx - contentW / 2.0f;
    
    if (g_screen == Screen::Welcome) {
        float topBlueH = h * 0.45f;
        float btnW = 340.0f;
        float btnH = 48.0f;
        float btnX = cx - btnW / 2.0f;
        float btnY = topBlueH + 140.0f;
        
        g_btnStart.rc = RectF(btnX, btnY, btnW, btnH);
        g_btnStart.text = L"Start Messaging";
        
        float linkY = btnY + btnH + 24.0f;
        g_linkRu.text = L"Продолжить на русском";
        g_linkRu.rc = RectF(cx - 150, linkY, 300, 24);
        
    } else if (g_screen == Screen::Phone) {
        float topMargin = 30.0f;
        g_linkSettings.text = L"НАСТРОЙКИ";
        g_linkSettings.rc = RectF(w - 150.0f, topMargin, 130, 24);
        
        float blockTop = 140.0f;
        float fieldW = 400.0f;
        float fieldX = cx - fieldW / 2.0f;
        
        g_countryField.rc = RectF(fieldX, blockTop + 80, fieldW, 52);
        g_countryField.placeholder = L"Country";
        
        float rowY = blockTop + 160;
        g_phoneField.rc = RectF(fieldX, rowY, fieldW, 52);
        g_phoneField.placeholder = L"Phone number";
        
        float btnW = 400.0f;
        float btnH = 48.0f;
        float btnX = cx - btnW / 2.0f;
        float btnY = rowY + 80;
        g_btnContinue.rc = RectF(btnX, btnY, btnW, btnH);
        g_btnContinue.text = L"Продолжить";
        
        g_linkContinueEn.text = L"Continue in English";
        g_linkContinueEn.rc = RectF(cx - 130, btnY + btnH + 24, 260, 24);
        
        g_linkQr.text = L"Быстрый вход по QR-коду";
        g_linkQr.rc = RectF(cx - 160, btnY + btnH + 56, 320, 24);
        
    } else if (g_screen == Screen::Code) {
        float topMargin = 30.0f;
        
        float blockTop = 140.0f;
        float fieldW = 280.0f;
        float fieldX = cx - fieldW / 2.0f;
        
        g_codeField.rc = RectF(fieldX, blockTop + 100, fieldW, 60);
        g_codeField.placeholder = L"Code";
        
        float btnW = 280.0f;
        float btnH = 48.0f;
        float btnX = cx - btnW / 2.0f;
        float btnY = blockTop + 190;
        g_btnVerify.rc = RectF(btnX, btnY, btnW, btnH);
        g_btnVerify.text = L"Подтвердить";
        
        g_linkResend.text = L"Отправить код повторно";
        g_linkResend.rc = RectF(cx - 150, btnY + btnH + 24, 300, 24);
    }
}

static void UpdateHotStates(POINT pt) {
    auto updateBtn = [&](Button& b) {
        bool wasHot = b.hot;
        b.hot = PtInRectF(b.rc, pt);
        if (b.hot != wasHot) {
            StartAnimation(b.hoverAnim, 200);
        }
    };
    
    auto updateLink = [&](Link& l) {
        bool wasHot = l.hot;
        l.hot = PtInRectF(l.rc, pt);
        if (l.hot != wasHot) {
            StartAnimation(l.hoverAnim, 150);
        }
    };
    
    if (g_screen == Screen::Welcome) {
        updateBtn(g_btnStart);
        updateLink(g_linkRu);
    } else if (g_screen == Screen::Phone) {
        updateBtn(g_btnContinue);
        updateLink(g_linkContinueEn);
        updateLink(g_linkQr);
        updateLink(g_linkSettings);
    } else if (g_screen == Screen::Code) {
        updateBtn(g_btnVerify);
        updateLink(g_linkResend);
    }
}

static void SetScreen(Screen s) {
    g_screen = s;
    StartAnimation(g_screenAnim, 400);
    g_phoneField.focused = false;
    g_codeField.focused = false;
    InvalidateRect(g_hwnd, nullptr, TRUE);
}

// ---------------- Drawing Functions ----------------
static void DrawWelcome(Graphics* g, int w, int h) {
    // Background
    SolidBrush bgBrush(Colors::Background);
    g->FillRectangle(&bgBrush, 0, 0, w, h);
    
    float topBlueH = h * 0.45f;
    
    // Blue gradient background
    LinearGradientBrush blueBrush(
        PointF(0, 0), 
        PointF(0, topBlueH),
        Color(255, 74, 170, 230),
        Color(255, 54, 150, 210)
    );
    g->FillRectangle(&blueBrush, 0, 0, (float)w, topBlueH);
    
    // White section
    SolidBrush whiteBrush(Colors::White);
    g->FillRectangle(&whiteBrush, 0, topBlueH, (float)w, (float)h - topBlueH);
    
    // Shadow between sections
    RectF shadowRect(0, topBlueH - 10, (float)w, 20);
    LinearGradientBrush shadowBrush(
        PointF(0, topBlueH - 10),
        PointF(0, topBlueH + 10),
        Color(0, 0, 0, 0),
        Colors::ShadowLight
    );
    g->FillRectangle(&shadowBrush, shadowRect);
    
    // Paper plane
    DrawPaperPlane(g, w / 2.0f, topBlueH / 2.0f, 60.0f, Colors::White);
    
    // Title
    RectF titleRect(0, topBlueH + 50, (float)w, 40);
    DrawTextCentered(g, L"Telegram Desktop", titleRect, g_fontTitle, Colors::TextPrimary);
    
    // Subtitle
    RectF subtitleRect(0, topBlueH + 100, (float)w, 60);
    std::wstring subtitle = L"Welcome to the official Telegram Desktop app.\nIt's fast and secure.";
    DrawTextCentered(g, subtitle, subtitleRect, g_fontBody, Colors::TextSecondary);
    
    // Button with shadow
    RectF shadowBtnRect = g_btnStart.rc;
    shadowBtnRect.Inflate(2, 2);
    shadowBtnRect.Offset(0, 2);
    FillRoundRect(g, shadowBtnRect, 12, Colors::ShadowLight);
    
    Color btnColor = g_btnStart.GetColor();
    FillRoundRect(g, g_btnStart.rc, 12, btnColor);
    DrawTextCentered(g, g_btnStart.text, g_btnStart.rc, g_fontButton, Colors::White);
    
    // Link
    StringFormat format;
    format.SetAlignment(StringAlignmentCenter);
    format.SetLineAlignment(StringAlignmentCenter);
    
    SolidBrush linkBrush(g_linkRu.GetColor());
    g->DrawString(g_linkRu.text.c_str(), -1, g_fontLink, g_linkRu.rc, &format, &linkBrush);
    
    if (g_linkRu.hot) {
        Pen underline(g_linkRu.GetColor(), 1.0f);
        float y = g_linkRu.rc.Y + g_linkRu.rc.Height - 4;
        g->DrawLine(&underline, 
            g_linkRu.rc.X + 50, y,
            g_linkRu.rc.X + g_linkRu.rc.Width - 50, y);
    }
}

static std::wstring FormatPhoneMasked(const std::wstring& digits) {
    std::wstring result;
    int len = (int)digits.length();
    
    for (int i = 0; i < 10; i++) {
        if (i > 0 && (i == 3 || i == 6)) {
            result += L" ";
        }
        if (i < len) {
            result += digits[i];
        } else {
            result += L"_";
        }
    }
    
    return result;
}

static void DrawInputField(Graphics* g, InputField& field, const std::wstring& displayText) {
    // Background
    SolidBrush bgBrush(Colors::White);
    g->FillRectangle(&bgBrush, field.rc);
    
    // Border
    Color borderColor = field.GetBorderColor();
    Pen borderPen(borderColor, 2.0f);
    RectF borderRect = field.rc;
    borderRect.Inflate(-1, -1);
    g->DrawRectangle(&borderPen, borderRect);
    
    // Text or placeholder
    RectF textRect = field.rc;
    textRect.X += 16;
    textRect.Width -= 32;
    
    if (displayText.empty() && !field.focused) {
        SolidBrush phBrush(Colors::TextTertiary);
        StringFormat format;
        format.SetAlignment(StringAlignmentNear);
        format.SetLineAlignment(StringAlignmentCenter);
        g->DrawString(field.placeholder.c_str(), -1, g_fontBody, textRect, &format, &phBrush);
    } else {
        SolidBrush textBrush(Colors::TextPrimary);
        StringFormat format;
        format.SetAlignment(StringAlignmentNear);
        format.SetLineAlignment(StringAlignmentCenter);
        g->DrawString(displayText.c_str(), -1, g_fontBody, textRect, &format, &textBrush);
        
        // Cursor
        if (field.focused && ((GetTickCount() / 500) % 2 == 0)) {
            RectF cursorRect;
            g->MeasureString(displayText.c_str(), (int)displayText.length(), 
                           g_fontBody, textRect, &format, &cursorRect);
            
            Pen cursorPen(Colors::TelegramBlue, 2.0f);
            float cursorX = textRect.X + cursorRect.Width + 2;
            g->DrawLine(&cursorPen, 
                cursorX, field.rc.Y + 14,
                cursorX, field.rc.Y + field.rc.Height - 14);
        }
    }
}

static void DrawPhone(Graphics* g, int w, int h) {
    // Background
    SolidBrush bgBrush(Colors::White);
    g->FillRectangle(&bgBrush, 0, 0, w, h);
    
    // Back arrow
    DrawBackArrow(g, 26, 26, 10, Colors::TextSecondary);
    
    // Settings link
    StringFormat rightFormat;
    rightFormat.SetAlignment(StringAlignmentFar);
    rightFormat.SetLineAlignment(StringAlignmentCenter);
    
    SolidBrush linkBrush(g_linkSettings.GetColor());
    g->DrawString(g_linkSettings.text.c_str(), -1, g_fontLink, 
                 g_linkSettings.rc, &rightFormat, &linkBrush);
    
    if (g_linkSettings.hot) {
        Pen underline(g_linkSettings.GetColor(), 1.0f);
        RectF measureRect;
        g->MeasureString(g_linkSettings.text.c_str(), -1, g_fontLink, 
                        PointF(0, 0), &measureRect);
        float y = g_linkSettings.rc.Y + g_linkSettings.rc.Height - 4;
        float x2 = g_linkSettings.rc.X + g_linkSettings.rc.Width;
        g->DrawLine(&underline, x2 - measureRect.Width, y, x2, y);
    }
    
    // Header
    RectF headerRect(0, 120, (float)w, 32);
    DrawTextCentered(g, L"Ваш номер телефона", headerRect, g_fontHeader, Colors::TextPrimary);
    
    RectF subheaderRect(0, 158, (float)w, 50);
    std::wstring subtext = L"Проверьте код страны и введите\nсвой номер телефона.";
    DrawTextCentered(g, subtext, subheaderRect, g_fontSmall, Colors::TextSecondary);
    
    // Country field with flag
    DrawInputField(g, g_countryField, L"");
    
    // Draw flag and country name
    RectF countryContent = g_countryField.rc;
    countryContent.X += 16;
    countryContent.Y += 14;
    
    DrawRussianFlag(g, countryContent.X, countryContent.Y, 32, 24);
    
    RectF countryTextRect = countryContent;
    countryTextRect.X += 44;
    countryTextRect.Width -= 44;
    
    StringFormat leftFormat;
    leftFormat.SetAlignment(StringAlignmentNear);
    leftFormat.SetLineAlignment(StringAlignmentCenter);
    
    SolidBrush textBrush(Colors::TextPrimary);
    g->DrawString(L"Russian Federation", -1, g_fontBody, countryTextRect, &leftFormat, &textBrush);
    
    // Chevron
    DrawChevronDown(g, 
        g_countryField.rc.X + g_countryField.rc.Width - 24,
        g_countryField.rc.Y + g_countryField.rc.Height / 2,
        6, Colors::TextTertiary);
    
    // Phone field
    std::wstring phoneDisplay = L"+7 ";
    if (!g_phoneDigits.empty()) {
        phoneDisplay += FormatPhoneMasked(g_phoneDigits);
    } else if (!g_phoneField.focused) {
        phoneDisplay += L"___ ___ ____";
    }
    
    DrawInputField(g, g_phoneField, phoneDisplay);
    
    // Continue button
    RectF shadowBtnRect = g_btnContinue.rc;
    shadowBtnRect.Inflate(2, 2);
    shadowBtnRect.Offset(0, 2);
    FillRoundRect(g, shadowBtnRect, 12, Colors::ShadowLight);
    
    Color btnColor = g_btnContinue.GetColor();
    FillRoundRect(g, g_btnContinue.rc, 12, btnColor);
    DrawTextCentered(g, g_btnContinue.text, g_btnContinue.rc, g_fontButton, Colors::White);
    
    // Links
    auto drawCenteredLink = [&](Link& link) {
        StringFormat format;
        format.SetAlignment(StringAlignmentCenter);
        format.SetLineAlignment(StringAlignmentCenter);
        
        SolidBrush brush(link.GetColor());
        g->DrawString(link.text.c_str(), -1, g_fontLink, link.rc, &format, &brush);
        
        if (link.hot) {
            RectF measureRect;
            g->MeasureString(link.text.c_str(), -1, g_fontLink, PointF(0, 0), &measureRect);
            
            Pen underline(link.GetColor(), 1.0f);
            float cx = link.rc.X + link.rc.Width / 2;
            float y = link.rc.Y + link.rc.Height - 4;
            g->DrawLine(&underline, 
                cx - measureRect.Width / 2, y,
                cx + measureRect.Width / 2, y);
        }
    };
    
    drawCenteredLink(g_linkContinueEn);
    
    // QR link with icon
    float qrIconX = g_linkQr.rc.X + g_linkQr.rc.Width / 2 - 100;
    DrawQRIcon(g, qrIconX, g_linkQr.rc.Y + 2, 20, g_linkQr.GetColor());
    
    RectF qrTextRect = g_linkQr.rc;
    qrTextRect.X += 30;
    drawCenteredLink(g_linkQr);
}

static void DrawCode(Graphics* g, int w, int h) {
    // Background
    SolidBrush bgBrush(Colors::White);
    g->FillRectangle(&bgBrush, 0, 0, w, h);
    
    // Back arrow
    DrawBackArrow(g, 26, 26, 10, Colors::TextSecondary);
    
    // Header
    RectF headerRect(0, 120, (float)w, 32);
    DrawTextCentered(g, L"Введите код", headerRect, g_fontHeader, Colors::TextPrimary);
    
    RectF subheaderRect(0, 158, (float)w, 50);
    std::wstring phoneFormatted = L"+7 " + FormatPhoneMasked(g_phoneDigits);
    std::wstring subtext = L"Мы отправили код на номер\n" + phoneFormatted;
    DrawTextCentered(g, subtext, subheaderRect, g_fontSmall, Colors::TextSecondary);
    
    // Code input
    RectF codeRect = g_codeField.rc;
    
    // Background
    SolidBrush codeBgBrush(Colors::White);
    g->FillRectangle(&codeBgBrush, codeRect);
    
    // Border
    Color borderColor = g_codeField.GetBorderColor();
    Pen borderPen(borderColor, 2.0f);
    RectF borderRect = codeRect;
    borderRect.Inflate(-1, -1);
    g->DrawRectangle(&borderPen, borderRect);
    
    // Code digits
    if (g_codeDigits.empty() && !g_codeField.focused) {
        SolidBrush phBrush(Colors::TextTertiary);
        DrawTextCentered(g, L"— — — — —", codeRect, g_fontCode, Colors::TextTertiary);
    } else {
        std::wstring codeDisplay;
        for (size_t i = 0; i < 5; i++) {
            if (i < g_codeDigits.length()) {
                codeDisplay += g_codeDigits[i];
            } else {
                codeDisplay += L"—";
            }
            if (i < 4) codeDisplay += L" ";
        }
        
        DrawTextCentered(g, codeDisplay, codeRect, g_fontCode, Colors::TextPrimary);
    }
    
    // Verify button
    RectF shadowBtnRect = g_btnVerify.rc;
    shadowBtnRect.Inflate(2, 2);
    shadowBtnRect.Offset(0, 2);
    FillRoundRect(g, shadowBtnRect, 12, Colors::ShadowLight);
    
    Color btnColor = g_btnVerify.GetColor();
    FillRoundRect(g, g_btnVerify.rc, 12, btnColor);
    DrawTextCentered(g, g_btnVerify.text, g_btnVerify.rc, g_fontButton, Colors::White);
    
    // Resend link
    StringFormat format;
    format.SetAlignment(StringAlignmentCenter);
    format.SetLineAlignment(StringAlignmentCenter);
    
    SolidBrush linkBrush(g_linkResend.GetColor());
    g->DrawString(g_linkResend.text.c_str(), -1, g_fontLink, g_linkResend.rc, &format, &linkBrush);
    
    if (g_linkResend.hot) {
        RectF measureRect;
        g->MeasureString(g_linkResend.text.c_str(), -1, g_fontLink, PointF(0, 0), &measureRect);
        
        Pen underline(g_linkResend.GetColor(), 1.0f);
        float cx = g_linkResend.rc.X + g_linkResend.rc.Width / 2;
        float y = g_linkResend.rc.Y + g_linkResend.rc.Height - 4;
        g->DrawLine(&underline, 
            cx - measureRect.Width / 2, y,
            cx + measureRect.Width / 2, y);
    }
}

static void Paint(HWND hwnd) {
    RECT rc;
    GetClientRect(hwnd, &rc);
    int w = rc.right - rc.left;
    int h = rc.bottom - rc.top;
    
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    
    // Double buffering
    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP memBitmap = CreateCompatibleBitmap(hdc, w, h);
    HGDIOBJ oldBitmap = SelectObject(memDC, memBitmap);
    
    Graphics graphics(memDC);
    graphics.SetSmoothingMode(SmoothingModeAntiAlias);
    graphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit);
    
    if (g_screen == Screen::Welcome) {
        DrawWelcome(&graphics, w, h);
    } else if (g_screen == Screen::Phone) {
        DrawPhone(&graphics, w, h);
    } else if (g_screen == Screen::Code) {
        DrawCode(&graphics, w, h);
    }
    
    BitBlt(hdc, 0, 0, w, h, memDC, 0, 0, SRCCOPY);
    
    SelectObject(memDC, oldBitmap);
    DeleteObject(memBitmap);
    DeleteDC(memDC);
    
    EndPaint(hwnd, &ps);
}

// ---------------- Input Handling ----------------
static void ClickWelcome(POINT pt) {
    if (PtInRectF(g_btnStart.rc, pt)) {
        SetScreen(Screen::Phone);
    } else if (PtInRectF(g_linkRu.rc, pt)) {
        SetScreen(Screen::Phone);
    }
}

static void ClickPhone(POINT pt) {
    RECT backArea = { 10, 10, 60, 60 };
    if (PtInRect(&backArea, pt)) {
        SetScreen(Screen::Welcome);
        return;
    }
    
    if (PtInRectF(g_phoneField.rc, pt)) {
        g_phoneField.focused = true;
        StartAnimation(g_phoneField.focusAnim);
        InvalidateRect(g_hwnd, nullptr, FALSE);
        return;
    } else {
        if (g_phoneField.focused) {
            g_phoneField.focused = false;
            StartAnimation(g_phoneField.focusAnim);
        }
    }
    
    if (PtInRectF(g_btnContinue.rc, pt)) {
        if (g_phoneDigits.length() >= 10) {
            SetScreen(Screen::Code);
        } else {
            MessageBoxW(g_hwnd, L"Пожалуйста, введите полный номер телефона.", L"Ошибка", MB_OK | MB_ICONWARNING);
        }
        return;
    }
    
    if (PtInRectF(g_linkSettings.rc, pt)) {
        MessageBoxW(g_hwnd, L"Настройки (демо)", L"Settings", MB_OK | MB_ICONINFORMATION);
    } else if (PtInRectF(g_linkContinueEn.rc, pt)) {
        MessageBoxW(g_hwnd, L"Смена языка (демо)", L"Language", MB_OK | MB_ICONINFORMATION);
    } else if (PtInRectF(g_linkQr.rc, pt)) {
        MessageBoxW(g_hwnd, L"QR-вход (демо)", L"QR Login", MB_OK | MB_ICONINFORMATION);
    }
}

static void ClickCode(POINT pt) {
    RECT backArea = { 10, 10, 60, 60 };
    if (PtInRect(&backArea, pt)) {
        SetScreen(Screen::Phone);
        return;
    }
    
    if (PtInRectF(g_codeField.rc, pt)) {
        g_codeField.focused = true;
        StartAnimation(g_codeField.focusAnim);
        InvalidateRect(g_hwnd, nullptr, FALSE);
        return;
    } else {
        if (g_codeField.focused) {
            g_codeField.focused = false;
            StartAnimation(g_codeField.focusAnim);
        }
    }
    
    if (PtInRectF(g_btnVerify.rc, pt)) {
        if (g_codeDigits.length() == 5) {
            MessageBoxW(g_hwnd, L"Код подтвержден! (демо)", L"Success", MB_OK | MB_ICONINFORMATION);
        } else {
            MessageBoxW(g_hwnd, L"Пожалуйста, введите 5-значный код.", L"Ошибка", MB_OK | MB_ICONWARNING);
        }
        return;
    }
    
    if (PtInRectF(g_linkResend.rc, pt)) {
        MessageBoxW(g_hwnd, L"Код отправлен повторно (демо)", L"Resend", MB_OK | MB_ICONINFORMATION);
    }
}

static void OnChar(wchar_t ch) {
    if (g_screen == Screen::Phone && g_phoneField.focused) {
        if (ch >= L'0' && ch <= L'9') {
            if (g_phoneDigits.length() < 10) {
                g_phoneDigits.push_back(ch);
                InvalidateRect(g_hwnd, nullptr, FALSE);
            }
        } else if (ch == 8) { // Backspace
            if (!g_phoneDigits.empty()) {
                g_phoneDigits.pop_back();
                InvalidateRect(g_hwnd, nullptr, FALSE);
            }
        }
    } else if (g_screen == Screen::Code && g_codeField.focused) {
        if (ch >= L'0' && ch <= L'9') {
            if (g_codeDigits.length() < 5) {
                g_codeDigits.push_back(ch);
                InvalidateRect(g_hwnd, nullptr, FALSE);
                
                if (g_codeDigits.length() == 5) {
                    // Auto-verify when 5 digits entered
                    PostMessage(g_hwnd, WM_COMMAND, 1001, 0);
                }
            }
        } else if (ch == 8) { // Backspace
            if (!g_codeDigits.empty()) {
                g_codeDigits.pop_back();
                InvalidateRect(g_hwnd, nullptr, FALSE);
            }
        }
    }
}

// ---------------- Window Procedure ----------------
static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_CREATE:
        g_hwnd = hwnd;
        CreateFonts();
        SetTimer(hwnd, 1, 16, nullptr); // ~60 FPS for animations
        return 0;
        
    case WM_TIMER:
        if (wParam == 1) {
            bool needRedraw = false;
            
            needRedraw |= UpdateAnimation(g_screenAnim);
            needRedraw |= UpdateAnimation(g_btnStart.hoverAnim);
            needRedraw |= UpdateAnimation(g_btnContinue.hoverAnim);
            needRedraw |= UpdateAnimation(g_btnVerify.hoverAnim);
            needRedraw |= UpdateAnimation(g_linkRu.hoverAnim);
            needRedraw |= UpdateAnimation(g_linkContinueEn.hoverAnim);
            needRedraw |= UpdateAnimation(g_linkQr.hoverAnim);
            needRedraw |= UpdateAnimation(g_linkSettings.hoverAnim);
            needRedraw |= UpdateAnimation(g_linkResend.hoverAnim);
            needRedraw |= UpdateAnimation(g_phoneField.focusAnim);
            needRedraw |= UpdateAnimation(g_codeField.focusAnim);
            
            if (needRedraw) {
                InvalidateRect(hwnd, nullptr, FALSE);
            }
        }
        return 0;
        
    case WM_SIZE: {
        RECT rc;
        GetClientRect(hwnd, &rc);
        LayoutUI(rc.right - rc.left, rc.bottom - rc.top);
        InvalidateRect(hwnd, nullptr, TRUE);
        return 0;
    }
    
    case WM_MOUSEMOVE: {
        POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        UpdateHotStates(pt);
        
        static TRACKMOUSEEVENT tme = { sizeof(tme), TME_LEAVE, hwnd, 0 };
        TrackMouseEvent(&tme);
        
        return 0;
    }
    
    case WM_MOUSELEAVE:
        // Reset all hot states
        g_btnStart.hot = false;
        g_btnContinue.hot = false;
        g_btnVerify.hot = false;
        g_linkRu.hot = false;
        g_linkContinueEn.hot = false;
        g_linkQr.hot = false;
        g_linkSettings.hot = false;
        g_linkResend.hot = false;
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;
    
    case WM_LBUTTONDOWN: {
        SetCapture(hwnd);
        POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        
        if (g_screen == Screen::Welcome) {
            g_btnStart.down = PtInRectF(g_btnStart.rc, pt);
        } else if (g_screen == Screen::Phone) {
            g_btnContinue.down = PtInRectF(g_btnContinue.rc, pt);
        } else if (g_screen == Screen::Code) {
            g_btnVerify.down = PtInRectF(g_btnVerify.rc, pt);
        }
        
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;
    }
    
    case WM_LBUTTONUP: {
        ReleaseCapture();
        POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        
        bool wasDown = false;
        if (g_screen == Screen::Welcome) {
            wasDown = g_btnStart.down;
            g_btnStart.down = false;
            if (wasDown) ClickWelcome(pt);
        } else if (g_screen == Screen::Phone) {
            wasDown = g_btnContinue.down;
            g_btnContinue.down = false;
            ClickPhone(pt);
        } else if (g_screen == Screen::Code) {
            wasDown = g_btnVerify.down;
            g_btnVerify.down = false;
            ClickCode(pt);
        }
        
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;
    }
    
    case WM_CHAR:
        OnChar((wchar_t)wParam);
        return 0;
    
    case WM_COMMAND:
        if (wParam == 1001) { // Auto-verify code
            Sleep(100);
            MessageBoxW(hwnd, L"Код подтвержден! Добро пожаловать в Telegram!", L"Success", MB_OK | MB_ICONINFORMATION);
        }
        return 0;
    
    case WM_SETFOCUS:
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;
    
    case WM_KILLFOCUS:
        g_phoneField.focused = false;
        g_codeField.focused = false;
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;
    
    case WM_PAINT:
        Paint(hwnd);
        return 0;
    
    case WM_ERASEBKGND:
        return 1; // Prevent flickering
    
    case WM_DESTROY:
        KillTimer(hwnd, 1);
        DestroyFonts();
        PostQuitMessage(0);
        return 0;
    }
    
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

// ---------------- Entry Point ----------------
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    g_hInst = hInstance;
    
    // Initialize GDI+
    GdiplusStartupInput gdiplusStartupInput;
    GdiplusStartup(&g_gdiplusToken, &gdiplusStartupInput, nullptr);
    
    // Register window class
    WNDCLASSEXW wc = {};
    wc.cbSize = sizeof(wc);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszClassName = kClassName;
    
    if (!RegisterClassExW(&wc)) {
        MessageBoxW(nullptr, L"Failed to register window class", L"Error", MB_OK | MB_ICONERROR);
        return 0;
    }
    
    // Create window
    int winW = 900;
    int winH = 640;
    
    HWND hwnd = CreateWindowExW(
        0,
        kClassName,
        L"Telegram Desktop Enhanced",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        winW, winH,
        nullptr, nullptr, hInstance, nullptr
    );
    
    if (!hwnd) {
        MessageBoxW(nullptr, L"Failed to create window", L"Error", MB_OK | MB_ICONERROR);
        return 0;
    }
    
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    
    // Initial layout
    RECT rc;
    GetClientRect(hwnd, &rc);
    LayoutUI(rc.right - rc.left, rc.bottom - rc.top);
    
    // Message loop
    MSG msg = {};
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    
    // Cleanup GDI+
    GdiplusShutdown(g_gdiplusToken);
    
    return (int)msg.wParam;
}
