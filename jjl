// main.cpp - Telegram-like 2-screen mock (WinAPI + GDI), single file, no Qt.
// Build (MSVC): cl /EHsc /DUNICODE /D_UNICODE main.cpp user32.lib gdi32.lib
// Build (MinGW): g++ -municode -O2 main.cpp -lgdi32 -luser32 -o telegram_mock.exe

#define UNICODE
#define _UNICODE
#include <windows.h>
#include <windowsx.h>
#include <string>
#include <vector>
#include <algorithm>

static const wchar_t* kClassName = L"TelegramMockWindowClass";

static HINSTANCE g_hInst = nullptr;
static HWND g_hwnd = nullptr;

enum class Screen {
    Welcome = 0,
    Phone = 1
};
static Screen g_screen = Screen::Welcome;

// ---------------- Utilities ----------------
static int ClampI(int v, int lo, int hi) { return (v < lo) ? lo : (v > hi) ? hi : v; }

static COLORREF RGBc(int r, int g, int b) { return RGB(ClampI(r,0,255), ClampI(g,0,255), ClampI(b,0,255)); }

static void FillSolidRect(HDC hdc, const RECT& rc, COLORREF color) {
    HBRUSH br = CreateSolidBrush(color);
    FillRect(hdc, &rc, br);
    DeleteObject(br);
}

static void FrameRect1(HDC hdc, const RECT& rc, COLORREF color) {
    HPEN pen = CreatePen(PS_SOLID, 1, color);
    HGDIOBJ oldPen = SelectObject(hdc, pen);
    HGDIOBJ oldBrush = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hdc, oldBrush);
    SelectObject(hdc, oldPen);
    DeleteObject(pen);
}

static SIZE MeasureText(HDC hdc, HFONT font, const std::wstring& text) {
    HGDIOBJ old = SelectObject(hdc, font);
    SIZE sz{};
    GetTextExtentPoint32W(hdc, text.c_str(), (int)text.size(), &sz);
    SelectObject(hdc, old);
    return sz;
}

static void DrawTextCentered(HDC hdc, HFONT font, const std::wstring& text, RECT rc, COLORREF color) {
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, color);
    HGDIOBJ oldF = SelectObject(hdc, font);
    DrawTextW(hdc, text.c_str(), (int)text.size(), &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    SelectObject(hdc, oldF);
}

static void DrawTextLeft(HDC hdc, HFONT font, const std::wstring& text, RECT rc, COLORREF color, UINT format = DT_LEFT | DT_TOP | DT_WORDBREAK) {
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, color);
    HGDIOBJ oldF = SelectObject(hdc, font);
    DrawTextW(hdc, text.c_str(), (int)text.size(), &rc, format);
    SelectObject(hdc, oldF);
}

static void DrawUnderlineText(HDC hdc, HFONT font, const std::wstring& text, int x, int y, COLORREF color) {
    // Simple underline by drawing a line under measured text.
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, color);
    HGDIOBJ oldF = SelectObject(hdc, font);
    TextOutW(hdc, x, y, text.c_str(), (int)text.size());
    SIZE sz{};
    GetTextExtentPoint32W(hdc, text.c_str(), (int)text.size(), &sz);
    SelectObject(hdc, oldF);

    HPEN pen = CreatePen(PS_SOLID, 1, color);
    HGDIOBJ oldP = SelectObject(hdc, pen);
    MoveToEx(hdc, x, y + sz.cy + 1, nullptr);
    LineTo(hdc, x + sz.cx, y + sz.cy + 1);
    SelectObject(hdc, oldP);
    DeleteObject(pen);
}

static HRGN CreateRoundRectRgnEx(const RECT& rc, int radius) {
    return CreateRoundRectRgn(rc.left, rc.top, rc.right, rc.bottom, radius, radius);
}

static void FillRoundRect(HDC hdc, const RECT& rc, int radius, COLORREF color) {
    HRGN rgn = CreateRoundRectRgnEx(rc, radius);
    HBRUSH br = CreateSolidBrush(color);
    FillRgn(hdc, rgn, br);
    DeleteObject(br);
    DeleteObject(rgn);
}

static void DrawChevronDown(HDC hdc, int cx, int cy, int size, COLORREF color) {
    // Draw a simple v-shaped chevron
    HPEN pen = CreatePen(PS_SOLID, 2, color);
    HGDIOBJ oldP = SelectObject(hdc, pen);
    MoveToEx(hdc, cx - size, cy - size/2, nullptr);
    LineTo(hdc, cx, cy + size/2);
    LineTo(hdc, cx + size, cy - size/2);
    SelectObject(hdc, oldP);
    DeleteObject(pen);
}

static void DrawBackArrow(HDC hdc, int x, int y, int size, COLORREF color) {
    // Simple left arrow
    HPEN pen = CreatePen(PS_SOLID, 2, color);
    HGDIOBJ oldP = SelectObject(hdc, pen);
    MoveToEx(hdc, x + size, y, nullptr);
    LineTo(hdc, x, y + size);
    LineTo(hdc, x + size, y + 2*size);
    SelectObject(hdc, oldP);
    DeleteObject(pen);
}

// ---------------- UI State ----------------
struct Button {
    RECT rc{};
    std::wstring text;
    bool hot = false;
    bool down = false;
    bool enabled = true;
};

struct Link {
    RECT rc{};
    std::wstring text;
    bool hot = false;
};

static Button g_btnStart{};
static Button g_btnContinue{};
static Link g_linkRu{};
static Link g_linkContinueEn{};
static Link g_linkQr{};
static Link g_linkSettings{};
static RECT g_countryDrop{};
static RECT g_phoneEdit{};
static RECT g_codeBox{};

static std::wstring g_phoneDigits; // only digits typed for phone field
static bool g_phoneFocused = false;

// Fonts
static HFONT g_fontTitle = nullptr;
static HFONT g_fontBody = nullptr;
static HFONT g_fontSmall = nullptr;
static HFONT g_fontButton = nullptr;
static HFONT g_fontLink = nullptr;
static HFONT g_fontHeader = nullptr;

static void CreateFonts() {
    // Use Segoe UI if available (default on Windows 10/11).
    // Sizes tuned to look similar.
    auto makeFont = [](int height, int weight) -> HFONT {
        return CreateFontW(
            -height, 0, 0, 0, weight, FALSE, FALSE, FALSE,
            DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
            CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Segoe UI"
        );
    };

    g_fontTitle  = makeFont(26, FW_SEMIBOLD);
    g_fontHeader = makeFont(18, FW_SEMIBOLD);
    g_fontBody   = makeFont(14, FW_NORMAL);
    g_fontSmall  = makeFont(12, FW_NORMAL);
    g_fontButton = makeFont(14, FW_SEMIBOLD);
    g_fontLink   = makeFont(12, FW_NORMAL);
}

static void DestroyFonts() {
    auto del = [](HFONT& f) { if (f) { DeleteObject(f); f = nullptr; } };
    del(g_fontTitle);
    del(g_fontHeader);
    del(g_fontBody);
    del(g_fontSmall);
    del(g_fontButton);
    del(g_fontLink);
}

static bool PtInRectEx(const RECT& rc, POINT pt) {
    return pt.x >= rc.left && pt.x < rc.right && pt.y >= rc.top && pt.y < rc.bottom;
}

static void LayoutUI(int w, int h) {
    // Common layout constants
    int contentW = min(640, w - 80);
    int cx = w / 2;
    int left = cx - contentW / 2;
    int right = cx + contentW / 2;

    if (g_screen == Screen::Welcome) {
        int topBlueH = (int)(h * 0.42);
        int btnW = 300;
        int btnH = 44;

        int btnX = cx - btnW/2;
        int btnY = topBlueH + 120;

        g_btnStart.rc = { btnX, btnY, btnX + btnW, btnY + btnH };
        g_btnStart.text = L"Start Messaging";

        // Link under button
        int linkY = btnY + btnH + 18;
        g_linkRu.text = L"Продолжить на русском";
        g_linkRu.rc = { cx - 140, linkY, cx + 140, linkY + 20 };
    } else {
        // Phone screen
        int topMargin = 26;
        // Back arrow area
        // Settings link at top-right
        g_linkSettings.text = L"НАСТРОЙКИ";
        g_linkSettings.rc = { w - 140, topMargin, w - 20, topMargin + 22 };

        // Center block
        int blockTop = 120;
        int fieldW = 360;
        int fieldX = cx - fieldW/2;

        // Country dropdown
        g_countryDrop = { fieldX, blockTop + 70, fieldX + fieldW, blockTop + 110 };

        // Phone input row
        // Code box + phone edit
        int rowY = blockTop + 140;
        g_codeBox = { fieldX, rowY, fieldX + 60, rowY + 44 };
        g_phoneEdit = { fieldX + 70, rowY, fieldX + fieldW, rowY + 44 };

        // Continue button
        int btnW = 360;
        int btnH = 44;
        int btnX = cx - btnW/2;
        int btnY = rowY + 70;
        g_btnContinue.rc = { btnX, btnY, btnX + btnW, btnY + btnH };
        g_btnContinue.text = L"Продолжить";

        // Links
        g_linkContinueEn.text = L"Continue in English";
        g_linkContinueEn.rc = { cx - 120, btnY + btnH + 18, cx + 120, btnY + btnH + 40 };

        g_linkQr.text = L"Быстрый вход по QR-коду";
        g_linkQr.rc = { cx - 150, btnY + btnH + 50, cx + 150, btnY + btnH + 72 };
    }
}

static void UpdateHotStates(POINT pt) {
    auto setBtnHot = [&](Button& b) { b.hot = PtInRectEx(b.rc, pt); };
    auto setLinkHot = [&](Link& l) { l.hot = PtInRectEx(l.rc, pt); };

    if (g_screen == Screen::Welcome) {
        setBtnHot(g_btnStart);
        setLinkHot(g_linkRu);
    } else {
        setBtnHot(g_btnContinue);
        setLinkHot(g_linkContinueEn);
        setLinkHot(g_linkQr);
        setLinkHot(g_linkSettings);
    }
}

static void SetScreen(Screen s) {
    g_screen = s;
    g_phoneFocused = false;
    InvalidateRect(g_hwnd, nullptr, TRUE);
}

// ---------------- Drawing ----------------
static void DrawWelcome(HDC hdc, int w, int h) {
    // Background
    RECT rcAll{0,0,w,h};
    FillSolidRect(hdc, rcAll, RGBc(245,245,245));

    int topBlueH = (int)(h * 0.42);
    RECT rcBlue{0,0,w,topBlueH};
    FillSolidRect(hdc, rcBlue, RGBc(26, 150, 214)); // Telegram-ish blue

    RECT rcWhite{0,topBlueH,w,h};
    FillSolidRect(hdc, rcWhite, RGBc(255,255,255));

    // Paper plane placeholder (simple triangle)
    // In real Telegram this is a vector plane; here we draw a simple white polygon.
    POINT plane[3] = {
        { w/2 - 20, topBlueH/2 - 40 },
        { w/2 + 60, topBlueH/2 - 10 },
        { w/2 - 10, topBlueH/2 + 30 }
    };
    HBRUSH brPlane = CreateSolidBrush(RGBc(255,255,255));
    HPEN penPlane = CreatePen(PS_SOLID, 1, RGBc(255,255,255));
    HGDIOBJ oldB = SelectObject(hdc, brPlane);
    HGDIOBJ oldP = SelectObject(hdc, penPlane);
    Polygon(hdc, plane, 3);
    SelectObject(hdc, oldB);
    SelectObject(hdc, oldP);
    DeleteObject(brPlane);
    DeleteObject(penPlane);

    // Title and body
    RECT rcTitle{0, topBlueH + 40, w, topBlueH + 80};
    DrawTextCentered(hdc, g_fontTitle, L"Telegram Desktop", rcTitle, RGBc(0,0,0));

    RECT rcBody{0, topBlueH + 85, w, topBlueH + 130};
    DrawTextCentered(hdc, g_fontBody, L"Welcome to the official Telegram Desktop app.\nIt's fast and secure.",
                     rcBody, RGBc(120,120,120));

    // Button
    COLORREF btnColor = g_btnStart.hot ? RGBc(56, 167, 225) : RGBc(64, 160, 220);
    FillRoundRect(hdc, g_btnStart.rc, 10, btnColor);
    DrawTextCentered(hdc, g_fontButton, g_btnStart.text, g_btnStart.rc, RGBc(255,255,255));

    // Link
    int linkX = (g_linkRu.rc.left + g_linkRu.rc.right)/2;
    // We'll draw centered by measuring
    SIZE lsz = MeasureText(hdc, g_fontLink, g_linkRu.text);
    int lx = linkX - lsz.cx/2;
    int ly = g_linkRu.rc.top;
    COLORREF linkColor = g_linkRu.hot ? RGBc(0,120,200) : RGBc(0,140,220);
    DrawUnderlineText(hdc, g_fontLink, g_linkRu.text, lx, ly, linkColor);
}

static std::wstring FormatPhoneMasked(const std::wstring& digits) {
    // Simple mask: ___ ___ ____ (up to 10 digits)
    // Display typed digits in positions.
    std::wstring mask = L"___ ___ ____";
    int di = 0;
    for (int i = 0; i < (int)mask.size() && di < (int)digits.size(); ++i) {
        if (mask[i] == L'_') {
            mask[i] = digits[di++];
        }
    }
    return mask;
}

static void DrawInputBox(HDC hdc, const RECT& rc, bool focused) {
    // Bottom underline style like Telegram
    // Fill background white, draw underline gray/blue
    FillSolidRect(hdc, rc, RGBc(255,255,255));
    COLORREF line = focused ? RGBc(64,160,220) : RGBc(210,210,210);
    HPEN pen = CreatePen(PS_SOLID, 2, line);
    HGDIOBJ oldP = SelectObject(hdc, pen);
    MoveToEx(hdc, rc.left, rc.bottom - 1, nullptr);
    LineTo(hdc, rc.right, rc.bottom - 1);
    SelectObject(hdc, oldP);
    DeleteObject(pen);
}

static void DrawPhone(HDC hdc, int w, int h) {
    RECT rcAll{0,0,w,h};
    FillSolidRect(hdc, rcAll, RGBc(255,255,255));

    // Top bar elements
    // Back arrow (top-left)
    DrawBackArrow(hdc, 22, 22, 8, RGBc(120,120,120));

    // Settings link (top-right)
    {
        SIZE sz = MeasureText(hdc, g_fontLink, g_linkSettings.text);
        int x = g_linkSettings.rc.right - sz.cx;
        int y = g_linkSettings.rc.top;
        COLORREF c = g_linkSettings.hot ? RGBc(0,120,200) : RGBc(0,140,220);
        DrawUnderlineText(hdc, g_fontLink, g_linkSettings.text, x, y, c);
    }

    // Header text
    RECT rcH1{0, 110, w, 140};
    DrawTextCentered(hdc, g_fontHeader, L"Ваш номер телефона", rcH1, RGBc(0,0,0));

    RECT rcH2{0, 145, w, 185};
    DrawTextCentered(hdc, g_fontSmall, L"Проверьте код страны и введите\nсвой номер телефона.",
                     rcH2, RGBc(140,140,140));

    // Country dropdown
    // Draw underline and text
    DrawInputBox(hdc, g_countryDrop, false);
    RECT rcCountryText = g_countryDrop;
    rcCountryText.left += 4;
    rcCountryText.top += 10;
    DrawTextLeft(hdc, g_fontBody, L"Russian Federation", rcCountryText, RGBc(0,0,0), DT_LEFT|DT_TOP|DT_SINGLELINE);
    DrawChevronDown(hdc, g_countryDrop.right - 14, (g_countryDrop.top + g_countryDrop.bottom)/2, 6, RGBc(160,160,160));

    // Code box + phone edit
    DrawInputBox(hdc, g_codeBox, false);
    RECT rcCodeText = g_codeBox;
    rcCodeText.left += 6;
    rcCodeText.top += 10;
    DrawTextLeft(hdc, g_fontBody, L"+7", rcCodeText, RGBc(0,0,0), DT_LEFT|DT_TOP|DT_SINGLELINE);

    DrawInputBox(hdc, g_phoneEdit, g_phoneFocused);
    RECT rcPhoneText = g_phoneEdit;
    rcPhoneText.left += 6;
    rcPhoneText.top += 10;

    std::wstring shown = g_phoneDigits.empty() ? L"___ ___ ____" : FormatPhoneMasked(g_phoneDigits);
    COLORREF phoneColor = g_phoneDigits.empty() ? RGBc(180,180,180) : RGBc(0,0,0);
    DrawTextLeft(hdc, g_fontBody, shown, rcPhoneText, phoneColor, DT_LEFT|DT_TOP|DT_SINGLELINE);

    // Continue button
    COLORREF btnColor = g_btnContinue.hot ? RGBc(56, 167, 225) : RGBc(64, 160, 220);
    FillRoundRect(hdc, g_btnContinue.rc, 10, btnColor);
    DrawTextCentered(hdc, g_fontButton, g_btnContinue.text, g_btnContinue.rc, RGBc(255,255,255));

    // Links under button
    auto drawCenteredLink = [&](const Link& l) {
        SIZE sz = MeasureText(hdc, g_fontLink, l.text);
        int cx = (l.rc.left + l.rc.right)/2;
        int x = cx - sz.cx/2;
        int y = l.rc.top;
        COLORREF c = l.hot ? RGBc(0,120,200) : RGBc(0,140,220);
        DrawUnderlineText(hdc, g_fontLink, l.text, x, y, c);
    };

    drawCenteredLink(g_linkContinueEn);
    drawCenteredLink(g_linkQr);
}

static void Paint(HWND hwnd) {
    RECT rc{};
    GetClientRect(hwnd, &rc);
    int w = rc.right - rc.left;
    int h = rc.bottom - rc.top;

    PAINTSTRUCT ps{};
    HDC hdc = BeginPaint(hwnd, &ps);

    // Double buffering
    HDC mem = CreateCompatibleDC(hdc);
    HBITMAP bmp = CreateCompatibleBitmap(hdc, w, h);
    HGDIOBJ oldBmp = SelectObject(mem, bmp);

    if (g_screen == Screen::Welcome) DrawWelcome(mem, w, h);
    else DrawPhone(mem, w, h);

    BitBlt(hdc, 0, 0, w, h, mem, 0, 0, SRCCOPY);

    SelectObject(mem, oldBmp);
    DeleteObject(bmp);
    DeleteDC(mem);

    EndPaint(hwnd, &ps);
}

// ---------------- Input handling ----------------
static void ClickWelcome(POINT pt) {
    if (PtInRectEx(g_btnStart.rc, pt)) {
        SetScreen(Screen::Phone);
        return;
    }
    if (PtInRectEx(g_linkRu.rc, pt)) {
        // Just go next for demo as well
        SetScreen(Screen::Phone);
        return;
    }
}

static void ClickPhone(POINT pt) {
    // Back arrow area
    RECT backArea{ 10, 10, 60, 60 };
    if (PtInRectEx(backArea, pt)) {
        SetScreen(Screen::Welcome);
        return;
    }

    if (PtInRectEx(g_phoneEdit, pt)) {
        g_phoneFocused = true;
        InvalidateRect(g_hwnd, nullptr, FALSE);
        return;
    } else {
        g_phoneFocused = false;
        InvalidateRect(g_hwnd, nullptr, FALSE);
    }

    if (PtInRectEx(g_btnContinue.rc, pt)) {
        MessageBoxW(g_hwnd, L"Демо макет: здесь обычно отправляется код подтверждения.", L"Continue", MB_OK | MB_ICONINFORMATION);
        return;
    }

    if (PtInRectEx(g_linkSettings.rc, pt)) {
        MessageBoxW(g_hwnd, L"Настройки (демо).", L"Settings", MB_OK);
        return;
    }
    if (PtInRectEx(g_linkContinueEn.rc, pt)) {
        MessageBoxW(g_hwnd, L"Switch language (демо).", L"Language", MB_OK);
        return;
    }
    if (PtInRectEx(g_linkQr.rc, pt)) {
        MessageBoxW(g_hwnd, L"QR login (демо).", L"QR", MB_OK);
        return;
    }
}

static void OnChar(wchar_t ch) {
    if (g_screen != Screen::Phone) return;
    if (!g_phoneFocused) return;

    if (ch >= L'0' && ch <= L'9') {
        if ((int)g_phoneDigits.size() < 10) {
            g_phoneDigits.push_back(ch);
            InvalidateRect(g_hwnd, nullptr, FALSE);
        }
    } else if (ch == 8) { // backspace
        if (!g_phoneDigits.empty()) {
            g_phoneDigits.pop_back();
            InvalidateRect(g_hwnd, nullptr, FALSE);
        }
    }
}

static void OnMouseMove(HWND hwnd, int x, int y) {
    POINT pt{ x, y };
    UpdateHotStates(pt);
    InvalidateRect(hwnd, nullptr, FALSE);
}

// ---------------- WndProc ----------------
static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_CREATE:
        g_hwnd = hwnd;
        CreateFonts();
        return 0;

    case WM_SIZE: {
        RECT rc{};
        GetClientRect(hwnd, &rc);
        LayoutUI(rc.right - rc.left, rc.bottom - rc.top);
        InvalidateRect(hwnd, nullptr, TRUE);
        return 0;
    }

    case WM_MOUSEMOVE:
        OnMouseMove(hwnd, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        return 0;

    case WM_LBUTTONDOWN: {
        SetCapture(hwnd);
        POINT pt{ GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        if (g_screen == Screen::Welcome) {
            g_btnStart.down = PtInRectEx(g_btnStart.rc, pt);
        } else {
            g_btnContinue.down = PtInRectEx(g_btnContinue.rc, pt);
        }
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;
    }

    case WM_LBUTTONUP: {
        ReleaseCapture();
        POINT pt{ GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };

        if (g_screen == Screen::Welcome) {
            bool wasDown = g_btnStart.down;
            g_btnStart.down = false;
            if (wasDown) ClickWelcome(pt);
        } else {
            bool wasDown = g_btnContinue.down;
            g_btnContinue.down = false;
            if (wasDown) ClickPhone(pt);
            else ClickPhone(pt); // allow clicking links/fields
        }

        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;
    }

    case WM_CHAR:
        OnChar((wchar_t)wParam);
        return 0;

    case WM_SETFOCUS:
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;

    case WM_KILLFOCUS:
        g_phoneFocused = false;
        InvalidateRect(hwnd, nullptr, FALSE);
        return 0;

    case WM_PAINT:
        Paint(hwnd);
        return 0;

    case WM_DESTROY:
        DestroyFonts();
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

// ---------------- WinMain ----------------
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    g_hInst = hInstance;

    WNDCLASSEXW wc{};
    wc.cbSize = sizeof(wc);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = kClassName;

    if (!RegisterClassExW(&wc)) return 0;

    // Window size similar to screenshot
    int winW = 820;
    int winH = 560;

    HWND hwnd = CreateWindowExW(
        0, kClassName, L"Telegram Desktop",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, winW, winH,
        nullptr, nullptr, hInstance, nullptr
    );
    if (!hwnd) return 0;

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // Force initial layout
    RECT rc{};
    GetClientRect(hwnd, &rc);
    LayoutUI(rc.right - rc.left, rc.bottom - rc.top);

    MSG msg{};
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return (int)msg.wParam;
}
