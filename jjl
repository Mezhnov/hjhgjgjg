#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shellapi.h>
#include <dwmapi.h>
#include <wchar.h>
#include <cmath>

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "dwmapi.lib")

using namespace Gdiplus;

// ================= CONFIG =================
const int W = 1200;
const int H = 700;

const wchar_t* BG_URL   = L"https://images.unsplash.com/photo-1557683316-973673baf926?w=1600";
const wchar_t* BG_FILE  = L"bg.jpg";
const wchar_t* LOGO_URL = L"https://i.imgur.com/8Z5KX7v.png"; // ← замени на свой логотип
const wchar_t* LOGO_FILE= L"logo.png";

const wchar_t* GTA_PATH = L"C:\\Games\\GTA5\\GTA5.exe";

// ================= ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ =================
ULONG_PTR gdiToken;
Image* background = nullptr;
Image* logo = nullptr;
bool isFullscreen = false;
RECT normalRect;

float progress = 0.0f;
float progressTarget = 0.92f;   // имитация реального прогресса
float playPulse = 0.0f;
bool playPulseDir = true;

bool showNews = false;
bool showSettings = false;
int currentNewsIndex = 0;

// ================= НОВОСТИ (пример) =================
struct NewsItem {
    const wchar_t* title;
    const wchar_t* description;
    const wchar_t* imageUrl;
    const wchar_t* imageFile;
};

NewsItem newsItems[] = {
    { L"Обновление 1.68",       L"Новые бизнесы, интерьер домов, кастомизация", L"https://picsum.photos/800/300?random=1", L"news1.jpg" },
    { L"Зимний ивент 2026",     L"Снег, подарки, новый транспорт",              L"https://picsum.photos/800/300?random=2", L"news2.jpg" },
    { L"Античит усилен",        L"Более 4000 аккаунтов забанено за 2 недели",   L"https://picsum.photos/800/300?random=3", L"news3.jpg" },
};
const int numNews = sizeof(newsItems) / sizeof(NewsItem);
Image* newsImages[3] = { nullptr };

// ================= НАСТРОЙКИ =================
bool settingFullscreen  = false;
bool settingAutoUpdate  = true;
bool settingSoundEffects= true;
int  settingVolume      = 78;

// ================= СТРУКТУРЫ =================
struct Button {
    RECT rect;
    const wchar_t* text;
    bool hover;
    Color normalColor;
    Color hoverColor;
    int fontSize;
    const wchar_t* tooltip;
};

struct Panel {
    RECT rect;
    Color bgColor;
    int borderRadius;
};

// ================= КНОПКИ =================
Button btnPlay { {430, 520, 770, 620}, L"ЗАПУСТИТЬ", false, Color(40,220,100,220), Color(60,255,140,255), 32, L"Запустить игру" };

Button btnNews     { {40, 160,340,240}, L"НОВОСТИ",     false, Color(50,50,60,180),   Color(70,70,90,220), 20, L"Новости проекта" };
Button btnSettings { {40, 260,340,340}, L"НАСТРОЙКИ",   false, Color(50,50,60,180),   Color(70,70,90,220), 20, L"Настройки лаунчера" };
Button btnDiscord  { {40, 360,340,440}, L"DISCORD",     false, Color(88,101,242,200), Color(100,120,255,240),20,L"Наш Discord" };
Button btnForum    { {40, 460,340,540}, L"ФОРУМ",       false, Color(50,50,60,180),   Color(70,70,90,220), 20, L"Официальный форум" };

Button btnDonate   { {860,160,1160,240}, L"ДОНАТ",      false, Color(255,215,0,200),  Color(255,235,80,255),20, L"Поддержать сервер" };
Button btnStats    { {860,260,1160,340}, L"СТАТИСТИКА", false, Color(50,50,60,180),   Color(70,70,90,220), 20, L"Статистика" };
Button btnRules    { {860,360,1160,440}, L"ПРАВИЛА",    false, Color(220,60,60,180),  Color(240,80,80,220),20, L"Правила сервера" };

Button btnMinimize { {W-140,12,W-100,42}, L"−", false, Color(0,0,0,0), Color(160,160,160,200), 22, L"Свернуть" };
Button btnMaximize { {W-90, 12,W-50, 42}, L"□", false, Color(0,0,0,0), Color(160,160,160,200), 22, L"Развернуть / Свернуть" };
Button btnClose    { {W-40, 12,W-10, 42}, L"×", false, Color(0,0,0,0), Color(220,60,60,220),   22, L"Закрыть" };

Button btnNewsBack  { {60, 60,180,110}, L"← НАЗАД", false, Color(60,60,70,180), Color(90,90,110,220), 20, L"" };
Button btnNewsPrev  { {380,580,480,640}, L"<", false, Color(60,60,70,160), Color(90,90,110,200), 28, L"" };
Button btnNewsNext  { {720,580,820,640}, L">", false, Color(60,60,70,160), Color(90,90,110,200), 28, L"" };

Button btnSettingsBack { {60, 60,180,110}, L"← НАЗАД", false, Color(60,60,70,180), Color(90,90,110,220), 20, L"" };

// Чекбоксы
Button chkFullscreen  { {240,180,780,240}, L"Полноэкранный режим игры",  false, Color(0,0,0,0), Color(80,80,100,140), 17, L"" };
Button chkAutoUpdate  { {240,250,780,310}, L"Автообновление клиента",    false, Color(0,0,0,0), Color(80,80,100,140), 17, L"" };
Button chkSound       { {240,320,780,380}, L"Звуки интерфейса",          false, Color(0,0,0,0), Color(80,80,100,140), 17, L"" };

// ================= ПАНЕЛИ =================
Panel mainLeft   { {30, 140, 370, 640}, Color(30,30,40,140), 16 };
Panel mainRight  { {830,140,1170,540},  Color(30,30,40,140), 16 };
Panel playArea   { {410,490,790,650},   Color(20,20,30,100), 24 };
Panel newsPanel  { {180, 90,1020,580},  Color(25,25,35,160), 20 };
Panel settingsPanel{{180,90,1020,580},  Color(25,25,35,160), 20 };

// ================= УТИЛИТЫ =================
bool InRect(const POINT& p, const RECT& r) {
    return p.x >= r.left && p.x < r.right && p.y >= r.top && p.y < r.bottom;
}

void DrawRoundedRect(Graphics& g, Brush* brush, RectF rect, REAL radius) {
    GraphicsPath path;
    path.AddArc(rect.X, rect.Y, radius*2, radius*2, 180, 90);
    path.AddArc(rect.X+rect.Width-radius*2, rect.Y, radius*2, radius*2, 270, 90);
    path.AddArc(rect.X+rect.Width-radius*2, rect.Y+rect.Height-radius*2, radius*2, radius*2, 0, 90);
    path.AddArc(rect.X, rect.Y+rect.Height-radius*2, radius*2, radius*2, 90, 90);
    path.CloseFigure();
    g.FillPath(brush, &path);
}

void DrawButton(Graphics& g, Button& b, float pulse = 0.f) {
    Color bg = b.hover ? b.hoverColor : b.normalColor;
    if (&b == &btnPlay && pulse > 0) {
        BYTE alpha = (BYTE)(pulse * 60);
        bg = Color(bg.GetA() + alpha, bg.GetR(), bg.GetG(), bg.GetB());
    }

    SolidBrush brush(bg);
    RectF r((REAL)b.rect.left, (REAL)b.rect.top, (REAL)(b.rect.right-b.rect.left), (REAL)(b.rect.bottom-b.rect.top));
    DrawRoundedRect(g, &brush, r, 14.0f);

    FontFamily ff(L"Segoe UI");
    Font font(&ff, (REAL)b.fontSize, FontStyleBold);
    SolidBrush text(Color::WhiteSmoke);
    StringFormat fmt; fmt.SetAlignment(StringAlignmentCenter); fmt.SetLineAlignment(StringAlignmentCenter);

    // лёгкая тень под текстом
    SolidBrush shadow(Color(80,0,0,0));
    g.DrawString(b.text, -1, &font, PointF(r.X+2, r.Y+2), &fmt, &shadow);
    g.DrawString(b.text, -1, &font, r, &fmt, &text);
}

void DrawTooltip(Graphics& g, const wchar_t* text, POINT mouse) {
    if (!text || !wcslen(text)) return;

    FontFamily ff(L"Segoe UI");
    Font font(&ff, 14.0f);
    RectF bound;
    g.MeasureString(text, -1, &font, PointF(0,0), &bound);

    REAL w = bound.Width + 24;
    REAL h = bound.Height + 16;
    REAL x = mouse.x + 16;
    REAL y = mouse.y + 24;

    // не выходим за экран
    if (x + w > W) x = mouse.x - w - 8;
    if (y + h > H) y = mouse.y - h - 8;

    RectF rect(x, y, w, h);
    SolidBrush bg(Color(220, 30, 30, 45));
    DrawRoundedRect(g, &bg, rect, 8);

    Pen border(Color(180,120,120,255), 1.5f);
    g.DrawPath(&border, [&rect](GraphicsPath& p){
        p.AddArc(rect.X, rect.Y, 16,16,180,90);
        p.AddArc(rect.X+rect.Width-16, rect.Y,16,16,270,90);
        p.AddArc(rect.X+rect.Width-16, rect.Y+rect.Height-16,16,16,0,90);
        p.AddArc(rect.X, rect.Y+rect.Height-16,16,16,90,90);
        p.CloseFigure();
    });

    SolidBrush txtBrush(Color::White);
    StringFormat fmt; fmt.SetAlignment(StringAlignmentCenter); fmt.SetLineAlignment(StringAlignmentCenter);
    g.DrawString(text, -1, &font, rect, &fmt, &txtBrush);
}

void DrawCheckbox(Graphics& g, Button& b, bool checked) {
    RectF r((REAL)b.rect.left, (REAL)b.rect.top, (REAL)(b.rect.right-b.rect.left), (REAL)(b.rect.bottom-b.rect.top));

    SolidBrush bg(b.hover ? Color(70,70,90,160) : Color(50,50,60,120));
    g.FillRectangle(&bg, r);

    RectF box(r.X + 12, r.Y + (r.Height-24)/2, 24, 24);
    Pen pen(Color(220,220,220), 2.2f);
    g.DrawRectangle(&pen, box);

    if (checked) {
        SolidBrush fill(Color(60,220,100));
        g.FillRectangle(&fill, box.X+4, box.Y+4, box.Width-8, box.Height-8);
    }

    FontFamily ff(L"Segoe UI");
    Font font(&ff, 17);
    SolidBrush text(Color(235,235,245));
    RectF textRect(r.X + 48, r.Y, r.Width - 50, r.Height);
    StringFormat fmt; fmt.SetLineAlignment(StringAlignmentCenter);
    g.DrawString(b.text, -1, &font, textRect, &fmt, &text);
}

// ... (остальные функции DrawXXX остаются почти без изменений, только улучшены цвета и отступы)

void DrawHeader(Graphics& g) {
    LinearGradientBrush grad(Point(0,0), Point(0,80), Color(180,20,20,50), Color(60,10,10,30));
    g.FillRectangle(&grad, 0, 0, W, 80);

    if (logo) g.DrawImage(logo, 24, 12, 56, 56);

    FontFamily ff(L"Segoe UI");
    Font big(&ff, 38, FontStyleBold);
    SolidBrush sh(Color(140,0,0,0));
    SolidBrush txt1(Color(255,210,60));
    SolidBrush txt2(Color(255,255,255));

    g.DrawString(L"MAJESTIC", -1, &big, PointF(100,18), &sh);
    g.DrawString(L"MAJESTIC", -1, &big, PointF(96, 14), &txt1);

    g.DrawString(L"RP", -1, &big, PointF(340,18), &sh);
    g.DrawString(L"RP",      -1, &big, PointF(336,14), &txt2);
}

// ================= WINDOW PROC =================
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static POINT mousePos;
    static const Button* hovered = nullptr;

    switch (msg)
    {
    case WM_CREATE:
    {
        DWM_WINDOW_CORNER_PREFERENCE pref = DWMWCP_ROUND;
        DwmSetWindowAttribute(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &pref, sizeof(pref));

        URLDownloadToFileW(nullptr, BG_URL,   BG_FILE,   0, nullptr);
        URLDownloadToFileW(nullptr, LOGO_URL, LOGO_FILE, 0, nullptr);

        background = Image::FromFile(BG_FILE);
        logo       = Image::FromFile(LOGO_FILE);

        for (int i = 0; i < numNews; ++i) {
            URLDownloadToFileW(nullptr, newsItems[i].imageUrl, newsItems[i].imageFile, 0, nullptr);
            newsImages[i] = Image::FromFile(newsItems[i].imageFile);
        }

        SetTimer(hwnd, 1, 16, nullptr);   // ~60 fps
        break;
    }

    case WM_TIMER:
        if (wParam == 1)
        {
            // плавный прогресс
            if (progress < progressTarget) {
                progress += (progressTarget - progress) * 0.08f;
                if (progress > progressTarget) progress = progressTarget;
            }

            // пульсация кнопки Play
            if (playPulseDir) {
                playPulse += 0.04f;
                if (playPulse >= 1.f) playPulseDir = false;
            } else {
                playPulse -= 0.04f;
                if (playPulse <= 0.f) playPulseDir = true;
            }

            InvalidateRect(hwnd, nullptr, FALSE);
        }
        break;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP bmp = CreateCompatibleBitmap(hdc, W, H);
        SelectObject(memDC, bmp);

        Graphics g(memDC);
        g.SetSmoothingMode(SmoothingModeAntiAlias);
        g.SetTextRenderingHint(TextRenderingHintAntiAlias);
        g.SetInterpolationMode(InterpolationModeHighQualityBicubic);

        if (background) g.DrawImage(background, 0, 0, W, H);

        // тёмный оверлей
        LinearGradientBrush ov(Point(0,0), Point(0,H), Color(160,0,0,0), Color(220,0,0,0));
        g.FillRectangle(&ov, 0,0,W,H);

        DrawHeader(g);

        if (!showNews && !showSettings) {
            DrawRoundedRect(g, &SolidBrush(Color(35,35,45,90)), RectF(0,80,W,H-80), 0);

            DrawPanel(g, mainLeft);
            DrawPanel(g, mainRight);
            DrawPanel(g, playArea);

            DrawButton(g, btnNews);
            DrawButton(g, btnSettings);
            DrawButton(g, btnDiscord);
            DrawButton(g, btnForum);
            DrawButton(g, btnDonate);
            DrawButton(g, btnStats);
            DrawButton(g, btnRules);

            DrawButton(g, btnPlay, playPulse);
            // здесь можно нарисовать красивый прогресс-бар ...

            DrawButton(g, btnMinimize);
            DrawButton(g, btnMaximize);
            DrawButton(g, btnClose);

            if (hovered) DrawTooltip(g, hovered->tooltip, mousePos);
        }
        else if (showNews) {
            DrawNews(g);      // ← нужно дописать или оставить как было
        }
        else if (showSettings) {
            DrawSettings(g);  // ← нужно дописать или оставить как было
        }

        BitBlt(hdc, 0,0,W,H, memDC,0,0, SRCCOPY);
        DeleteObject(bmp);
        DeleteDC(memDC);
        EndPaint(hwnd, &ps);
        break;
    }

    case WM_MOUSEMOVE:
    {
        POINT p;
        GetCursorPos(&p);
        ScreenToClient(hwnd, &p);
        mousePos = p;

        // ... (логика hover остаётся похожей, только обновляем hovered)

        InvalidateRect(hwnd, nullptr, FALSE);
        TRACKMOUSEEVENT tme{sizeof(tme), TME_LEAVE, hwnd, 0};
        TrackMouseEvent(&tme);
        break;
    }

    // WM_LBUTTONDOWN, WM_DESTROY и т.д. — почти без изменений

    default:
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }
    return 0;
}

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR, int nCmdShow)
{
    GdiplusStartupInput gi;
    GdiplusStartup(&gdiToken, &gi, nullptr);

    WNDCLASSW wc{};
    wc.lpfnWndProc    = WndProc;
    wc.hInstance      = hInst;
    wc.lpszClassName  = L"MajesticLauncher";
    wc.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    RegisterClassW(&wc);

    HWND hwnd = CreateWindowExW(WS_EX_LAYERED | WS_EX_APPWINDOW,
        wc.lpszClassName, L"Majestic RP • Launcher",
        WS_POPUP,
        (GetSystemMetrics(SM_CXSCREEN)-W)/2,
        (GetSystemMetrics(SM_CYSCREEN)-H)/2,
        W, H,
        nullptr, nullptr, hInst, nullptr);

    SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    MSG msg{};
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    // cleanup
    delete background; delete logo;
    for (auto& img : newsImages) delete img;
    GdiplusShutdown(gdiToken);

    return (int)msg.wParam;
}
