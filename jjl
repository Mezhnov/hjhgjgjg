#include <windows.h>
#include <gdiplus.h>
#include <urlmon.h>
#include <shellapi.h>
#include <dwmapi.h>
#include <wchar.h>  // Для swprintf

#pragma comment(lib, "gdiplus.lib")
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "dwmapi.lib")

using namespace Gdiplus;

// ================= CONFIG =================
const int W = 1200;
const int H = 700;

const wchar_t* BG_URL = L"https://avatars.mds.yandex.net/i?id=36cbb9eb6253b776b00360ca303f84d7_l-12608381-images-thumbs&n=13";
const wchar_t* BG_FILE = L"background.jpg";
const wchar_t* LOGO_URL = L"https://i.imgur.com/placeholder.png"; // Replace with actual logo URL
const wchar_t* LOGO_FILE = L"logo.png";

const wchar_t* GTA_PATH = L"C:\\Games\\GTA5\\GTA5.exe";
// =========================================

ULONG_PTR gdiToken;
Image* background = nullptr;
Image* logo = nullptr;
bool isFullscreen = false;
RECT normalRect;
float progress = 0.0f; // For simulated progress bar
bool showNews = false; // Новое состояние для экрана новостей
int currentNewsIndex = 0; // Индекс текущей новости для карусели

// ================= СТРУКТУРА НОВОСТЕЙ =================
struct NewsItem {
    const wchar_t* title;
    const wchar_t* description;
    const wchar_t* imageUrl;
    const wchar_t* imageFile;
};

NewsItem newsItems[] = {
    { L"Обновление 1.5: Новые машины!", L"Добавлены новые автомобили и миссии. Подробности на форуме.", L"https://example.com/news1.jpg", L"news1.jpg" },
    { L"Конкурс на лучший билд", L"Участвуйте и выигрывайте призы! Срок до 20.01.2026.", L"https://example.com/news2.jpg", L"news2.jpg" },
    { L"Бан волна читеров", L"Очищаем сервер от нарушителей. Спасибо за репорты!", L"https://example.com/news3.jpg", L"news3.jpg" },
    // Добавьте больше новостей по необходимости
};
const int numNews = sizeof(newsItems) / sizeof(NewsItem);
Image* newsImages[3] = { nullptr, nullptr, nullptr }; // Кэш изображений (предполагаем 3 новости)

// ================= UI СТРУКТУРЫ =================
struct Button
{
    RECT rect;
    const wchar_t* text;
    bool hover;
    Color normalColor;
    Color hoverColor;
    int fontSize;
    const wchar_t* tooltip;
};

struct Panel
{
    RECT rect;
    Color bgColor;
    int borderRadius;
};

// ================= КНОПКИ =================
Button btnPlay = { {450, 500, 750, 580}, L"ЗАПУСТИТЬ ИГРУ", false, 
    Color(80, 255, 140, 0), Color(255, 255, 165, 0), 24, L"Запустить GTA V" };

Button btnNews = { {50, 180, 350, 250}, L"НОВОСТИ", false,
    Color(120, 30, 30, 35), Color(180, 40, 40, 45), 18, L"Просмотреть последние новости сервера" };

Button btnSettings = { {50, 270, 350, 340}, L"НАСТРОЙКИ", false,
    Color(120, 30, 30, 35), Color(180, 40, 40, 45), 18, L"Настроить лаунчер" };

Button btnDiscord = { {50, 360, 350, 430}, L"DISCORD", false,
    Color(120, 88, 101, 242), Color(200, 88, 101, 242), 18, L"Присоединиться к Discord сообществу" };

Button btnForum = { {50, 450, 350, 520}, L"ФОРУМ", false,
    Color(120, 30, 30, 35), Color(180, 40, 40, 45), 18, L"Посетить форум" };

Button btnDonate = { {850, 180, 1150, 250}, L"ДОНАТ", false,
    Color(120, 255, 215, 0), Color(200, 255, 215, 0), 18, L"Поддержать сервер" };

Button btnStats = { {850, 270, 1150, 340}, L"СТАТИСТИКА", false,
    Color(120, 30, 30, 35), Color(180, 40, 40, 45), 18, L"Просмотреть статистику" };

// Новые оригинальные кнопки
Button btnRules = { {850, 360, 1150, 430}, L"ПРАВИЛА", false,
    Color(120, 200, 0, 0), Color(180, 220, 20, 20), 18, L"Ознакомиться с правилами сервера" };

Button btnEvents = { {50, 540, 350, 610}, L"СОБЫТИЯ", false,
    Color(120, 0, 200, 200), Color(180, 20, 220, 220), 18, L"Просмотреть текущие события" };

// Системные кнопки
Button btnMinimize = { {W-140, 10, W-100, 40}, L"—", false,
    Color(0, 0, 0, 0), Color(100, 255, 255, 255), 20, L"Свернуть" };

Button btnMaximize = { {W-90, 10, W-50, 40}, L"□", false,
    Color(0, 0, 0, 0), Color(100, 255, 255, 255), 20, L"Развернуть/Свернуть" };

Button btnClose = { {W-40, 10, W-10, 40}, L"✕", false,
    Color(0, 0, 0, 0), Color(200, 255, 0, 0), 20, L"Закрыть" };

// Кнопки для новостей
Button btnNewsBack = { {50, 50, 150, 100}, L"НАЗАД", false,
    Color(120, 30, 30, 35), Color(180, 40, 40, 45), 18, L"Вернуться к главному экрану" };

Button btnNewsPrev = { {400, 600, 500, 650}, L"<", false,
    Color(120, 30, 30, 35), Color(180, 40, 40, 45), 24, L"Предыдущая новость" };

Button btnNewsNext = { {700, 600, 800, 650}, L">", false,
    Color(120, 30, 30, 35), Color(180, 40, 40, 45), 24, L"Следующая новость" };

// ================= ПАНЕЛИ =================
Panel mainPanel = { {30, 150, 370, 640}, Color(140, 15, 15, 20), 15 }; // Увеличена для новых кнопок
Panel rightPanel = { {830, 150, 1170, 460}, Color(140, 15, 15, 20), 15 }; // Увеличена
Panel playPanel = { {430, 480, 770, 600}, Color(0, 0, 0, 0), 20 };

Panel newsPanel = { {200, 100, 1000, 550}, Color(140, 15, 15, 20), 20 }; // Панель для новостей

// ================= УТИЛИТЫ =================
bool InRect(const POINT& p, const RECT& r)
{
    return p.x >= r.left && p.x <= r.right &&
           p.y >= r.top && p.y <= r.bottom;
}

void DrawRoundedRect(Graphics& g, Brush* brush, const RectF& rect, float radius)
{
    GraphicsPath path;
    path.AddArc(rect.X, rect.Y, radius * 2, radius * 2, 180, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y, radius * 2, radius * 2, 270, 90);
    path.AddArc(rect.X + rect.Width - radius * 2, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 0, 90);
    path.AddArc(rect.X, rect.Y + rect.Height - radius * 2, radius * 2, radius * 2, 90, 90);
    path.CloseFigure();
    
    g.FillPath(brush, &path);
}

void DrawPanel(Graphics& g, const Panel& p)
{
    SolidBrush brush(p.bgColor);
    RectF rect((REAL)p.rect.left, (REAL)p.rect.top,
               (REAL)(p.rect.right - p.rect.left),
               (REAL)(p.rect.bottom - p.rect.top));
    
    if (p.borderRadius > 0)
        DrawRoundedRect(g, &brush, rect, (float)p.borderRadius);
    else
        g.FillRectangle(&brush, rect);

    // Добавлена тень для панелей
    Pen shadowPen(Color(50, 0, 0, 0), 2.0f);
    GraphicsPath shadowPath;
    shadowPath.AddRectangle(rect);
    g.TranslateTransform(2.0f, 2.0f);
    g.DrawPath(&shadowPen, &shadowPath);
    g.ResetTransform();
}

void DrawButton(Graphics& g, const Button& b)
{
    Color bg = b.hover ? b.hoverColor : b.normalColor;
    SolidBrush brush(bg);
    
    RectF rect((REAL)b.rect.left, (REAL)b.rect.top,
               (REAL)(b.rect.right - b.rect.left),
               (REAL)(b.rect.bottom - b.rect.top));
    
    DrawRoundedRect(g, &brush, rect, 10.0f);
    
    // Улучшенная тень при наведении
    if (b.hover)
    {
        Pen shadowPen(Color(150, 255, 255, 255), 3.0f);
        shadowPen.SetDashStyle(DashStyleDot);
        GraphicsPath path;
        path.AddRectangle(rect);
        g.DrawPath(&shadowPen, &path);
    }
    
    FontFamily ff(L"Segoe UI");
    Font font(&ff, (REAL)b.fontSize, FontStyleBold);
    SolidBrush textBrush(Color::White);
    
    StringFormat format;
    format.SetAlignment(StringAlignmentCenter);
    format.SetLineAlignment(StringAlignmentCenter);
    
    g.DrawString(b.text, -1, &font, rect, &format, &textBrush);
}

void DrawTooltip(Graphics& g, const wchar_t* text, POINT p)
{
    if (!text) return;
    
    FontFamily ff(L"Segoe UI");
    Font font(&ff, 12.0f, FontStyleRegular);
    SolidBrush bgBrush(Color(200, 20, 20, 20));
    SolidBrush textBrush(Color::White);
    
    RectF boundRect;
    g.MeasureString(text, -1, &font, PointF(0,0), &boundRect);
    
    RectF tooltipRect((REAL)p.x + 20, (REAL)p.y, boundRect.Width + 20, boundRect.Height + 10);
    DrawRoundedRect(g, &bgBrush, tooltipRect, 5.0f);
    
    g.DrawString(text, -1, &font, PointF(tooltipRect.X + 10, tooltipRect.Y + 5), &textBrush);
}

void DrawGradientOverlay(Graphics& g)
{
    // Улучшенный градиент: от черного сверху к прозрачному снизу
    LinearGradientBrush gradient(
        Point(0, 0),
        Point(0, H),
        Color(220, 0, 0, 0),
        Color(0, 0, 0, 0)
    );
    g.FillRectangle(&gradient, 0, 0, W, H);
    
    // Добавлен боковой градиент для глубины
    LinearGradientBrush sideGradient(
        Point(0, 0),
        Point(W, 0),
        Color(100, 0, 0, 0),
        Color(0, 0, 0, 0)
    );
    g.FillRectangle(&sideGradient, 0, 0, W, H);
}

void DrawHeader(Graphics& g)
{
    // Улучшенная верхняя панель с градиентом
    LinearGradientBrush headerGradient(
        Point(0, 0),
        Point(0, 60),
        Color(200, 10, 10, 15),
        Color(100, 10, 10, 15)
    );
    g.FillRectangle(&headerGradient, 0, 0, W, 60);
    
    // Логотип
    if (logo)
        g.DrawImage(logo, 20, 10, 50, 50); // Добавлено рисование логотипа
    
    // Название с тенью
    FontFamily ff(L"Segoe UI");
    Font titleFont(&ff, 32.0f, FontStyleBold);
    
    SolidBrush shadow(Color(100, 0, 0, 0));
    SolidBrush orange(Color(255, 255, 140, 0));
    SolidBrush white(Color::White);
    
    // Тень для текста
    g.DrawString(L"MAJESTIC", -1, &titleFont, PointF(82.0f, 12.0f), &shadow);
    g.DrawString(L"ROLEPLAY", -1, &titleFont, PointF(262.0f, 12.0f), &shadow);
    
    g.DrawString(L"MAJESTIC", -1, &titleFont, PointF(80.0f, 10.0f), &orange);
    g.DrawString(L"ROLEPLAY", -1, &titleFont, PointF(260.0f, 10.0f), &white);
}

void DrawServerInfo(Graphics& g)
{
    FontFamily ff(L"Segoe UI");
    Font infoFont(&ff, 14.0f, FontStyleBold);
    Font smallFont(&ff, 11.0f, FontStyleRegular);
    
    SolidBrush white(Color::White);
    SolidBrush green(Color(255, 0, 255, 0));
    SolidBrush gray(Color(200, 200, 200, 200));
    
    // Статус сервера
    g.DrawString(L"● ONLINE", -1, &infoFont, PointF(W - 250.0f, 20.0f), &green);
    
    // Онлайн игроков с анимацией (статично, но можно расширить)
    g.DrawString(L"Онлайн: 2847/3000", -1, &smallFont, PointF(W - 380.0f, 23.0f), &gray);
}

void DrawInfoBoxes(Graphics& g)
{
    FontFamily ff(L"Segoe UI");
    Font titleFont(&ff, 16.0f, FontStyleBold);
    Font textFont(&ff, 12.0f, FontStyleRegular);
    
    SolidBrush white(Color::White);
    SolidBrush gray(Color(220, 200, 200, 200));
    
    // Информационные блоки с рамками
    const wchar_t* info1 = L"Версия игры";
    const wchar_t* value1 = L"3095.2";
    
    const wchar_t* info2 = L"Последнее обновление";
    const wchar_t* value2 = L"15.01.2025";
    
    // Добавлена рамка
    SolidBrush boxBg(Color(50, 255, 255, 255));
    RectF box1(440.0f, 390.0f, 140.0f, 60.0f);
    RectF box2(590.0f, 390.0f, 170.0f, 60.0f);
    DrawRoundedRect(g, &boxBg, box1, 5.0f);
    DrawRoundedRect(g, &boxBg, box2, 5.0f);
    
    g.DrawString(info1, -1, &textFont, PointF(450.0f, 400.0f), &gray);
    g.DrawString(value1, -1, &titleFont, PointF(450.0f, 420.0f), &white);
    
    g.DrawString(info2, -1, &textFont, PointF(600.0f, 400.0f), &gray);
    g.DrawString(value2, -1, &titleFont, PointF(600.0f, 420.0f), &white);
}

void DrawProgressBar(Graphics& g, float progress)
{
    RectF bgRect(450.0f, 630.0f, 300.0f, 12.0f); // Увеличена высота
    RectF progressRect(450.0f, 630.0f, 300.0f * progress, 12.0f);
    
    SolidBrush bgBrush(Color(100, 50, 50, 50));
    LinearGradientBrush progressBrush(
        PointF(450.0f, 630.0f),
        PointF(750.0f, 630.0f),
        Color(255, 255, 140, 0),
        Color(255, 200, 0, 0)
    );
    
    DrawRoundedRect(g, &bgBrush, bgRect, 6.0f);
    DrawRoundedRect(g, &progressBrush, progressRect, 6.0f);
    
    // Текст прогресса
    FontFamily ff(L"Segoe UI");
    Font font(&ff, 10.0f, FontStyleRegular);
    SolidBrush textBrush(Color::White);
    wchar_t progText[16];
    swprintf(progText, 16, L"%.0f%%", progress * 100);
    g.DrawString(progText, -1, &font, PointF(580.0f, 632.0f), &textBrush);
}

void DrawNews(Graphics& g)
{
    // Панель новостей
    DrawPanel(g, newsPanel);

    // Заголовок новости
    FontFamily ff(L"Segoe UI");
    Font titleFont(&ff, 24.0f, FontStyleBold);
    Font descFont(&ff, 14.0f, FontStyleRegular);
    SolidBrush white(Color::White);

    RectF titleRect(220.0f, 120.0f, 760.0f, 50.0f);
    g.DrawString(newsItems[currentNewsIndex].title, -1, &titleFont, titleRect, nullptr, &white);

    // Описание
    RectF descRect(220.0f, 180.0f, 760.0f, 200.0f);
    g.DrawString(newsItems[currentNewsIndex].description, -1, &descFont, descRect, nullptr, &white);

    // Изображение новости
    if (newsImages[currentNewsIndex])
    {
        g.DrawImage(newsImages[currentNewsIndex], 220, 400, 760, 120); // Размер изображения
    }

    // Кнопки карусели
    DrawButton(g, btnNewsPrev);
    DrawButton(g, btnNewsNext);

    // Индикатор текущей новости
    wchar_t indexText[16];
    swprintf(indexText, 16, L"%d / %d", currentNewsIndex + 1, numNews);
    g.DrawString(indexText, -1, &descFont, PointF(580.0f, 620.0f), &white);

    // Кнопка назад
    DrawButton(g, btnNewsBack);
}

// ================= WINDOW PROC =================
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM w, LPARAM l)
{
    static POINT mousePos;
    static const Button* hoveredButton = nullptr;

    switch (msg)
    {
    case WM_CREATE:
    {
        // Скругленные углы окна (Windows 11)
        DWM_WINDOW_CORNER_PREFERENCE preference = DWMWCP_ROUND;
        DwmSetWindowAttribute(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, &preference, sizeof(preference));
        
        // Загрузка ресурсов
        URLDownloadToFileW(nullptr, BG_URL, BG_FILE, 0, nullptr);
        background = Image::FromFile(BG_FILE);
        
        URLDownloadToFileW(nullptr, LOGO_URL, LOGO_FILE, 0, nullptr);
        logo = Image::FromFile(LOGO_FILE);
        
        // Загрузка изображений новостей
        for (int i = 0; i < numNews; ++i)
        {
            URLDownloadToFileW(nullptr, newsItems[i].imageUrl, newsItems[i].imageFile, 0, nullptr);
            newsImages[i] = Image::FromFile(newsItems[i].imageFile);
        }
        
        // Симуляция прогресса (таймер для анимации)
        SetTimer(hwnd, 1, 50, nullptr); // Оригинальное добавление: анимированный прогресс бар
        
        break;
    }

    case WM_TIMER:
    {
        if (w == 1)
        {
            progress += 0.01f;
            if (progress > 1.0f) progress = 1.0f;
            InvalidateRect(hwnd, nullptr, FALSE);
        }
        break;
    }

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        
        // Двойная буферизация
        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP memBitmap = CreateCompatibleBitmap(hdc, W, H);
        SelectObject(memDC, memBitmap);
        
        Graphics g(memDC);
        g.SetSmoothingMode(SmoothingModeAntiAlias);
        g.SetTextRenderingHint(TextRenderingHintAntiAlias);
        g.SetInterpolationMode(InterpolationModeHighQualityBicubic);
        
        // Фон
        if (background)
            g.DrawImage(background, 0, 0, W, H);
        
        DrawGradientOverlay(g);
        
        // UI элементы
        DrawHeader(g);
        DrawServerInfo(g);
        
        if (!showNews)
        {
            DrawPanel(g, mainPanel);
            DrawPanel(g, rightPanel);
            
            DrawButton(g, btnNews);
            DrawButton(g, btnSettings);
            DrawButton(g, btnDiscord);
            DrawButton(g, btnForum);
            DrawButton(g, btnDonate);
            DrawButton(g, btnStats);
            DrawButton(g, btnRules); // Новая
            DrawButton(g, btnEvents); // Новая
            
            DrawInfoBoxes(g);
            DrawButton(g, btnPlay);
            
            DrawProgressBar(g, progress); // Добавлено рисование прогресс бара (симулирует загрузку/обновление)
        }
        else
        {
            DrawNews(g);
        }
        
        // Системные кнопки
        DrawButton(g, btnMinimize);
        DrawButton(g, btnMaximize);
        DrawButton(g, btnClose);
        
        // Тултип если есть
        if (hoveredButton)
            DrawTooltip(g, hoveredButton->tooltip, mousePos);
        
        BitBlt(hdc, 0, 0, W, H, memDC, 0, 0, SRCCOPY);
        
        DeleteObject(memBitmap);
        DeleteDC(memDC);
        EndPaint(hwnd, &ps);
        break;
    }

    case WM_MOUSEMOVE:
    {
        POINT p;
        GetCursorPos(&p);
        ScreenToClient(hwnd, &p);
        mousePos = p;
        
        Button* buttons[] = { nullptr };
        if (!showNews)
        {
            buttons[0] = &btnPlay; buttons[1] = &btnNews; buttons[2] = &btnSettings; buttons[3] = &btnDiscord;
            buttons[4] = &btnForum; buttons[5] = &btnDonate; buttons[6] = &btnStats; buttons[7] = &btnRules;
            buttons[8] = &btnEvents; buttons[9] = &btnMinimize; buttons[10] = &btnMaximize; buttons[11] = &btnClose;
        }
        else
        {
            buttons[0] = &btnNewsBack; buttons[1] = &btnNewsPrev; buttons[2] = &btnNewsNext;
            buttons[3] = &btnMinimize; buttons[4] = &btnMaximize; buttons[5] = &btnClose;
        }
        
        bool needRedraw = false;
        const Button* newHover = nullptr;
        for (int i = 0; buttons[i] != nullptr; ++i)
        {
            Button* b = buttons[i];
            bool old = b->hover;
            b->hover = InRect(p, b->rect);
            if (old != b->hover) needRedraw = true;
            if (b->hover) newHover = b;
        }
        
        if (hoveredButton != newHover)
        {
            hoveredButton = newHover;
            needRedraw = true;
        }
        
        if (needRedraw)
            InvalidateRect(hwnd, nullptr, FALSE);
        
        // Трекинг для тултипов
        TRACKMOUSEEVENT tme = { sizeof(tme) };
        tme.dwFlags = TME_LEAVE;
        tme.hwndTrack = hwnd;
        TrackMouseEvent(&tme);
        break;
    }

    case WM_MOUSELEAVE:
    {
        hoveredButton = nullptr;
        InvalidateRect(hwnd, nullptr, FALSE);
        break;
    }

    case WM_LBUTTONDOWN:
    {
        POINT p;
        GetCursorPos(&p);
        ScreenToClient(hwnd, &p);
        
        if (!showNews)
        {
            if (InRect(p, btnPlay.rect))
            {
                ShellExecuteW(nullptr, L"open", GTA_PATH, nullptr, nullptr, SW_SHOW);
            }
            else if (InRect(p, btnDiscord.rect))
            {
                ShellExecuteW(nullptr, L"open", L"https://discord.gg/majestic", nullptr, nullptr, SW_SHOW);
            }
            else if (InRect(p, btnForum.rect))
            {
                ShellExecuteW(nullptr, L"open", L"https://majestic-rp.ru/forum", nullptr, nullptr, SW_SHOW);
            }
            else if (InRect(p, btnDonate.rect))
            {
                ShellExecuteW(nullptr, L"open", L"https://majestic-rp.ru/donate", nullptr, nullptr, SW_SHOW);
            }
            else if (InRect(p, btnSettings.rect))
            {
                MessageBoxW(hwnd, L"Настройки в разработке", L"Majestic RP", MB_ICONINFORMATION);
            }
            else if (InRect(p, btnNews.rect))
            {
                showNews = true;
                InvalidateRect(hwnd, nullptr, FALSE);
            }
            else if (InRect(p, btnStats.rect))
            {
                MessageBoxW(hwnd, L"Статистика персонажа", L"Статистика", MB_ICONINFORMATION);
            }
            else if (InRect(p, btnRules.rect))
            {
                MessageBoxW(hwnd, L"Правила сервера: Не читерить, уважать других и т.д.", L"Правила", MB_ICONINFORMATION);
            }
            else if (InRect(p, btnEvents.rect))
            {
                MessageBoxW(hwnd, L"Текущие события: Конкурс на лучший билд!", L"События", MB_ICONINFORMATION);
            }
        }
        else
        {
            if (InRect(p, btnNewsBack.rect))
            {
                showNews = false;
                InvalidateRect(hwnd, nullptr, FALSE);
            }
            else if (InRect(p, btnNewsPrev.rect))
            {
                currentNewsIndex = (currentNewsIndex - 1 + numNews) % numNews;
                InvalidateRect(hwnd, nullptr, FALSE);
            }
            else if (InRect(p, btnNewsNext.rect))
            {
                currentNewsIndex = (currentNewsIndex + 1) % numNews;
                InvalidateRect(hwnd, nullptr, FALSE);
            }
        }
        
        if (InRect(p, btnClose.rect))
        {
            PostQuitMessage(0);
        }
        else if (InRect(p, btnMinimize.rect))
        {
            ShowWindow(hwnd, SW_MINIMIZE);
        }
        else if (InRect(p, btnMaximize.rect))
        {
            if (!isFullscreen)
            {
                GetWindowRect(hwnd, &normalRect);
                MONITORINFO mi = { sizeof(mi) };
                GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST), &mi);
                SetWindowPos(hwnd, HWND_TOP,
                    mi.rcMonitor.left, mi.rcMonitor.top,
                    mi.rcMonitor.right - mi.rcMonitor.left,
                    mi.rcMonitor.bottom - mi.rcMonitor.top,
                    SWP_FRAMECHANGED);
                isFullscreen = true;
            }
            else
            {
                SetWindowPos(hwnd, HWND_TOP,
                    normalRect.left, normalRect.top,
                    normalRect.right - normalRect.left,
                    normalRect.bottom - normalRect.top,
                    SWP_FRAMECHANGED);
                isFullscreen = false;
            }
        }
        else if (p.y < 60 && !showNews) // Перетаскивание за header только на главном экране
        {
            SendMessage(hwnd, WM_NCLBUTTONDOWN, HTCAPTION, 0);
        }
        
        break;
    }

    case WM_DESTROY:
        delete background;
        delete logo;
        for (int i = 0; i < numNews; ++i)
        {
            delete newsImages[i];
        }
        GdiplusShutdown(gdiToken);
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProcW(hwnd, msg, w, l);
    }
    return 0;
}

// ================= WINMAIN =================
int WINAPI WinMain(HINSTANCE h, HINSTANCE, LPSTR, int)
{
    GdiplusStartupInput gdi;
    GdiplusStartup(&gdiToken, &gdi, nullptr);
    
    WNDCLASSW wc{};
    wc.lpfnWndProc = WndProc;
    wc.hInstance = h;
    wc.lpszClassName = L"MAJESTIC_LAUNCHER";
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    
    RegisterClassW(&wc);
    
    HWND hwnd = CreateWindowExW(
        WS_EX_LAYERED,
        wc.lpszClassName,
        L"Majestic RP Launcher",
        WS_POPUP,
        (GetSystemMetrics(SM_CXSCREEN) - W) / 2,
        (GetSystemMetrics(SM_CYSCREEN) - H) / 2,
        W, H,
        nullptr, nullptr, h, nullptr
    );
    
    SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);
    
    MSG msg{};
    while (GetMessageW(&msg, nullptr, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    
    return 0;
}
